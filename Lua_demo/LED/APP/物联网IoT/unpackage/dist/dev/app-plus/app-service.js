(this["webpackJsonp"] = this["webpackJsonp"] || []).push([["app-service"],[
/* 0 */
/*!*******************************************************************!*\
  !*** F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/main.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("__webpack_require__(/*! uni-pages */ 1);var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 8));\nvar _App = _interopRequireDefault(__webpack_require__(/*! ./App */ 9));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}\n\n_vue.default.config.productionTip = false;\n\n_App.default.mpType = 'app';\n\nvar app = new _vue.default(_objectSpread({},\n_App.default));\n\napp.$mount();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vbWFpbi5qcyJdLCJuYW1lcyI6WyJWdWUiLCJjb25maWciLCJwcm9kdWN0aW9uVGlwIiwiQXBwIiwibXBUeXBlIiwiYXBwIiwiJG1vdW50Il0sIm1hcHBpbmdzIjoiQUFBQSx3Q0FBbUI7QUFDbkIsdUU7O0FBRUFBLGFBQUlDLE1BQUosQ0FBV0MsYUFBWCxHQUEyQixLQUEzQjs7QUFFQUMsYUFBSUMsTUFBSixHQUFhLEtBQWI7O0FBRUEsSUFBTUMsR0FBRyxHQUFHLElBQUlMLFlBQUo7QUFDTEcsWUFESyxFQUFaOztBQUdBRSxHQUFHLENBQUNDLE1BQUoiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAndW5pLXBhZ2VzJztpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuaW1wb3J0IEFwcCBmcm9tICcuL0FwcCdcclxuXHJcblZ1ZS5jb25maWcucHJvZHVjdGlvblRpcCA9IGZhbHNlXHJcblxyXG5BcHAubXBUeXBlID0gJ2FwcCdcclxuXHJcbmNvbnN0IGFwcCA9IG5ldyBWdWUoe1xyXG4gICAgLi4uQXBwXHJcbn0pXHJcbmFwcC4kbW91bnQoKSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!**********************************************************************!*\
  !*** F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/pages.json ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


if (typeof Promise !== 'undefined' && !Promise.prototype.finally) {
  Promise.prototype.finally = function (callback) {
    var promise = this.constructor;
    return this.then(
    function (value) {return promise.resolve(callback()).then(function () {return value;});},
    function (reason) {return promise.resolve(callback()).then(function () {
        throw reason;
      });});

  };
}
if (uni.restoreGlobal) {
  uni.restoreGlobal(weex, plus, setTimeout, clearTimeout, setInterval, clearInterval);
}
__definePage('pages/index/index', function () {return Vue.extend(__webpack_require__(/*! pages/index/index.vue?mpType=page */ 2).default);});
__definePage('pages/mqtt/mqtt', function () {return Vue.extend(__webpack_require__(/*! pages/mqtt/mqtt.vue?mpType=page */ 13).default);});

/***/ }),
/* 2 */
/*!*********************************************************************************************!*\
  !*** F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/pages/index/index.vue?mpType=page ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.vue?vue&type=template&id=2be84a3c&mpType=page */ 3);\n/* harmony import */ var _index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.vue?vue&type=script&lang=js&mpType=page */ 5);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js */ 7);\n\nvar renderjs\n\n\n\n\n/* normalize component */\n\nvar component = Object(_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null,\n  false,\n  _index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"components\"],\n  renderjs\n)\n\ncomponent.options.__file = \"pages/index/index.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNkg7QUFDN0g7QUFDb0U7QUFDTDs7O0FBRy9EO0FBQ21OO0FBQ25OLGdCQUFnQiw0TUFBVTtBQUMxQixFQUFFLHNGQUFNO0FBQ1IsRUFBRSwyRkFBTTtBQUNSLEVBQUUsb0dBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsK0ZBQVU7QUFDWjtBQUNBOztBQUVBO0FBQ2UsZ0YiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zLCByZWN5Y2xhYmxlUmVuZGVyLCBjb21wb25lbnRzIH0gZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTJiZTg0YTNjJm1wVHlwZT1wYWdlXCJcbnZhciByZW5kZXJqc1xuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmbXBUeXBlPXBhZ2VcIlxuZXhwb3J0ICogZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJm1wVHlwZT1wYWdlXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL+i/hembt+S4i+i9vS9IQnVpbGRlclguMi42LjExLjIwMjAwNDA5LmZ1bGwvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsLFxuICBmYWxzZSxcbiAgY29tcG9uZW50cyxcbiAgcmVuZGVyanNcbilcblxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJwYWdlcy9pbmRleC9pbmRleC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!***************************************************************************************************************************!*\
  !*** F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/pages/index/index.vue?vue&type=template&id=2be84a3c&mpType=page ***!
  \***************************************************************************************************************************/
/*! exports provided: render, staticRenderFns, recyclableRender, components */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--10-0!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/filter-modules-template.js!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/page-meta.js!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./index.vue?vue&type=template&id=2be84a3c&mpType=page */ 4);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "recyclableRender", function() { return _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__["recyclableRender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "components", function() { return _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__["components"]; });



/***/ }),
/* 4 */
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--10-0!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/filter-modules-template.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/page-meta.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/pages/index/index.vue?vue&type=template&id=2be84a3c&mpType=page ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns, recyclableRender, components */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recyclableRender", function() { return recyclableRender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "components", function() { return components; });
var components
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "view",
    { staticClass: _vm._$s(0, "sc", "content"), attrs: { _i: 0 } },
    [
      _c(
        "view",
        { staticClass: _vm._$s(1, "sc", "text-area"), attrs: { _i: 1 } },
        [
          _c(
            "text",
            { staticClass: _vm._$s(2, "sc", "title"), attrs: { _i: 2 } },
            [_vm._v(_vm._$s(2, "t0-0", _vm._s(_vm.title)))]
          )
        ]
      )
    ]
  )
}
var recyclableRender = false
var staticRenderFns = []
render._withStripped = true



/***/ }),
/* 5 */
/*!*********************************************************************************************************************!*\
  !*** F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/pages/index/index.vue?vue&type=script&lang=js&mpType=page ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/babel-loader/lib!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--6-1!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./index.vue?vue&type=script&lang=js&mpType=page */ 6);\n/* harmony import */ var _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTR1QixDQUFnQixrc0JBQUcsRUFBQyIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi/ov4Xpm7fkuIvovb0vSEJ1aWxkZXJYLjIuNi4xMS4yMDIwMDQwOS5mdWxsL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4v6L+F6Zu35LiL6L29L0hCdWlsZGVyWC4yLjYuMTEuMjAyMDA0MDkuZnVsbC9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3dlYnBhY2stcHJlcHJvY2Vzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi0xIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL+i/hembt+S4i+i9vS9IQnVpbGRlclguMi42LjExLjIwMjAwNDA5LmZ1bGwvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy93ZWJwYWNrLXVuaS1hcHAtbG9hZGVyL3VzaW5nLWNvbXBvbmVudHMuanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4v6L+F6Zu35LiL6L29L0hCdWlsZGVyWC4yLjYuMTEuMjAyMDA0MDkuZnVsbC9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmbXBUeXBlPXBhZ2VcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi/ov4Xpm7fkuIvovb0vSEJ1aWxkZXJYLjIuNi4xMS4yMDIwMDQwOS5mdWxsL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4v6L+F6Zu35LiL6L29L0hCdWlsZGVyWC4yLjYuMTEuMjAyMDA0MDkuZnVsbC9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3dlYnBhY2stcHJlcHJvY2Vzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi0xIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL+i/hembt+S4i+i9vS9IQnVpbGRlclguMi42LjExLjIwMjAwNDA5LmZ1bGwvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy93ZWJwYWNrLXVuaS1hcHAtbG9hZGVyL3VzaW5nLWNvbXBvbmVudHMuanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4v6L+F6Zu35LiL6L29L0hCdWlsZGVyWC4yLjYuMTEuMjAyMDA0MDkuZnVsbC9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmbXBUeXBlPXBhZ2VcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--6-1!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/pages/index/index.vue?vue&type=script&lang=js&mpType=page ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = void 0; //\n//\n//\n//\n//\n//\n//\n//\n//\nvar _default =\n{\n  data: function data() {\n    return {\n      title: 'Hello' };\n\n  },\n  onLoad: function onLoad() {\n\n  },\n  methods: {} };exports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vcGFnZXMvaW5kZXgvaW5kZXgudnVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFVQTtBQUNBLE1BREEsa0JBQ0E7QUFDQTtBQUNBLG9CQURBOztBQUdBLEdBTEE7QUFNQSxRQU5BLG9CQU1BOztBQUVBLEdBUkE7QUFTQSxhQVRBLEUiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuXHQ8dmlldyBjbGFzcz1cImNvbnRlbnRcIj5cclxuXHRcdDwhLS0gPGltYWdlIGNsYXNzPVwibG9nb1wiIHNyYz1cIi9zdGF0aWMvbG9nby5wbmdcIj48L2ltYWdlPiAtLT5cclxuXHRcdDx2aWV3IGNsYXNzPVwidGV4dC1hcmVhXCI+XHJcblx0XHRcdDx0ZXh0IGNsYXNzPVwidGl0bGVcIj57e3RpdGxlfX08L3RleHQ+XHJcblx0XHQ8L3ZpZXc+XHJcblx0PC92aWV3PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRkYXRhKCkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHRpdGxlOiAnSGVsbG8nXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvbkxvYWQoKSB7XHJcblxyXG5cdFx0fSxcclxuXHRcdG1ldGhvZHM6IHtcclxuXHJcblx0XHR9XHJcblx0fVxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHQuY29udGVudCB7XHJcblx0XHRkaXNwbGF5OiBmbGV4O1xyXG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuXHR9XHJcblxyXG5cdC5sb2dvIHtcclxuXHRcdGhlaWdodDogMjAwcnB4O1xyXG5cdFx0d2lkdGg6IDIwMHJweDtcclxuXHRcdG1hcmdpbi10b3A6IDIwMHJweDtcclxuXHRcdG1hcmdpbi1sZWZ0OiBhdXRvO1xyXG5cdFx0bWFyZ2luLXJpZ2h0OiBhdXRvO1xyXG5cdFx0bWFyZ2luLWJvdHRvbTogNTBycHg7XHJcblx0fVxyXG5cclxuXHQudGV4dC1hcmVhIHtcclxuXHRcdGRpc3BsYXk6IGZsZXg7XHJcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuXHR9XHJcblxyXG5cdC50aXRsZSB7XHJcblx0XHRmb250LXNpemU6IDM2cnB4O1xyXG5cdFx0Y29sb3I6ICM4ZjhmOTQ7XHJcblx0fVxyXG48L3N0eWxlPlxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode, /* vue-cli only */
  components, // fixed by xxxxxx auto components
  renderjs // fixed by xxxxxx renderjs
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // fixed by xxxxxx auto components
  if (components) {
    if (!options.components) {
      options.components = {}
    }
    var hasOwn = Object.prototype.hasOwnProperty
    for (var name in components) {
      if (hasOwn.call(components, name) && !hasOwn.call(options.components, name)) {
        options.components[name] = components[name]
      }
    }
  }
  // fixed by xxxxxx renderjs
  if (renderjs) {
    (renderjs.beforeCreate || (renderjs.beforeCreate = [])).unshift(function() {
      this[renderjs.__module] = this
    });
    (options.mixins || (options.mixins = [])).push(renderjs)
  }

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 8 */
/*!**********************!*\
  !*** external "Vue" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Vue;

/***/ }),
/* 9 */
/*!*******************************************************************!*\
  !*** F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/App.vue ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=script&lang=js& */ 10);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js */ 7);\nvar render, staticRenderFns, recyclableRender, components\nvar renderjs\n\n\n\n\n/* normalize component */\n\nvar component = Object(_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n  _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null,\n  false,\n  components,\n  renderjs\n)\n\ncomponent.options.__file = \"App.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUN1RDtBQUNMOzs7QUFHbEQ7QUFDNk07QUFDN00sZ0JBQWdCLDRNQUFVO0FBQzFCLEVBQUUseUVBQU07QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNlLGdGIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMsIHJlY3ljbGFibGVSZW5kZXIsIGNvbXBvbmVudHNcbnZhciByZW5kZXJqc1xuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi8uLi8uLi/ov4Xpm7fkuIvovb0vSEJ1aWxkZXJYLjIuNi4xMS4yMDIwMDQwOS5mdWxsL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL0BkY2xvdWRpby92dWUtY2xpLXBsdWdpbi11bmkvcGFja2FnZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgZmFsc2UsXG4gIGNvbXBvbmVudHMsXG4gIHJlbmRlcmpzXG4pXG5cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiQXBwLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/*!********************************************************************************************!*\
  !*** F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/App.vue?vue&type=script&lang=js& ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/babel-loader/lib!../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--6-1!../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./App.vue?vue&type=script&lang=js& */ 11);\n/* harmony import */ var _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXVzQixDQUFnQixxckJBQUcsRUFBQyIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vLi4v6L+F6Zu35LiL6L29L0hCdWlsZGVyWC4yLjYuMTEuMjAyMDA0MDkuZnVsbC9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uLy4uL+i/hembt+S4i+i9vS9IQnVpbGRlclguMi42LjExLjIwMjAwNDA5LmZ1bGwvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy93ZWJwYWNrLXByZXByb2Nlc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTYtMSEuLi8uLi8uLi8uLi8uLi8uLi/ov4Xpm7fkuIvovb0vSEJ1aWxkZXJYLjIuNi4xMS4yMDIwMDQwOS5mdWxsL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL0BkY2xvdWRpby92dWUtY2xpLXBsdWdpbi11bmkvcGFja2FnZXMvd2VicGFjay11bmktYXBwLWxvYWRlci91c2luZy1jb21wb25lbnRzLmpzIS4uLy4uLy4uLy4uLy4uLy4uL+i/hembt+S4i+i9vS9IQnVpbGRlclguMi42LjExLjIwMjAwNDA5LmZ1bGwvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi/ov4Xpm7fkuIvovb0vSEJ1aWxkZXJYLjIuNi4xMS4yMDIwMDQwOS5mdWxsL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vLi4v6L+F6Zu35LiL6L29L0hCdWlsZGVyWC4yLjYuMTEuMjAyMDA0MDkuZnVsbC9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3dlYnBhY2stcHJlcHJvY2Vzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi0xIS4uLy4uLy4uLy4uLy4uLy4uL+i/hembt+S4i+i9vS9IQnVpbGRlclguMi42LjExLjIwMjAwNDA5LmZ1bGwvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy93ZWJwYWNrLXVuaS1hcHAtbG9hZGVyL3VzaW5nLWNvbXBvbmVudHMuanMhLi4vLi4vLi4vLi4vLi4vLi4v6L+F6Zu35LiL6L29L0hCdWlsZGVyWC4yLjYuMTEuMjAyMDA0MDkuZnVsbC9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--6-1!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/App.vue?vue&type=script&lang=js& ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__f__) {Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = void 0;var _default =\n{\n  onLaunch: function onLaunch() {\n    __f__(\"log\", 'App Launch', \" at App.vue:4\");\n  },\n  onShow: function onShow() {\n    __f__(\"log\", 'App Show', \" at App.vue:7\");\n  },\n  onHide: function onHide() {\n    __f__(\"log\", 'App Hide', \" at App.vue:10\");\n  } };exports.default = _default;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/format-log.js */ 12)[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vQXBwLnZ1ZSJdLCJuYW1lcyI6WyJvbkxhdW5jaCIsIm9uU2hvdyIsIm9uSGlkZSJdLCJtYXBwaW5ncyI6IjtBQUNlO0FBQ2RBLFVBQVEsRUFBRSxvQkFBVztBQUNwQixpQkFBWSxZQUFaO0FBQ0EsR0FIYTtBQUlkQyxRQUFNLEVBQUUsa0JBQVc7QUFDbEIsaUJBQVksVUFBWjtBQUNBLEdBTmE7QUFPZEMsUUFBTSxFQUFFLGtCQUFXO0FBQ2xCLGlCQUFZLFVBQVo7QUFDQSxHQVRhLEUiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBkZWZhdWx0IHtcblx0b25MYXVuY2g6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnNvbGUubG9nKCdBcHAgTGF1bmNoJylcblx0fSxcblx0b25TaG93OiBmdW5jdGlvbigpIHtcblx0XHRjb25zb2xlLmxvZygnQXBwIFNob3cnKVxuXHR9LFxuXHRvbkhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnNvbGUubG9nKCdBcHAgSGlkZScpXG5cdH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/*!*********************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/format-log.js ***!
  \*********************************************************************/
/*! exports provided: log, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return formatLog; });
function typof (v) {
  var s = Object.prototype.toString.call(v)
  return s.substring(8, s.length - 1)
}

function isDebugMode () {
  /* eslint-disable no-undef */
  return typeof __channelId__ === 'string' && __channelId__
}

function log (type) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key]
  }
  console[type].apply(console, args)
}

function formatLog () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key]
  }
  var type = args.shift()
  if (isDebugMode()) {
    args.push(args.pop().replace('at ', 'uni-app:///'))
    return console[type].apply(console, args)
  }

  var msgs = args.map(function (v) {
    var type = Object.prototype.toString.call(v).toLowerCase()

    if (type === '[object object]' || type === '[object array]') {
      try {
        v = '---BEGIN:JSON---' + JSON.stringify(v) + '---END:JSON---'
      } catch (e) {
        v = '[object object]'
      }
    } else {
      if (v === null) {
        v = '---NULL---'
      } else if (v === undefined) {
        v = '---UNDEFINED---'
      } else {
        var vType = typof(v).toUpperCase()

        if (vType === 'NUMBER' || vType === 'BOOLEAN') {
          v = '---BEGIN:' + vType + '---' + v + '---END:' + vType + '---'
        } else {
          v = String(v)
        }
      }
    }

    return v
  })
  var msg = ''

  if (msgs.length > 1) {
    var lastMsg = msgs.pop()
    msg = msgs.join('---COMMA---')

    if (lastMsg.indexOf(' at ') === 0) {
      msg += lastMsg
    } else {
      msg += '---COMMA---' + lastMsg
    }
  } else {
    msg = msgs[0]
  }

  console[type](msg)
}


/***/ }),
/* 13 */
/*!*******************************************************************************************!*\
  !*** F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/pages/mqtt/mqtt.vue?mpType=page ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mqtt_vue_vue_type_template_id_14d20054_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mqtt.vue?vue&type=template&id=14d20054&mpType=page */ 14);\n/* harmony import */ var _mqtt_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mqtt.vue?vue&type=script&lang=js&mpType=page */ 16);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _mqtt_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _mqtt_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js */ 7);\n\nvar renderjs\n\n\n\n\n/* normalize component */\n\nvar component = Object(_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _mqtt_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _mqtt_vue_vue_type_template_id_14d20054_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _mqtt_vue_vue_type_template_id_14d20054_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null,\n  false,\n  _mqtt_vue_vue_type_template_id_14d20054_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"components\"],\n  renderjs\n)\n\ncomponent.options.__file = \"pages/mqtt/mqtt.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNEg7QUFDNUg7QUFDbUU7QUFDTDs7O0FBRzlEO0FBQ21OO0FBQ25OLGdCQUFnQiw0TUFBVTtBQUMxQixFQUFFLHFGQUFNO0FBQ1IsRUFBRSwwRkFBTTtBQUNSLEVBQUUsbUdBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsOEZBQVU7QUFDWjtBQUNBOztBQUVBO0FBQ2UsZ0YiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucywgcmVjeWNsYWJsZVJlbmRlciwgY29tcG9uZW50cyB9IGZyb20gXCIuL21xdHQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTE0ZDIwMDU0Jm1wVHlwZT1wYWdlXCJcbnZhciByZW5kZXJqc1xuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9tcXR0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZtcFR5cGU9cGFnZVwiXG5leHBvcnQgKiBmcm9tIFwiLi9tcXR0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZtcFR5cGU9cGFnZVwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi/ov4Xpm7fkuIvovb0vSEJ1aWxkZXJYLjIuNi4xMS4yMDIwMDQwOS5mdWxsL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL0BkY2xvdWRpby92dWUtY2xpLXBsdWdpbi11bmkvcGFja2FnZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgZmFsc2UsXG4gIGNvbXBvbmVudHMsXG4gIHJlbmRlcmpzXG4pXG5cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwicGFnZXMvbXF0dC9tcXR0LnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/*!*************************************************************************************************************************!*\
  !*** F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/pages/mqtt/mqtt.vue?vue&type=template&id=14d20054&mpType=page ***!
  \*************************************************************************************************************************/
/*! exports provided: render, staticRenderFns, recyclableRender, components */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_mqtt_vue_vue_type_template_id_14d20054_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--10-0!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/filter-modules-template.js!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/page-meta.js!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./mqtt.vue?vue&type=template&id=14d20054&mpType=page */ 15);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_mqtt_vue_vue_type_template_id_14d20054_mpType_page__WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_mqtt_vue_vue_type_template_id_14d20054_mpType_page__WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "recyclableRender", function() { return _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_mqtt_vue_vue_type_template_id_14d20054_mpType_page__WEBPACK_IMPORTED_MODULE_0__["recyclableRender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "components", function() { return _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_mqtt_vue_vue_type_template_id_14d20054_mpType_page__WEBPACK_IMPORTED_MODULE_0__["components"]; });



/***/ }),
/* 15 */
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--10-0!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/filter-modules-template.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/page-meta.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/pages/mqtt/mqtt.vue?vue&type=template&id=14d20054&mpType=page ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns, recyclableRender, components */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recyclableRender", function() { return recyclableRender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "components", function() { return components; });
var components
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("view", [
    _c("button", { attrs: { _i: 1 }, on: { click: _vm.connect } }),
    _c("button", { attrs: { _i: 2 }, on: { click: _vm.subscribe } }),
    _c("button", { attrs: { _i: 3 }, on: { click: _vm.TurnON } }),
    _c("button", { attrs: { _i: 4 }, on: { click: _vm.TurnOFF } }),
    _c("button", { attrs: { _i: 5 }, on: { click: _vm.unsubscribe } }),
    _c("button", { attrs: { _i: 6 }, on: { click: _vm.unconnect } }),
    _c("view", [
      _vm._v(_vm._$s(7, "t0-0", _vm._s(_vm.receiveMessage.toString())))
    ])
  ])
}
var recyclableRender = false
var staticRenderFns = []
render._withStripped = true



/***/ }),
/* 16 */
/*!*******************************************************************************************************************!*\
  !*** F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/pages/mqtt/mqtt.vue?vue&type=script&lang=js&mpType=page ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_mqtt_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/babel-loader/lib!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--6-1!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!../../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./mqtt.vue?vue&type=script&lang=js&mpType=page */ 17);\n/* harmony import */ var _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_mqtt_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_mqtt_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_mqtt_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_mqtt_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_HBuilderX_2_6_11_20200409_full_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_mqtt_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJ1QixDQUFnQixpc0JBQUcsRUFBQyIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4v6L+F6Zu35LiL6L29L0hCdWlsZGVyWC4yLjYuMTEuMjAyMDA0MDkuZnVsbC9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL+i/hembt+S4i+i9vS9IQnVpbGRlclguMi42LjExLjIwMjAwNDA5LmZ1bGwvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy93ZWJwYWNrLXByZXByb2Nlc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTYtMSEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi/ov4Xpm7fkuIvovb0vSEJ1aWxkZXJYLjIuNi4xMS4yMDIwMDQwOS5mdWxsL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL0BkY2xvdWRpby92dWUtY2xpLXBsdWdpbi11bmkvcGFja2FnZXMvd2VicGFjay11bmktYXBwLWxvYWRlci91c2luZy1jb21wb25lbnRzLmpzIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL+i/hembt+S4i+i9vS9IQnVpbGRlclguMi42LjExLjIwMjAwNDA5LmZ1bGwvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbXF0dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmbXBUeXBlPXBhZ2VcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi/ov4Xpm7fkuIvovb0vSEJ1aWxkZXJYLjIuNi4xMS4yMDIwMDQwOS5mdWxsL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4v6L+F6Zu35LiL6L29L0hCdWlsZGVyWC4yLjYuMTEuMjAyMDA0MDkuZnVsbC9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3dlYnBhY2stcHJlcHJvY2Vzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi0xIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL+i/hembt+S4i+i9vS9IQnVpbGRlclguMi42LjExLjIwMjAwNDA5LmZ1bGwvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy93ZWJwYWNrLXVuaS1hcHAtbG9hZGVyL3VzaW5nLWNvbXBvbmVudHMuanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4v6L+F6Zu35LiL6L29L0hCdWlsZGVyWC4yLjYuMTEuMjAyMDA0MDkuZnVsbC9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9tcXR0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZtcFR5cGU9cGFnZVwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--6-1!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/pages/mqtt/mqtt.vue?vue&type=script&lang=js&mpType=page ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__f__) {Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = void 0;\n\n\n\n\n\n\n\n\n\n\n\n\nvar _mqtt = _interopRequireDefault(__webpack_require__(/*! ../../utils/mqtt.js */ 18));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };} //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//二选一\n//import mqtt from '../../utils/mqtt.min.js';\nvar _default = { data: function data() {return { serve: { host: '47.95.249.141', port: '8083', path: '/mqtt' }, onTopic: '/LED', Qos: 0, sendMassage: 'Hello MQTT', time: 0, receiveMessage: '',\n      client: null,\n      //MQTT连接的配置\n      options: {\n        wsOptions: {},\n        protocolVersion: 4, //MQTT连接协议版本\n        clientId: 'MQTT-test',\n        keepalive: 60,\n        clean: false,\n        username: 'admin',\n        password: 'public',\n        reconnectPeriod: 1000, //1000毫秒，两次重新连接之间的间隔\n        connectTimeout: 30 * 1000, //1000毫秒，两次重新连接之间的间隔\n        resubscribe: true //如果连接断开并重新连接，则会再次自动订阅已订阅的主题（默认true）\n      } };\n\n  },\n  methods: {\n\n    connect: function connect() {var _this = this;\n      var hosts = '',\n\n\n\n\n\n\n\n      hosts = 'wx://' + this.serve.host + ':' + this.serve.port + this.serve.path;\n\n\n      if (this.client == null || this.client.connented == false) {\n        uni.showLoading({\n          title: '连接中···' });\n\n        __f__(\"log\", hosts, this.options, \" at pages/mqtt/mqtt.vue:63\");\n        this.client = _mqtt.default.connect(\n        hosts,\n        this.options);\n\n\n        this.client.on('connect', function () {\n          uni.hideLoading();\n          _this.showToast('连接成功', 1000, 'success');\n        });\n        this.client.on('message', function (topic, message) {\n          __f__(\"log\", '收到来自' + topic + '的消息' + message.toString(), \" at pages/mqtt/mqtt.vue:74\");\n          _this.receiveMessage = message;\n\n        });\n      }\n\n      this.client.on('reconnect', function (error) {\n        uni.hideLoading();\n        _this.showToast('正在重连···', 1000);\n\n      });\n      this.client.on('error', function (error) {\n        uni.hideLoading();\n        _this.showToast('连接失败!', 1000);\n      });\n\n    },\n    subscribe: function subscribe() {var _this2 = this;\n      // 判断是否已成功连接\n      if (!this.client || !this.client.connected) {\n        this.showToast('客户端未连接', 1000);\n        return;\n      }\n\n      this.client.subscribe(this.onTopic, {\n        qos: this.Qos },\n      function (error) {\n        if (!error) {\n          _this2.showToast('订阅成功', 1000, 'success');\n          __f__(\"log\", '订阅成功', \" at pages/mqtt/mqtt.vue:103\");\n        }\n      });\n\n      /* //订阅多个主题\n          this.client.subscribe(['one', 'two', 'three'], { qos: 1 }, err => {\n          console.log(err || '订阅成功');\n          this.show(err || '订阅成功');\n          });\n          \t\t\t    // 订阅不同 qos 的不同主题\n              this.client.subscribe(\n                  [\n                      { hello: 1 },\n                      { 'one/two/three': 2 },\n                      { '#': 0 }\n                  ],\n                  (err) => {\n                    this.show();console.log(err || '订阅成功')\n                  },\n              )\n          \n          }); */\n\n\n    },\n    publish: function publish() {var _this3 = this;\n      // 判断是否已成功连接\n      if (!this.client || !this.client.connected) {\n        this.showToast('客户端未连接', 1000);\n        return;\n      }\n      if (this.sendMassage != '') {\n        var send = '';\n        send = this.sendMassage + this.time++;\n        this.client.publish(this.onTopic, send, function (error) {\n          __f__(\"log\", error || '消息发布成功', \" at pages/mqtt/mqtt.vue:138\");\n          _this3.showToast('消息发布成功', 1000, 'success');\n        });\n      } else {\n        this.showToast('发布消息为空', 1000);\n      }\n\n    },\n    TurnON: function TurnON() {var _this4 = this;\n      // 判断是否已成功连接\n      if (!this.client || !this.client.connected) {\n        this.showToast('客户端未连接', 1000);\n        return;\n      }\n      //if (this.sendMassage != '') {\n      var send = \"{\\\"LED_ON\\\": true}\";\n      //send=this.sendMassage+(this.time++)\n      this.client.publish(this.onTopic, send, function (error) {\n        __f__(\"log\", error || '开灯', \" at pages/mqtt/mqtt.vue:156\");\n        _this4.showToast('开灯成功', 1000, 'success');\n      });\n      //} else {\n      //\tthis.showToast('发布消息为空', 1000)\n      //}\n\n    },\n    TurnOFF: function TurnOFF() {var _this5 = this;\n      // 判断是否已成功连接\n      if (!this.client || !this.client.connected) {\n        this.showToast('客户端未连接', 1000);\n        return;\n      }\n      //if (this.sendMassage != '') {\n      var send = \"{\\\"LED_ON\\\": false}\";\n      //send=this.sendMassage+(this.time++)\n      this.client.publish(this.onTopic, send, function (error) {\n        __f__(\"log\", error || '关灯', \" at pages/mqtt/mqtt.vue:174\");\n        _this5.showToast('关灯成功', 1000, 'success');\n      });\n      //} else {\n      //\tthis.showToast('发布消息为空', 1000)\n      //}\n\n    },\n    unsubscribe: function unsubscribe() {var _this6 = this;\n      this.client.unsubscribe(\n      // topic, topic Array, topic Array-Onject\n      // ['one', 'two', 'three'],\n      this.onTopic,\n      function (err) {\n        __f__(\"log\", err || '取消订阅成功', \" at pages/mqtt/mqtt.vue:188\");\n        _this6.showToast('取消订阅成功', 1000, 'success');\n      });\n\n    },\n    unconnect: function unconnect() {\n      this.client.end();\n      this.client = null;\n      this.showToast('成功断开连接', 1000, 'success');\n      __f__(\"log\", '断开连接', \" at pages/mqtt/mqtt.vue:197\");\n    },\n    showToast: function showToast(title, time) {var icon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'none';\n      uni.showToast({\n        title: title,\n        icon: icon });\n\n      setTimeout(function () {\n        uni.hideToast();\n      }, time);\n    } } };exports.default = _default;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/format-log.js */ 12)[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vcGFnZXMvbXF0dC9tcXR0LnZ1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBYUEsdUY7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7ZUFDQSxFQUNBLElBREEsa0JBQ0EsQ0FDQSxTQUNBLFNBQ0EscUJBREEsRUFFQSxZQUZBLEVBR0EsYUFIQSxFQURBLEVBTUEsZUFOQSxFQU9BLE1BUEEsRUFRQSx5QkFSQSxFQVNBLE9BVEEsRUFVQSxrQkFWQTtBQVdBLGtCQVhBO0FBWUE7QUFDQTtBQUNBLHFCQURBO0FBRUEsMEJBRkEsRUFFQTtBQUNBLDZCQUhBO0FBSUEscUJBSkE7QUFLQSxvQkFMQTtBQU1BLHlCQU5BO0FBT0EsMEJBUEE7QUFRQSw2QkFSQSxFQVFBO0FBQ0EsaUNBVEEsRUFTQTtBQUNBLHlCQVZBLENBVUE7QUFWQSxPQWJBOztBQTBCQSxHQTVCQTtBQTZCQTs7QUFFQTtBQUNBOzs7Ozs7OztBQVFBLGlGQVJBOzs7QUFXQTtBQUNBO0FBQ0EseUJBREE7O0FBR0E7QUFDQTtBQUNBLGFBREE7QUFFQSxvQkFGQTs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsU0FIQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQSxTQUpBO0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BSkE7QUFLQTtBQUNBO0FBQ0E7QUFDQSxPQUhBOztBQUtBLEtBN0NBO0FBOENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BUEE7O0FBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBLEtBbEZBO0FBbUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBSEE7QUFJQSxPQVBBLE1BT0E7QUFDQTtBQUNBOztBQUVBLEtBcEdBO0FBcUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BSEE7QUFJQTtBQUNBO0FBQ0E7O0FBRUEsS0F0SEE7QUF1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FIQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQSxLQXhJQTtBQXlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUhBO0FBSUE7QUFDQTtBQUNBO0FBQ0EsT0FQQTs7QUFTQSxLQW5KQTtBQW9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0F6SkE7QUEwSkE7QUFDQTtBQUNBLG9CQURBO0FBRUEsa0JBRkE7O0FBSUE7QUFDQTtBQUNBLE9BRkEsRUFFQSxJQUZBO0FBR0EsS0FsS0EsRUE3QkEsRSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuXHQ8dmlldz5cclxuXHRcdDxidXR0b24gdHlwZT1cInByaW1hcnlcIiBAY2xpY2s9XCJjb25uZWN0XCI+bXF0dCDov57mjqU8L2J1dHRvbj5cclxuXHRcdDxidXR0b24gdHlwZT1cInByaW1hcnlcIiBAY2xpY2s9XCJzdWJzY3JpYmVcIj5tcXR0IOiuoumYhTwvYnV0dG9uPlxyXG5cdFx0PGJ1dHRvbiB0eXBlPVwicHJpbWFyeVwiIEBjbGljaz1cIlR1cm5PTlwiPuW8gOeBrzwvYnV0dG9uPlxyXG5cdFx0PGJ1dHRvbiB0eXBlPVwicHJpbWFyeVwiIEBjbGljaz1cIlR1cm5PRkZcIj7lhbPnga88L2J1dHRvbj5cclxuXHRcdDxidXR0b24gdHlwZT1cInByaW1hcnlcIiBAY2xpY2s9XCJ1bnN1YnNjcmliZVwiPuWPlua2iOiuoumYhTwvYnV0dG9uPlxyXG5cdFx0PGJ1dHRvbiB0eXBlPVwicHJpbWFyeVwiIEBjbGljaz1cInVuY29ubmVjdFwiPuaWreW8gOi/nuaOpTwvYnV0dG9uPlxyXG5cdFx0PHZpZXc+bWVzc2FnZTp7eyByZWNlaXZlTWVzc2FnZS50b1N0cmluZygpIH19PC92aWV3PlxyXG5cdDwvdmlldz5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcblx0aW1wb3J0IG1xdHQgZnJvbSAnLi4vLi4vdXRpbHMvbXF0dC5qcyc7Ly/kuozpgInkuIBcclxuXHQvL2ltcG9ydCBtcXR0IGZyb20gJy4uLy4uL3V0aWxzL21xdHQubWluLmpzJztcclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRkYXRhKCkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHNlcnZlOiB7XHJcblx0XHRcdFx0XHRob3N0OiAnNDcuOTUuMjQ5LjE0MScsXHJcblx0XHRcdFx0XHRwb3J0OiAnODA4MycsXHJcblx0XHRcdFx0XHRwYXRoOiAnL21xdHQnLFxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0b25Ub3BpYzogJy9MRUQnLFxyXG5cdFx0XHRcdFFvczogMCxcclxuXHRcdFx0XHRzZW5kTWFzc2FnZTogJ0hlbGxvIE1RVFQnLFxyXG5cdFx0XHRcdHRpbWU6MCxcclxuXHRcdFx0XHRyZWNlaXZlTWVzc2FnZTogJycsXHJcblx0XHRcdFx0Y2xpZW50OiBudWxsLFxyXG5cdFx0XHRcdC8vTVFUVOi/nuaOpeeahOmFjee9rlxyXG5cdFx0XHRcdG9wdGlvbnM6IHtcclxuXHRcdFx0XHRcdHdzT3B0aW9uczoge30sXHJcblx0XHRcdFx0XHRwcm90b2NvbFZlcnNpb246IDQsIC8vTVFUVOi/nuaOpeWNj+iurueJiOacrFxyXG5cdFx0XHRcdFx0Y2xpZW50SWQ6ICdNUVRULXRlc3QnLFxyXG5cdFx0XHRcdFx0a2VlcGFsaXZlOiA2MCxcclxuXHRcdFx0XHRcdGNsZWFuOiBmYWxzZSxcclxuXHRcdFx0XHRcdHVzZXJuYW1lOiAnYWRtaW4nLFxyXG5cdFx0XHRcdFx0cGFzc3dvcmQ6ICdwdWJsaWMnLFxyXG5cdFx0XHRcdFx0cmVjb25uZWN0UGVyaW9kOiAxMDAwLCAvLzEwMDDmr6vnp5LvvIzkuKTmrKHph43mlrDov57mjqXkuYvpl7TnmoTpl7TpmpRcclxuXHRcdFx0XHRcdGNvbm5lY3RUaW1lb3V0OiAzMCAqIDEwMDAsIC8vMTAwMOavq+enku+8jOS4pOasoemHjeaWsOi/nuaOpeS5i+mXtOeahOmXtOmalFxyXG5cdFx0XHRcdFx0cmVzdWJzY3JpYmU6IHRydWUgLy/lpoLmnpzov57mjqXmlq3lvIDlubbph43mlrDov57mjqXvvIzliJnkvJrlho3mrKHoh6rliqjorqLpmIXlt7LorqLpmIXnmoTkuLvpopjvvIjpu5jorqR0cnVl77yJXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0fTtcclxuXHRcdH0sXHJcblx0XHRtZXRob2RzOiB7XHJcblx0XHRcdFxyXG5cdFx0XHRjb25uZWN0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgaG9zdHMgPSAnJyxcclxuXHRcdFx0XHQvLyAjaWZkZWYgSDVcclxuXHRcdFx0XHRob3N0cyA9ICd3czovLycgKyB0aGlzLnNlcnZlLmhvc3QgKyAnOicgKyB0aGlzLnNlcnZlLnBvcnQgKyB0aGlzLnNlcnZlLnBhdGhcclxuXHRcdFx0XHQvLyNlbmRpZlxyXG5cdFx0XHRcdC8vICNpZmRlZiBNUC1XRUlYSU4gXHJcblx0XHRcdFx0aG9zdHMgPSAnd3hzOi8vJyArIHRoaXMuc2VydmUuaG9zdCArIHRoaXMuc2VydmUucGF0aFxyXG5cdFx0XHRcdC8vI2VuZGlmXHJcblx0XHRcdFx0Ly8gI2lmZGVmIEFQUC1QTFVTXHJcblx0XHRcdFx0aG9zdHMgPSAnd3g6Ly8nICsgdGhpcy5zZXJ2ZS5ob3N0ICsgJzonICsgdGhpcy5zZXJ2ZS5wb3J0ICsgdGhpcy5zZXJ2ZS5wYXRoXHJcblx0XHRcdFx0Ly8jZW5kaWZcclxuXHJcblx0XHRcdFx0aWYgKHRoaXMuY2xpZW50ID09IG51bGwgfHwgdGhpcy5jbGllbnQuY29ubmVudGVkID09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHR1bmkuc2hvd0xvYWRpbmcoe1xyXG5cdFx0XHRcdFx0XHR0aXRsZTogJ+i/nuaOpeS4rcK3wrfCtydcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhob3N0cywgdGhpcy5vcHRpb25zKVxyXG5cdFx0XHRcdFx0dGhpcy5jbGllbnQgPSBtcXR0LmNvbm5lY3QoXHJcblx0XHRcdFx0XHRcdGhvc3RzLFxyXG5cdFx0XHRcdFx0XHR0aGlzLm9wdGlvbnNcclxuXHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5jbGllbnQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XHJcblx0XHRcdFx0XHRcdHVuaS5oaWRlTG9hZGluZygpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnNob3dUb2FzdCgn6L+e5o6l5oiQ5YqfJywgMTAwMCwgJ3N1Y2Nlc3MnKVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR0aGlzLmNsaWVudC5vbignbWVzc2FnZScsICh0b3BpYywgbWVzc2FnZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZygn5pS25Yiw5p2l6IeqJyArIHRvcGljICsgJ+eahOa2iOaBrycgKyBtZXNzYWdlLnRvU3RyaW5nKCkpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnJlY2VpdmVNZXNzYWdlID0gbWVzc2FnZVxyXG5cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5jbGllbnQub24oJ3JlY29ubmVjdCcsIGVycm9yID0+IHtcclxuXHRcdFx0XHRcdHVuaS5oaWRlTG9hZGluZygpO1xyXG5cdFx0XHRcdFx0dGhpcy5zaG93VG9hc3QoJ+ato+WcqOmHjei/nsK3wrfCtycsIDEwMDApXHJcblxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHRoaXMuY2xpZW50Lm9uKCdlcnJvcicsIGVycm9yID0+IHtcclxuXHRcdFx0XHRcdHVuaS5oaWRlTG9hZGluZygpO1xyXG5cdFx0XHRcdFx0dGhpcy5zaG93VG9hc3QoJ+i/nuaOpeWksei0pSEnLCAxMDAwKVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c3Vic2NyaWJlOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvLyDliKTmlq3mmK/lkKblt7LmiJDlip/ov57mjqVcclxuXHRcdFx0XHRpZiAoIXRoaXMuY2xpZW50IHx8ICF0aGlzLmNsaWVudC5jb25uZWN0ZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMuc2hvd1RvYXN0KCflrqLmiLfnq6/mnKrov57mjqUnLCAxMDAwKVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5jbGllbnQuc3Vic2NyaWJlKHRoaXMub25Ub3BpYywge1xyXG5cdFx0XHRcdFx0cW9zOiB0aGlzLlFvc1xyXG5cdFx0XHRcdH0sIGVycm9yID0+IHtcclxuXHRcdFx0XHRcdGlmICghZXJyb3IpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5zaG93VG9hc3QoJ+iuoumYheaIkOWKnycsIDEwMDAsICdzdWNjZXNzJylcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ+iuoumYheaIkOWKnycpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHQvKiAvL+iuoumYheWkmuS4quS4u+mimFxyXG5cdFx0XHR0aGlzLmNsaWVudC5zdWJzY3JpYmUoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sIHsgcW9zOiAxIH0sIGVyciA9PiB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coZXJyIHx8ICforqLpmIXmiJDlip8nKTtcclxuXHRcdFx0XHR0aGlzLnNob3coZXJyIHx8ICforqLpmIXmiJDlip8nKTtcclxuXHRcdFx0IH0pO1xyXG5cdFx0XHRcclxuXHRcdFx0XHQgICAgLy8g6K6i6ZiF5LiN5ZCMIHFvcyDnmoTkuI3lkIzkuLvpophcclxuXHRcdFx0XHQgICAgdGhpcy5jbGllbnQuc3Vic2NyaWJlKFxyXG5cdFx0XHRcdCAgICAgICAgW1xyXG5cdFx0XHRcdCAgICAgICAgICAgIHsgaGVsbG86IDEgfSxcclxuXHRcdFx0XHQgICAgICAgICAgICB7ICdvbmUvdHdvL3RocmVlJzogMiB9LFxyXG5cdFx0XHRcdCAgICAgICAgICAgIHsgJyMnOiAwIH1cclxuXHRcdFx0XHQgICAgICAgIF0sXHJcblx0XHRcdFx0ICAgICAgICAoZXJyKSA9PiB7XHJcblx0XHRcdFx0ICAgICAgICAgIHRoaXMuc2hvdygpO2NvbnNvbGUubG9nKGVyciB8fCAn6K6i6ZiF5oiQ5YqfJylcclxuXHRcdFx0XHQgICAgICAgIH0sXHJcblx0XHRcdFx0ICAgIClcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcdH0pOyAqL1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRwdWJsaXNoOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvLyDliKTmlq3mmK/lkKblt7LmiJDlip/ov57mjqVcclxuXHRcdFx0XHRpZiAoIXRoaXMuY2xpZW50IHx8ICF0aGlzLmNsaWVudC5jb25uZWN0ZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMuc2hvd1RvYXN0KCflrqLmiLfnq6/mnKrov57mjqUnLCAxMDAwKVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGhpcy5zZW5kTWFzc2FnZSAhPSAnJykge1xyXG5cdFx0XHRcdFx0dmFyIHNlbmQ9JydcclxuXHRcdFx0XHRcdHNlbmQ9dGhpcy5zZW5kTWFzc2FnZSsodGhpcy50aW1lKyspXHJcblx0XHRcdFx0XHR0aGlzLmNsaWVudC5wdWJsaXNoKHRoaXMub25Ub3BpYyxzZW5kLCBlcnJvciA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGVycm9yIHx8ICfmtojmga/lj5HluIPmiJDlip8nKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5zaG93VG9hc3QoJ+a2iOaBr+WPkeW4g+aIkOWKnycsIDEwMDAsICdzdWNjZXNzJylcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLnNob3dUb2FzdCgn5Y+R5biD5raI5oGv5Li656m6JywgMTAwMClcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LFxyXG5cdFx0XHRUdXJuT046IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdC8vIOWIpOaWreaYr+WQpuW3suaIkOWKn+i/nuaOpVxyXG5cdFx0XHRcdGlmICghdGhpcy5jbGllbnQgfHwgIXRoaXMuY2xpZW50LmNvbm5lY3RlZCkge1xyXG5cdFx0XHRcdFx0dGhpcy5zaG93VG9hc3QoJ+WuouaIt+err+acqui/nuaOpScsIDEwMDApXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vaWYgKHRoaXMuc2VuZE1hc3NhZ2UgIT0gJycpIHtcclxuXHRcdFx0XHRcdHZhciBzZW5kPSBcIntcXFwiTEVEX09OXFxcIjogdHJ1ZX1cIlxyXG5cdFx0XHRcdFx0Ly9zZW5kPXRoaXMuc2VuZE1hc3NhZ2UrKHRoaXMudGltZSsrKVxyXG5cdFx0XHRcdFx0dGhpcy5jbGllbnQucHVibGlzaCh0aGlzLm9uVG9waWMsc2VuZCwgZXJyb3IgPT4ge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhlcnJvciB8fCAn5byA54GvJyk7XHJcblx0XHRcdFx0XHRcdHRoaXMuc2hvd1RvYXN0KCflvIDnga/miJDlip8nLCAxMDAwLCAnc3VjY2VzcycpXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHQvL30gZWxzZSB7XHJcblx0XHRcdFx0Ly9cdHRoaXMuc2hvd1RvYXN0KCflj5HluIPmtojmga/kuLrnqbonLCAxMDAwKVxyXG5cdFx0XHRcdC8vfVxyXG5cdFx0XHRcclxuXHRcdFx0fSxcclxuXHRcdFx0VHVybk9GRjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8g5Yik5pat5piv5ZCm5bey5oiQ5Yqf6L+e5o6lXHJcblx0XHRcdFx0aWYgKCF0aGlzLmNsaWVudCB8fCAhdGhpcy5jbGllbnQuY29ubmVjdGVkKSB7XHJcblx0XHRcdFx0XHR0aGlzLnNob3dUb2FzdCgn5a6i5oi356uv5pyq6L+e5o6lJywgMTAwMClcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly9pZiAodGhpcy5zZW5kTWFzc2FnZSAhPSAnJykge1xyXG5cdFx0XHRcdFx0dmFyIHNlbmQ9IFwie1xcXCJMRURfT05cXFwiOiBmYWxzZX1cIlxyXG5cdFx0XHRcdFx0Ly9zZW5kPXRoaXMuc2VuZE1hc3NhZ2UrKHRoaXMudGltZSsrKVxyXG5cdFx0XHRcdFx0dGhpcy5jbGllbnQucHVibGlzaCh0aGlzLm9uVG9waWMsc2VuZCwgZXJyb3IgPT4ge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhlcnJvciB8fCAn5YWz54GvJyk7XHJcblx0XHRcdFx0XHRcdHRoaXMuc2hvd1RvYXN0KCflhbPnga/miJDlip8nLCAxMDAwLCAnc3VjY2VzcycpXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHQvL30gZWxzZSB7XHJcblx0XHRcdFx0Ly9cdHRoaXMuc2hvd1RvYXN0KCflj5HluIPmtojmga/kuLrnqbonLCAxMDAwKVxyXG5cdFx0XHRcdC8vfVxyXG5cdFx0XHRcclxuXHRcdFx0fSxcclxuXHRcdFx0dW5zdWJzY3JpYmU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHRoaXMuY2xpZW50LnVuc3Vic2NyaWJlKFxyXG5cdFx0XHRcdFx0Ly8gdG9waWMsIHRvcGljIEFycmF5LCB0b3BpYyBBcnJheS1PbmplY3RcclxuXHRcdFx0XHRcdC8vIFsnb25lJywgJ3R3bycsICd0aHJlZSddLFxyXG5cdFx0XHRcdFx0dGhpcy5vblRvcGljLFxyXG5cdFx0XHRcdFx0ZXJyID0+IHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coZXJyIHx8ICflj5bmtojorqLpmIXmiJDlip8nKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5zaG93VG9hc3QoJ+WPlua2iOiuoumYheaIkOWKnycsIDEwMDAsICdzdWNjZXNzJylcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR1bmNvbm5lY3Q6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHRoaXMuY2xpZW50LmVuZCgpO1xyXG5cdFx0XHRcdHRoaXMuY2xpZW50ID0gbnVsbFxyXG5cdFx0XHRcdHRoaXMuc2hvd1RvYXN0KCfmiJDlip/mlq3lvIDov57mjqUnLCAxMDAwLCAnc3VjY2VzcycpXHJcblx0XHRcdFx0Y29uc29sZS5sb2coJ+aWreW8gOi/nuaOpScpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRzaG93VG9hc3Q6IGZ1bmN0aW9uKHRpdGxlLCB0aW1lLCBpY29uID0gJ25vbmUnKSB7XHJcblx0XHRcdFx0dW5pLnNob3dUb2FzdCh7XHJcblx0XHRcdFx0XHR0aXRsZTogdGl0bGUsXHJcblx0XHRcdFx0XHRpY29uOiBpY29uLFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR1bmkuaGlkZVRvYXN0KCk7XHJcblx0XHRcdFx0fSwgdGltZSk7XHJcblx0XHRcdH0sXHJcblx0XHR9XHJcblx0fVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG5cdGJ1dHRvbiB7XHJcblx0XHRtYXJnaW4tdG9wOiAzMHVweDtcclxuXHRcdG1hcmdpbi1ib3R0b206IDMwdXB4O1xyXG5cdH1cclxuPC9zdHlsZT5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/*!*************************************************************************!*\
  !*** F:/vscodespace/myrepository/Lua_demo/LED/APP/物联网IoT/utils/mqtt.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, wx, __f__) {var require;var require;(function (f) {if (true) {module.exports = f();} else { var g; }})(function () {var define, module, exports;return function () {function r(e, n, t) {function o(i, f) {if (!n[i]) {if (!e[i]) {var c = \"function\" == typeof require && require;if (!f && c) return require(i, !0);if (u) return u(i, !0);var a = new Error(\"Cannot find module '\" + i + \"'\");throw a.code = \"MODULE_NOT_FOUND\", a;}var p = n[i] = { exports: {} };e[i][0].call(p.exports, function (r) {var n = e[i][1][r];return o(n || r);}, p, p.exports, r, e, n, t);}return n[i].exports;}for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) {o(t[i]);}return o;}return r;}()({ 1: [function (require, module, exports) {\n      (function (process, global) {\n        'use strict';\n\n        /**\n                       * Module dependencies\n                       */\n        var events = require('events');\n        var Store = require('./store');\n        var mqttPacket = require('mqtt-packet');\n        var Writable = require('readable-stream').Writable;\n        var inherits = require('inherits');\n        var reInterval = require('reinterval');\n        var validations = require('./validations');\n        var xtend = require('xtend');\n        var setImmediate = global.setImmediate || function (callback) {\n          // works in node v0.8\n          process.nextTick(callback);\n        };\n        var defaultConnectOptions = {\n          keepalive: 60,\n          reschedulePings: true,\n          protocolId: 'MQTT',\n          protocolVersion: 4,\n          reconnectPeriod: 1000,\n          connectTimeout: 30 * 1000,\n          clean: true,\n          resubscribe: true };\n\n        var errors = {\n          0: '',\n          1: 'Unacceptable protocol version',\n          2: 'Identifier rejected',\n          3: 'Server unavailable',\n          4: 'Bad username or password',\n          5: 'Not authorized',\n          16: 'No matching subscribers',\n          17: 'No subscription existed',\n          128: 'Unspecified error',\n          129: 'Malformed Packet',\n          130: 'Protocol Error',\n          131: 'Implementation specific error',\n          132: 'Unsupported Protocol Version',\n          133: 'Client Identifier not valid',\n          134: 'Bad User Name or Password',\n          135: 'Not authorized',\n          136: 'Server unavailable',\n          137: 'Server busy',\n          138: 'Banned',\n          139: 'Server shutting down',\n          140: 'Bad authentication method',\n          141: 'Keep Alive timeout',\n          142: 'Session taken over',\n          143: 'Topic Filter invalid',\n          144: 'Topic Name invalid',\n          145: 'Packet identifier in use',\n          146: 'Packet Identifier not found',\n          147: 'Receive Maximum exceeded',\n          148: 'Topic Alias invalid',\n          149: 'Packet too large',\n          150: 'Message rate too high',\n          151: 'Quota exceeded',\n          152: 'Administrative action',\n          153: 'Payload format invalid',\n          154: 'Retain not supported',\n          155: 'QoS not supported',\n          156: 'Use another server',\n          157: 'Server moved',\n          158: 'Shared Subscriptions not supported',\n          159: 'Connection rate exceeded',\n          160: 'Maximum connect time',\n          161: 'Subscription Identifiers not supported',\n          162: 'Wildcard Subscriptions not supported' };\n\n\n        function defaultId() {\n          return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n        }\n\n        function sendPacket(client, packet, cb) {\n          client.emit('packetsend', packet);\n\n          var result = mqttPacket.writeToStream(packet, client.stream, client.options);\n\n          if (!result && cb) {\n            client.stream.once('drain', cb);\n          } else if (cb) {\n            cb();\n          }\n        }\n\n        function flush(queue) {\n          if (queue) {\n            Object.keys(queue).forEach(function (messageId) {\n              if (typeof queue[messageId].cb === 'function') {\n                queue[messageId].cb(new Error('Connection closed'));\n                delete queue[messageId];\n              }\n            });\n          }\n        }\n\n        function flushVolatile(queue) {\n          if (queue) {\n            Object.keys(queue).forEach(function (messageId) {\n              if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n                queue[messageId].cb(new Error('Connection closed'));\n                delete queue[messageId];\n              }\n            });\n          }\n        }\n\n        function storeAndSend(client, packet, cb, cbStorePut) {\n          client.outgoingStore.put(packet, function storedPacket(err) {\n            if (err) {\n              return cb && cb(err);\n            }\n            cbStorePut();\n            sendPacket(client, packet, cb);\n          });\n        }\n\n        function nop() {}\n\n        /**\n                           * MqttClient constructor\n                           *\n                           * @param {Stream} stream - stream\n                           * @param {Object} [options] - connection options\n                           * (see Connection#connect)\n                           */\n        function MqttClient(streamBuilder, options) {\n          var k;\n          var that = this;\n\n          if (!(this instanceof MqttClient)) {\n            return new MqttClient(streamBuilder, options);\n          }\n\n          this.options = options || {};\n\n          // Defaults\n          for (k in defaultConnectOptions) {\n            if (typeof this.options[k] === 'undefined') {\n              this.options[k] = defaultConnectOptions[k];\n            } else {\n              this.options[k] = options[k];\n            }\n          }\n\n          this.options.clientId = typeof options.clientId === 'string' ? options.clientId : defaultId();\n\n          this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {arguments[3](0);};\n\n          this.streamBuilder = streamBuilder;\n\n          // Inflight message storages\n          this.outgoingStore = options.outgoingStore || new Store();\n          this.incomingStore = options.incomingStore || new Store();\n\n          // Should QoS zero messages be queued when the connection is broken?\n          this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero;\n\n          // map of subscribed topics to support reconnection\n          this._resubscribeTopics = {};\n\n          // map of a subscribe messageId and a topic\n          this.messageIdToTopic = {};\n\n          // Ping timer, setup in _setupPingTimer\n          this.pingTimer = null;\n          // Is the client connected?\n          this.connected = false;\n          // Are we disconnecting?\n          this.disconnecting = false;\n          // Packet queue\n          this.queue = [];\n          // connack timer\n          this.connackTimer = null;\n          // Reconnect timer\n          this.reconnectTimer = null;\n          // Is processing store?\n          this._storeProcessing = false;\n          // Packet Ids are put into the store during store processing\n          this._packetIdsDuringStoreProcessing = {};\n          /**\n                                                      * MessageIDs starting with 1\n                                                      * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n                                                      */\n          this.nextId = Math.max(1, Math.floor(Math.random() * 65535));\n\n          // Inflight callbacks\n          this.outgoing = {};\n\n          // True if connection is first time.\n          this._firstConnection = true;\n\n          // Mark disconnected on stream close\n          this.on('close', function () {\n            this.connected = false;\n            clearTimeout(this.connackTimer);\n          });\n\n          // Send queued packets\n          this.on('connect', function () {\n            var queue = this.queue;\n\n            function deliver() {\n              var entry = queue.shift();\n              var packet = null;\n\n              if (!entry) {\n                return;\n              }\n\n              packet = entry.packet;\n\n              that._sendPacket(\n              packet,\n              function (err) {\n                if (entry.cb) {\n                  entry.cb(err);\n                }\n                deliver();\n              });\n\n            }\n\n            deliver();\n          });\n\n          // Clear ping timer\n          this.on('close', function () {\n            if (that.pingTimer !== null) {\n              that.pingTimer.clear();\n              that.pingTimer = null;\n            }\n          });\n\n          // Setup reconnect timer on disconnect\n          this.on('close', this._setupReconnect);\n\n          events.EventEmitter.call(this);\n\n          this._setupStream();\n        }\n        inherits(MqttClient, events.EventEmitter);\n\n        /**\n                                                    * setup the event handlers in the inner stream.\n                                                    *\n                                                    * @api private\n                                                    */\n        MqttClient.prototype._setupStream = function () {\n          var connectPacket;\n          var that = this;\n          var writable = new Writable();\n          var parser = mqttPacket.parser(this.options);\n          var completeParse = null;\n          var packets = [];\n\n          this._clearReconnect();\n\n          this.stream = this.streamBuilder(this);\n\n          parser.on('packet', function (packet) {\n            packets.push(packet);\n          });\n\n          function nextTickWork() {\n            if (packets.length) {\n              process.nextTick(work);\n            } else {\n              var done = completeParse;\n              completeParse = null;\n              done();\n            }\n          }\n\n          function work() {\n            var packet = packets.shift();\n\n            if (packet) {\n              that._handlePacket(packet, nextTickWork);\n            } else {\n              var done = completeParse;\n              completeParse = null;\n              if (done) done();\n            }\n          }\n\n          writable._write = function (buf, enc, done) {\n            completeParse = done;\n            parser.parse(buf);\n            work();\n          };\n\n          this.stream.pipe(writable);\n\n          // Suppress connection errors\n          this.stream.on('error', nop);\n\n          // Echo stream close\n          this.stream.on('close', function () {\n            flushVolatile(that.outgoing);\n            that.emit('close');\n          });\n\n          // Send a connect packet\n          connectPacket = Object.create(this.options);\n          connectPacket.cmd = 'connect';\n          // avoid message queue\n          sendPacket(this, connectPacket);\n\n          // Echo connection errors\n          parser.on('error', this.emit.bind(this, 'error'));\n\n          // auth\n          if (this.options.properties) {\n            if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n              this.emit('error', new Error('Packet has no Authentication Method'));\n              return this;\n            }\n            if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n              var authPacket = xtend({ cmd: 'auth', reasonCode: 0 }, this.options.authPacket);\n              sendPacket(this, authPacket);\n            }\n          }\n\n          // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n          this.stream.setMaxListeners(1000);\n\n          clearTimeout(this.connackTimer);\n          this.connackTimer = setTimeout(function () {\n            that._cleanUp(true);\n          }, this.options.connectTimeout);\n        };\n\n        MqttClient.prototype._handlePacket = function (packet, done) {\n          var options = this.options;\n\n          if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n            this.emit('error', new Error('exceeding packets size ' + packet.cmd));\n            this.end({ reasonCode: 149, properties: { reasonString: 'Maximum packet size was exceeded' } });\n            return this;\n          }\n\n          this.emit('packetreceive', packet);\n\n          switch (packet.cmd) {\n            case 'publish':\n              this._handlePublish(packet, done);\n              break;\n            case 'puback':\n            case 'pubrec':\n            case 'pubcomp':\n            case 'suback':\n            case 'unsuback':\n              this._handleAck(packet);\n              done();\n              break;\n            case 'pubrel':\n              this._handlePubrel(packet, done);\n              break;\n            case 'connack':\n              this._handleConnack(packet);\n              done();\n              break;\n            case 'pingresp':\n              this._handlePingresp(packet);\n              done();\n              break;\n            case 'disconnect':\n              this._handleDisconnect(packet);\n              done();\n              break;\n            default:\n              // do nothing\n              // maybe we should do an error handling\n              // or just log it\n              break;}\n\n        };\n\n        MqttClient.prototype._checkDisconnecting = function (callback) {\n          if (this.disconnecting) {\n            if (callback) {\n              callback(new Error('client disconnecting'));\n            } else {\n              this.emit('error', new Error('client disconnecting'));\n            }\n          }\n          return this.disconnecting;\n        };\n\n        /**\n            * publish - publish <message> to <topic>\n            *\n            * @param {String} topic - topic to publish to\n            * @param {String, Buffer} message - message to publish\n            * @param {Object} [opts] - publish options, includes:\n            *    {Number} qos - qos level to publish on\n            *    {Boolean} retain - whether or not to retain the message\n            *    {Boolean} dup - whether or not mark a message as duplicate\n            *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n            * @param {Function} [callback] - function(err){}\n            *    called when publish succeeds or fails\n            * @returns {MqttClient} this - for chaining\n            * @api public\n            *\n            * @example client.publish('topic', 'message');\n            * @example\n            *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n            * @example client.publish('topic', 'message', console.log);\n            */\n        MqttClient.prototype.publish = function (topic, message, opts, callback) {\n          var packet;\n          var options = this.options;\n\n          // .publish(topic, payload, cb);\n          if (typeof opts === 'function') {\n            callback = opts;\n            opts = null;\n          }\n\n          // default opts\n          var defaultOpts = { qos: 0, retain: false, dup: false };\n          opts = xtend(defaultOpts, opts);\n\n          if (this._checkDisconnecting(callback)) {\n            return this;\n          }\n\n          packet = {\n            cmd: 'publish',\n            topic: topic,\n            payload: message,\n            qos: opts.qos,\n            retain: opts.retain,\n            messageId: this._nextId(),\n            dup: opts.dup };\n\n\n          if (options.protocolVersion === 5) {\n            packet.properties = opts.properties;\n            if (!options.properties && packet.properties && packet.properties.topicAlias || opts.properties && options.properties && (\n            opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum ||\n            !options.properties.topicAliasMaximum && opts.properties.topicAlias)) {\n              /*\n                                                                                   if we are don`t setup topic alias or\n                                                                                   topic alias maximum less than topic alias or\n                                                                                   server don`t give topic alias maximum,\n                                                                                   we are removing topic alias from packet\n                                                                                   */\n              delete packet.properties.topicAlias;\n            }\n          }\n\n          switch (opts.qos) {\n            case 1:\n            case 2:\n              // Add to callbacks\n              this.outgoing[packet.messageId] = {\n                volatile: false,\n                cb: callback || nop };\n\n              if (this._storeProcessing) {\n                this._packetIdsDuringStoreProcessing[packet.messageId] = false;\n                this._storePacket(packet, undefined, opts.cbStorePut);\n              } else {\n                this._sendPacket(packet, undefined, opts.cbStorePut);\n              }\n              break;\n            default:\n              if (this._storeProcessing) {\n                this._storePacket(packet, callback, opts.cbStorePut);\n              } else {\n                this._sendPacket(packet, callback, opts.cbStorePut);\n              }\n              break;}\n\n\n          return this;\n        };\n\n        /**\n            * subscribe - subscribe to <topic>\n            *\n            * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n            * @param {Object} [opts] - optional subscription options, includes:\n            *    {Number} qos - subscribe qos level\n            * @param {Function} [callback] - function(err, granted){} where:\n            *    {Error} err - subscription error (none at the moment!)\n            *    {Array} granted - array of {topic: 't', qos: 0}\n            * @returns {MqttClient} this - for chaining\n            * @api public\n            * @example client.subscribe('topic');\n            * @example client.subscribe('topic', {qos: 1});\n            * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n            * @example client.subscribe('topic', console.log);\n            */\n        MqttClient.prototype.subscribe = function () {\n          var packet;\n          var args = new Array(arguments.length);\n          for (var i = 0; i < arguments.length; i++) {\n            args[i] = arguments[i];\n          }\n          var subs = [];\n          var obj = args.shift();\n          var resubscribe = obj.resubscribe;\n          var callback = args.pop() || nop;\n          var opts = args.pop();\n          var invalidTopic;\n          var that = this;\n          var version = this.options.protocolVersion;\n\n          delete obj.resubscribe;\n\n          if (typeof obj === 'string') {\n            obj = [obj];\n          }\n\n          if (typeof callback !== 'function') {\n            opts = callback;\n            callback = nop;\n          }\n\n          invalidTopic = validations.validateTopics(obj);\n          if (invalidTopic !== null) {\n            setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n            return this;\n          }\n\n          if (this._checkDisconnecting(callback)) {\n            return this;\n          }\n\n          var defaultOpts = {\n            qos: 0 };\n\n          if (version === 5) {\n            defaultOpts.nl = false;\n            defaultOpts.rap = false;\n            defaultOpts.rh = 0;\n          }\n          opts = xtend(defaultOpts, opts);\n\n          if (Array.isArray(obj)) {\n            obj.forEach(function (topic) {\n              if (!that._resubscribeTopics.hasOwnProperty(topic) ||\n              that._resubscribeTopics[topic].qos < opts.qos ||\n              resubscribe) {\n                var currentOpts = {\n                  topic: topic,\n                  qos: opts.qos };\n\n                if (version === 5) {\n                  currentOpts.nl = opts.nl;\n                  currentOpts.rap = opts.rap;\n                  currentOpts.rh = opts.rh;\n                  currentOpts.properties = opts.properties;\n                }\n                subs.push(currentOpts);\n              }\n            });\n          } else {\n            Object.\n            keys(obj).\n            forEach(function (k) {\n              if (!that._resubscribeTopics.hasOwnProperty(k) ||\n              that._resubscribeTopics[k].qos < obj[k].qos ||\n              resubscribe) {\n                var currentOpts = {\n                  topic: k,\n                  qos: obj[k].qos };\n\n                if (version === 5) {\n                  currentOpts.nl = obj[k].nl;\n                  currentOpts.rap = obj[k].rap;\n                  currentOpts.rh = obj[k].rh;\n                  currentOpts.properties = opts.properties;\n                }\n                subs.push(currentOpts);\n              }\n            });\n          }\n\n          packet = {\n            cmd: 'subscribe',\n            subscriptions: subs,\n            qos: 1,\n            retain: false,\n            dup: false,\n            messageId: this._nextId() };\n\n\n          if (opts.properties) {\n            packet.properties = opts.properties;\n          }\n\n          if (!subs.length) {\n            callback(null, []);\n            return;\n          }\n\n          // subscriptions to resubscribe to in case of disconnect\n          if (this.options.resubscribe) {\n            var topics = [];\n            subs.forEach(function (sub) {\n              if (that.options.reconnectPeriod > 0) {\n                var topic = { qos: sub.qos };\n                if (version === 5) {\n                  topic.nl = sub.nl || false;\n                  topic.rap = sub.rap || false;\n                  topic.rh = sub.rh || 0;\n                  topic.properties = sub.properties;\n                }\n                that._resubscribeTopics[sub.topic] = topic;\n                topics.push(sub.topic);\n              }\n            });\n            that.messageIdToTopic[packet.messageId] = topics;\n          }\n\n          this.outgoing[packet.messageId] = {\n            volatile: true,\n            cb: function cb(err, packet) {\n              if (!err) {\n                var granted = packet.granted;\n                for (var i = 0; i < granted.length; i += 1) {\n                  subs[i].qos = granted[i];\n                }\n              }\n\n              callback(err, subs);\n            } };\n\n\n          this._sendPacket(packet);\n\n          return this;\n        };\n\n        /**\n            * unsubscribe - unsubscribe from topic(s)\n            *\n            * @param {String, Array} topic - topics to unsubscribe from\n            * @param {Object} [opts] - optional subscription options, includes:\n            *    {Object} properties - properties of unsubscribe packet\n            * @param {Function} [callback] - callback fired on unsuback\n            * @returns {MqttClient} this - for chaining\n            * @api public\n            * @example client.unsubscribe('topic');\n            * @example client.unsubscribe('topic', console.log);\n            */\n        MqttClient.prototype.unsubscribe = function () {\n          var packet = {\n            cmd: 'unsubscribe',\n            qos: 1,\n            messageId: this._nextId() };\n\n          var that = this;\n          var args = new Array(arguments.length);\n          for (var i = 0; i < arguments.length; i++) {\n            args[i] = arguments[i];\n          }\n          var topic = args.shift();\n          var callback = args.pop() || nop;\n          var opts = args.pop();\n\n          if (typeof topic === 'string') {\n            topic = [topic];\n          }\n\n          if (typeof callback !== 'function') {\n            opts = callback;\n            callback = nop;\n          }\n\n          if (this._checkDisconnecting(callback)) {\n            return this;\n          }\n\n          if (typeof topic === 'string') {\n            packet.unsubscriptions = [topic];\n          } else if (typeof topic === 'object' && topic.length) {\n            packet.unsubscriptions = topic;\n          }\n\n          if (this.options.resubscribe) {\n            packet.unsubscriptions.forEach(function (topic) {\n              delete that._resubscribeTopics[topic];\n            });\n          }\n\n          if (typeof opts === 'object' && opts.properties) {\n            packet.properties = opts.properties;\n          }\n\n          this.outgoing[packet.messageId] = {\n            volatile: true,\n            cb: callback };\n\n\n          this._sendPacket(packet);\n\n          return this;\n        };\n\n        /**\n            * end - close connection\n            *\n            * @returns {MqttClient} this - for chaining\n            * @param {Boolean} force - do not wait for all in-flight messages to be acked\n            * @param {Function} cb - called when the client has been closed\n            *\n            * @api public\n            */\n        MqttClient.prototype.end = function () {\n          var that = this;\n\n          var force = arguments[0];\n          var opts = arguments[1];\n          var cb = arguments[2];\n\n          if (force == null || typeof force !== 'boolean') {\n            cb = opts || nop;\n            opts = force;\n            force = false;\n            if (typeof opts !== 'object') {\n              cb = opts;\n              opts = null;\n              if (typeof cb !== 'function') {\n                cb = nop;\n              }\n            }\n          }\n\n          if (typeof opts !== 'object') {\n            cb = opts;\n            opts = null;\n          }\n\n          cb = cb || nop;\n\n          function closeStores() {\n            that.disconnected = true;\n            that.incomingStore.close(function () {\n              that.outgoingStore.close(function () {\n                if (cb) {\n                  cb.apply(null, arguments);\n                }\n                that.emit('end');\n              });\n            });\n            if (that._deferredReconnect) {\n              that._deferredReconnect();\n            }\n          }\n\n          function finish() {\n            // defer closesStores of an I/O cycle,\n            // just to make sure things are\n            // ok for websockets\n            that._cleanUp(force, setImmediate.bind(null, closeStores), opts);\n          }\n\n          if (this.disconnecting) {\n            return this;\n          }\n\n          this._clearReconnect();\n\n          this.disconnecting = true;\n\n          if (!force && Object.keys(this.outgoing).length > 0) {\n            // wait 10ms, just to be sure we received all of it\n            this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n          } else {\n            finish();\n          }\n\n          return this;\n        };\n\n        /**\n            * removeOutgoingMessage - remove a message in outgoing store\n            * the outgoing callback will be called withe Error('Message removed') if the message is removed\n            *\n            * @param {Number} mid - messageId to remove message\n            * @returns {MqttClient} this - for chaining\n            * @api public\n            *\n            * @example client.removeOutgoingMessage(client.getLastMessageId());\n            */\n        MqttClient.prototype.removeOutgoingMessage = function (mid) {\n          var cb = this.outgoing[mid] ? this.outgoing[mid].cb : null;\n          delete this.outgoing[mid];\n          this.outgoingStore.del({ messageId: mid }, function () {\n            cb(new Error('Message removed'));\n          });\n          return this;\n        };\n\n        /**\n            * reconnect - connect again using the same options as connect()\n            *\n            * @param {Object} [opts] - optional reconnect options, includes:\n            *    {Store} incomingStore - a store for the incoming packets\n            *    {Store} outgoingStore - a store for the outgoing packets\n            *    if opts is not given, current stores are used\n            * @returns {MqttClient} this - for chaining\n            *\n            * @api public\n            */\n        MqttClient.prototype.reconnect = function (opts) {\n          var that = this;\n          var f = function f() {\n            if (opts) {\n              that.options.incomingStore = opts.incomingStore;\n              that.options.outgoingStore = opts.outgoingStore;\n            } else {\n              that.options.incomingStore = null;\n              that.options.outgoingStore = null;\n            }\n            that.incomingStore = that.options.incomingStore || new Store();\n            that.outgoingStore = that.options.outgoingStore || new Store();\n            that.disconnecting = false;\n            that.disconnected = false;\n            that._deferredReconnect = null;\n            that._reconnect();\n          };\n\n          if (this.disconnecting && !this.disconnected) {\n            this._deferredReconnect = f;\n          } else {\n            f();\n          }\n          return this;\n        };\n\n        /**\n            * _reconnect - implement reconnection\n            * @api privateish\n            */\n        MqttClient.prototype._reconnect = function () {\n          this.emit('reconnect');\n          this._setupStream();\n        };\n\n        /**\n            * _setupReconnect - setup reconnect timer\n            */\n        MqttClient.prototype._setupReconnect = function () {\n          var that = this;\n\n          if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n            if (!this.reconnecting) {\n              this.emit('offline');\n              this.reconnecting = true;\n            }\n            that.reconnectTimer = setInterval(function () {\n              that._reconnect();\n            }, that.options.reconnectPeriod);\n          }\n        };\n\n        /**\n            * _clearReconnect - clear the reconnect timer\n            */\n        MqttClient.prototype._clearReconnect = function () {\n          if (this.reconnectTimer) {\n            clearInterval(this.reconnectTimer);\n            this.reconnectTimer = null;\n          }\n        };\n\n        /**\n            * _cleanUp - clean up on connection end\n            * @api private\n            */\n        MqttClient.prototype._cleanUp = function (forced, done) {\n          var opts = arguments[2];\n          if (done) {\n            this.stream.on('close', done);\n          }\n\n          if (forced) {\n            if (this.options.reconnectPeriod === 0 && this.options.clean) {\n              flush(this.outgoing);\n            }\n            this.stream.destroy();\n          } else {\n            var packet = xtend({ cmd: 'disconnect' }, opts);\n            this._sendPacket(\n            packet,\n            setImmediate.bind(\n            null,\n            this.stream.end.bind(this.stream)));\n\n\n          }\n\n          if (!this.disconnecting) {\n            this._clearReconnect();\n            this._setupReconnect();\n          }\n\n          if (this.pingTimer !== null) {\n            this.pingTimer.clear();\n            this.pingTimer = null;\n          }\n\n          if (done && !this.connected) {\n            this.stream.removeListener('close', done);\n            done();\n          }\n        };\n\n        /**\n            * _sendPacket - send or queue a packet\n            * @param {String} type - packet type (see `protocol`)\n            * @param {Object} packet - packet options\n            * @param {Function} cb - callback when the packet is sent\n            * @param {Function} cbStorePut - called when message is put into outgoingStore\n            * @api private\n            */\n        MqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n          cbStorePut = cbStorePut || nop;\n\n          if (!this.connected) {\n            this._storePacket(packet, cb, cbStorePut);\n            return;\n          }\n\n          // When sending a packet, reschedule the ping timer\n          this._shiftPingInterval();\n\n          switch (packet.cmd) {\n            case 'publish':\n              break;\n            case 'pubrel':\n              storeAndSend(this, packet, cb, cbStorePut);\n              return;\n            default:\n              sendPacket(this, packet, cb);\n              return;}\n\n\n          switch (packet.qos) {\n            case 2:\n            case 1:\n              storeAndSend(this, packet, cb, cbStorePut);\n              break;\n            /**\n                      * no need of case here since it will be caught by default\n                      * and jshint comply that before default it must be a break\n                      * anyway it will result in -1 evaluation\n                      */\n            case 0:\n            /* falls through */\n            default:\n              sendPacket(this, packet, cb);\n              break;}\n\n        };\n\n        /**\n            * _storePacket - queue a packet\n            * @param {String} type - packet type (see `protocol`)\n            * @param {Object} packet - packet options\n            * @param {Function} cb - callback when the packet is sent\n            * @param {Function} cbStorePut - called when message is put into outgoingStore\n            * @api private\n            */\n        MqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n          cbStorePut = cbStorePut || nop;\n\n          if ((packet.qos || 0) === 0 && this.queueQoSZero || packet.cmd !== 'publish') {\n            this.queue.push({ packet: packet, cb: cb });\n          } else if (packet.qos > 0) {\n            cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null;\n            this.outgoingStore.put(packet, function (err) {\n              if (err) {\n                return cb && cb(err);\n              }\n              cbStorePut();\n            });\n          } else if (cb) {\n            cb(new Error('No connection to broker'));\n          }\n        };\n\n        /**\n            * _setupPingTimer - setup the ping timer\n            *\n            * @api private\n            */\n        MqttClient.prototype._setupPingTimer = function () {\n          var that = this;\n\n          if (!this.pingTimer && this.options.keepalive) {\n            this.pingResp = true;\n            this.pingTimer = reInterval(function () {\n              that._checkPing();\n            }, this.options.keepalive * 1000);\n          }\n        };\n\n        /**\n            * _shiftPingInterval - reschedule the ping interval\n            *\n            * @api private\n            */\n        MqttClient.prototype._shiftPingInterval = function () {\n          if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n            this.pingTimer.reschedule(this.options.keepalive * 1000);\n          }\n        };\n        /**\n            * _checkPing - check if a pingresp has come back, and ping the server again\n            *\n            * @api private\n            */\n        MqttClient.prototype._checkPing = function () {\n          if (this.pingResp) {\n            this.pingResp = false;\n            this._sendPacket({ cmd: 'pingreq' });\n          } else {\n            // do a forced cleanup since socket will be in bad shape\n            this._cleanUp(true);\n          }\n        };\n\n        /**\n            * _handlePingresp - handle a pingresp\n            *\n            * @api private\n            */\n        MqttClient.prototype._handlePingresp = function () {\n          this.pingResp = true;\n        };\n\n        /**\n            * _handleConnack\n            *\n            * @param {Object} packet\n            * @api private\n            */\n\n        MqttClient.prototype._handleConnack = function (packet) {\n          var options = this.options;\n          var version = options.protocolVersion;\n          var rc = version === 5 ? packet.reasonCode : packet.returnCode;\n\n          clearTimeout(this.connackTimer);\n\n          if (packet.properties) {\n            if (packet.properties.topicAliasMaximum) {\n              if (!options.properties) {options.properties = {};}\n              options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum;\n            }\n            if (packet.properties.serverKeepAlive && options.keepalive) {\n              options.keepalive = packet.properties.serverKeepAlive;\n              this._shiftPingInterval();\n            }\n            if (packet.properties.maximumPacketSize) {\n              if (!options.properties) {options.properties = {};}\n              options.properties.maximumPacketSize = packet.properties.maximumPacketSize;\n            }\n          }\n\n          if (rc === 0) {\n            this.reconnecting = false;\n            this._onConnect(packet);\n          } else if (rc > 0) {\n            var err = new Error('Connection refused: ' + errors[rc]);\n            err.code = rc;\n            this.emit('error', err);\n          }\n        };\n\n        /**\n            * _handlePublish\n            *\n            * @param {Object} packet\n            * @api private\n            */\n        /*\n               those late 2 case should be rewrite to comply with coding style:\n               \n               case 1:\n               case 0:\n                 // do not wait sending a puback\n                 // no callback passed\n                 if (1 === qos) {\n                   this._sendPacket({\n                     cmd: 'puback',\n                     messageId: mid\n                   });\n                 }\n                 // emit the message event for both qos 1 and 0\n                 this.emit('message', topic, message, packet);\n                 this.handleMessage(packet, done);\n                 break;\n               default:\n                 // do nothing but every switch mus have a default\n                 // log or throw an error about unknown qos\n                 break;\n               \n               for now i just suppressed the warnings\n               */\n        MqttClient.prototype._handlePublish = function (packet, done) {\n          done = typeof done !== 'undefined' ? done : nop;\n          var topic = packet.topic.toString();\n          var message = packet.payload;\n          var qos = packet.qos;\n          var mid = packet.messageId;\n          var that = this;\n          var options = this.options;\n          var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];\n\n          switch (qos) {\n            case 2:{\n                options.customHandleAcks(topic, message, packet, function (error, code) {\n                  if (!(error instanceof Error)) {\n                    code = error;\n                    error = null;\n                  }\n                  if (error) {return that.emit('error', error);}\n                  if (validReasonCodes.indexOf(code) === -1) {return that.emit('error', new Error('Wrong reason code for pubrec'));}\n                  if (code) {\n                    that._sendPacket({ cmd: 'pubrec', messageId: mid, reasonCode: code }, done);\n                  } else {\n                    that.incomingStore.put(packet, function () {\n                      that._sendPacket({ cmd: 'pubrec', messageId: mid }, done);\n                    });\n                  }\n                });\n                break;\n              }\n            case 1:{\n                // emit the message event\n                options.customHandleAcks(topic, message, packet, function (error, code) {\n                  if (!(error instanceof Error)) {\n                    code = error;\n                    error = null;\n                  }\n                  if (error) {return that.emit('error', error);}\n                  if (validReasonCodes.indexOf(code) === -1) {return that.emit('error', new Error('Wrong reason code for puback'));}\n                  if (!code) {that.emit('message', topic, message, packet);}\n                  that.handleMessage(packet, function (err) {\n                    if (err) {\n                      return done && done(err);\n                    }\n                    that._sendPacket({ cmd: 'puback', messageId: mid, reasonCode: code }, done);\n                  });\n                });\n                break;\n              }\n            case 0:\n              // emit the message event\n              this.emit('message', topic, message, packet);\n              this.handleMessage(packet, done);\n              break;\n            default:\n              // do nothing\n              // log or throw an error about unknown qos\n              break;}\n\n        };\n\n        /**\n            * Handle messages with backpressure support, one at a time.\n            * Override at will.\n            *\n            * @param Packet packet the packet\n            * @param Function callback call when finished\n            * @api public\n            */\n        MqttClient.prototype.handleMessage = function (packet, callback) {\n          callback();\n        };\n\n        /**\n            * _handleAck\n            *\n            * @param {Object} packet\n            * @api private\n            */\n\n        MqttClient.prototype._handleAck = function (packet) {\n          /* eslint no-fallthrough: \"off\" */\n          var mid = packet.messageId;\n          var type = packet.cmd;\n          var response = null;\n          var cb = this.outgoing[mid] ? this.outgoing[mid].cb : null;\n          var that = this;\n          var err;\n\n          if (!cb) {\n            // Server sent an ack in error, ignore it.\n            return;\n          }\n\n          // Process\n          switch (type) {\n            case 'pubcomp':\n            // same thing as puback for QoS 2\n            case 'puback':\n              var pubackRC = packet.reasonCode;\n              // Callback - we're done\n              if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n                err = new Error('Publish error: ' + errors[pubackRC]);\n                err.code = pubackRC;\n                cb(err, packet);\n              }\n              delete this.outgoing[mid];\n              this.outgoingStore.del(packet, cb);\n              break;\n            case 'pubrec':\n              response = {\n                cmd: 'pubrel',\n                qos: 2,\n                messageId: mid };\n\n              var pubrecRC = packet.reasonCode;\n\n              if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n                err = new Error('Publish error: ' + errors[pubrecRC]);\n                err.code = pubrecRC;\n                cb(err, packet);\n              } else {\n                this._sendPacket(response);\n              }\n              break;\n            case 'suback':\n              delete this.outgoing[mid];\n              for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n                if ((packet.granted[grantedI] & 0x80) !== 0) {\n                  // suback with Failure status\n                  var topics = this.messageIdToTopic[mid];\n                  if (topics) {\n                    topics.forEach(function (topic) {\n                      delete that._resubscribeTopics[topic];\n                    });\n                  }\n                }\n              }\n              cb(null, packet);\n              break;\n            case 'unsuback':\n              delete this.outgoing[mid];\n              cb(null);\n              break;\n            default:\n              that.emit('error', new Error('unrecognized packet type'));}\n\n\n          if (this.disconnecting &&\n          Object.keys(this.outgoing).length === 0) {\n            this.emit('outgoingEmpty');\n          }\n        };\n\n        /**\n            * _handlePubrel\n            *\n            * @param {Object} packet\n            * @api private\n            */\n        MqttClient.prototype._handlePubrel = function (packet, callback) {\n          callback = typeof callback !== 'undefined' ? callback : nop;\n          var mid = packet.messageId;\n          var that = this;\n\n          var comp = { cmd: 'pubcomp', messageId: mid };\n\n          that.incomingStore.get(packet, function (err, pub) {\n            if (!err) {\n              that.emit('message', pub.topic, pub.payload, pub);\n              that.handleMessage(pub, function (err) {\n                if (err) {\n                  return callback(err);\n                }\n                that.incomingStore.del(pub, nop);\n                that._sendPacket(comp, callback);\n              });\n            } else {\n              that._sendPacket(comp, callback);\n            }\n          });\n        };\n\n        /**\n            * _handleDisconnect\n            *\n            * @param {Object} packet\n            * @api private\n            */\n        MqttClient.prototype._handleDisconnect = function (packet) {\n          this.emit('disconnect', packet);\n        };\n\n        /**\n            * _nextId\n            * @return unsigned int\n            */\n        MqttClient.prototype._nextId = function () {\n          // id becomes current state of this.nextId and increments afterwards\n          var id = this.nextId++;\n          // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n          if (this.nextId === 65536) {\n            this.nextId = 1;\n          }\n          return id;\n        };\n\n        /**\n            * getLastMessageId\n            * @return unsigned int\n            */\n        MqttClient.prototype.getLastMessageId = function () {\n          return this.nextId === 1 ? 65535 : this.nextId - 1;\n        };\n\n        /**\n            * _resubscribe\n            * @api private\n            */\n        MqttClient.prototype._resubscribe = function (connack) {\n          var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n          if (!this._firstConnection && (\n          this.options.clean || this.options.protocolVersion === 5 && !connack.sessionPresent) &&\n          _resubscribeTopicsKeys.length > 0) {\n            if (this.options.resubscribe) {\n              if (this.options.protocolVersion === 5) {\n                for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n                  var resubscribeTopic = {};\n                  resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n                  resubscribeTopic.resubscribe = true;\n                  this.subscribe(resubscribeTopic, { properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties });\n                }\n              } else {\n                this._resubscribeTopics.resubscribe = true;\n                this.subscribe(this._resubscribeTopics);\n              }\n            } else {\n              this._resubscribeTopics = {};\n            }\n          }\n\n          this._firstConnection = false;\n        };\n\n        /**\n            * _onConnect\n            *\n            * @api private\n            */\n        MqttClient.prototype._onConnect = function (packet) {\n          if (this.disconnected) {\n            this.emit('connect', packet);\n            return;\n          }\n\n          var that = this;\n\n          this._setupPingTimer();\n          this._resubscribe(packet);\n\n          this.connected = true;\n\n          function startStreamProcess() {\n            var outStore = that.outgoingStore.createStream();\n\n            function clearStoreProcessing() {\n              that._storeProcessing = false;\n              that._packetIdsDuringStoreProcessing = {};\n            }\n\n            that.once('close', remove);\n            outStore.on('error', function (err) {\n              clearStoreProcessing();\n              that.removeListener('close', remove);\n              that.emit('error', err);\n            });\n\n            function remove() {\n              outStore.destroy();\n              outStore = null;\n              clearStoreProcessing();\n            }\n\n            function storeDeliver() {\n              // edge case, we wrapped this twice\n              if (!outStore) {\n                return;\n              }\n              that._storeProcessing = true;\n\n              var packet = outStore.read(1);\n\n              var _cb;\n\n              if (!packet) {\n                // read when data is available in the future\n                outStore.once('readable', storeDeliver);\n                return;\n              }\n\n              // Skip already processed store packets\n              if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n                storeDeliver();\n                return;\n              }\n\n              // Avoid unnecessary stream read operations when disconnected\n              if (!that.disconnecting && !that.reconnectTimer) {\n                _cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null;\n                that.outgoing[packet.messageId] = {\n                  volatile: false,\n                  cb: function cb(err, status) {\n                    // Ensure that the original callback passed in to publish gets invoked\n                    if (_cb) {\n                      _cb(err, status);\n                    }\n\n                    storeDeliver();\n                  } };\n\n                that._packetIdsDuringStoreProcessing[packet.messageId] = true;\n                that._sendPacket(packet);\n              } else if (outStore.destroy) {\n                outStore.destroy();\n              }\n            }\n\n            outStore.on('end', function () {\n              var allProcessed = true;\n              for (var id in that._packetIdsDuringStoreProcessing) {\n                if (!that._packetIdsDuringStoreProcessing[id]) {\n                  allProcessed = false;\n                  break;\n                }\n              }\n              if (allProcessed) {\n                clearStoreProcessing();\n                that.removeListener('close', remove);\n                that.emit('connect', packet);\n              } else {\n                startStreamProcess();\n              }\n            });\n            storeDeliver();\n          }\n          // start flowing\n          startStreamProcess();\n        };\n\n        module.exports = MqttClient;\n\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, { \"./store\": 7, \"./validations\": 8, \"_process\": 92, \"events\": 13, \"inherits\": 80, \"mqtt-packet\": 84, \"readable-stream\": 108, \"reinterval\": 109, \"xtend\": 121 }], 2: [function (require, module, exports) {\n      (function (Buffer) {\n        'use strict';\n\n        var Transform = require('readable-stream').Transform;\n        var duplexify = require('duplexify');\n        var base64 = require('base64-js');\n\n        /* global FileReader */\n        var my;\n        var proxy;\n        var stream;\n        var isInitialized = false;\n\n        function buildProxy() {\n          var proxy = new Transform();\n          proxy._write = function (chunk, encoding, next) {\n            my.sendSocketMessage({\n              data: chunk.buffer,\n              success: function success() {\n                next();\n              },\n              fail: function fail() {\n                next(new Error());\n              } });\n\n          };\n          proxy._flush = function socketEnd(done) {\n            my.closeSocket({\n              success: function success() {\n                done();\n              } });\n\n          };\n\n          return proxy;\n        }\n\n        function setDefaultOpts(opts) {\n          if (!opts.hostname) {\n            opts.hostname = 'localhost';\n          }\n          if (!opts.path) {\n            opts.path = '/';\n          }\n\n          if (!opts.wsOptions) {\n            opts.wsOptions = {};\n          }\n        }\n\n        function buildUrl(opts, client) {\n          var protocol = opts.protocol === 'alis' ? 'wss' : 'ws';\n          var url = protocol + '://' + opts.hostname + opts.path;\n          if (opts.port && opts.port !== 80 && opts.port !== 443) {\n            url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n          }\n          if (typeof opts.transformWsUrl === 'function') {\n            url = opts.transformWsUrl(url, opts, client);\n          }\n          return url;\n        }\n\n        function bindEventHandler() {\n          if (isInitialized) return;\n\n          isInitialized = true;\n\n          my.onSocketOpen(function () {\n            stream.setReadable(proxy);\n            stream.setWritable(proxy);\n            stream.emit('connect');\n          });\n\n          my.onSocketMessage(function (res) {\n            if (typeof res.data === 'string') {\n              var array = base64.toByteArray(res.data);\n              var buffer = Buffer.from(array);\n              proxy.push(buffer);\n            } else {\n              var reader = new FileReader();\n              reader.addEventListener('load', function () {\n                var data = reader.result;\n\n                if (data instanceof ArrayBuffer) data = Buffer.from(data);else\n                data = Buffer.from(data, 'utf8');\n                proxy.push(data);\n              });\n              reader.readAsArrayBuffer(res.data);\n            }\n          });\n\n          my.onSocketClose(function () {\n            stream.end();\n            stream.destroy();\n          });\n\n          my.onSocketError(function (res) {\n            stream.destroy(res);\n          });\n        }\n\n        function buildStream(client, opts) {\n          opts.hostname = opts.hostname || opts.host;\n\n          if (!opts.hostname) {\n            throw new Error('Could not determine host. Specify host manually.');\n          }\n\n          var websocketSubProtocol =\n          opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ?\n          'mqttv3.1' :\n          'mqtt';\n\n          setDefaultOpts(opts);\n\n          var url = buildUrl(opts, client);\n          my = opts.my;\n          my.connectSocket({\n            url: url,\n            protocols: websocketSubProtocol });\n\n\n          proxy = buildProxy();\n          stream = duplexify.obj();\n\n          bindEventHandler();\n\n          return stream;\n        }\n\n        module.exports = buildStream;\n\n      }).call(this, require(\"buffer\").Buffer);\n    }, { \"base64-js\": 10, \"buffer\": 12, \"duplexify\": 17, \"readable-stream\": 108 }], 3: [function (require, module, exports) {\n      'use strict';\n      var net = require('net');\n\n      /*\n                                  variables port and host can be removed since\n                                  you have all required information in opts object\n                                */\n      function buildBuilder(client, opts) {\n        var port, host;\n        opts.port = opts.port || 1883;\n        opts.hostname = opts.hostname || opts.host || 'localhost';\n\n        port = opts.port;\n        host = opts.hostname;\n\n        return net.createConnection(port, host);\n      }\n\n      module.exports = buildBuilder;\n\n    }, { \"net\": 11 }], 4: [function (require, module, exports) {\n      'use strict';\n      var tls = require('tls');\n\n      function buildBuilder(mqttClient, opts) {\n        var connection;\n        opts.port = opts.port || 8883;\n        opts.host = opts.hostname || opts.host || 'localhost';\n\n        opts.rejectUnauthorized = opts.rejectUnauthorized !== false;\n\n        delete opts.path;\n\n        connection = tls.connect(opts);\n        /* eslint no-use-before-define: [2, \"nofunc\"] */\n        connection.on('secureConnect', function () {\n          if (opts.rejectUnauthorized && !connection.authorized) {\n            connection.emit('error', new Error('TLS not authorized'));\n          } else {\n            connection.removeListener('error', handleTLSerrors);\n          }\n        });\n\n        function handleTLSerrors(err) {\n          // How can I get verify this error is a tls error?\n          if (opts.rejectUnauthorized) {\n            mqttClient.emit('error', err);\n          }\n\n          // close this connection to match the behaviour of net\n          // otherwise all we get is an error from the connection\n          // and close event doesn't fire. This is a work around\n          // to enable the reconnect code to work the same as with\n          // net.createConnection\n          connection.end();\n        }\n\n        connection.on('error', handleTLSerrors);\n        return connection;\n      }\n\n      module.exports = buildBuilder;\n\n    }, { \"tls\": 11 }], 5: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        var websocket = require('websocket-stream');\n        var urlModule = require('url');\n        var WSS_OPTIONS = [\n        'rejectUnauthorized',\n        'ca',\n        'cert',\n        'key',\n        'pfx',\n        'passphrase'];\n\n        var IS_BROWSER = process.title === 'browser';\n\n        function buildUrl(opts, client) {\n          var url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n          if (typeof opts.transformWsUrl === 'function') {\n            url = opts.transformWsUrl(url, opts, client);\n          }\n          return url;\n        }\n\n        function setDefaultOpts(opts) {\n          if (!opts.hostname) {\n            opts.hostname = 'localhost';\n          }\n          if (!opts.port) {\n            if (opts.protocol === 'wss') {\n              opts.port = 443;\n            } else {\n              opts.port = 80;\n            }\n          }\n          if (!opts.path) {\n            opts.path = '/';\n          }\n\n          if (!opts.wsOptions) {\n            opts.wsOptions = {};\n          }\n          if (!IS_BROWSER && opts.protocol === 'wss') {\n            // Add cert/key/ca etc options\n            WSS_OPTIONS.forEach(function (prop) {\n              if (opts.hasOwnProperty(prop) && !opts.wsOptions.hasOwnProperty(prop)) {\n                opts.wsOptions[prop] = opts[prop];\n              }\n            });\n          }\n        }\n\n        function createWebSocket(client, opts) {\n          var websocketSubProtocol =\n          opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ?\n          'mqttv3.1' :\n          'mqtt';\n\n          setDefaultOpts(opts);\n          var url = buildUrl(opts, client);\n          return websocket(url, [websocketSubProtocol], opts.wsOptions);\n        }\n\n        function buildBuilder(client, opts) {\n          return createWebSocket(client, opts);\n        }\n\n        function buildBuilderBrowser(client, opts) {\n          if (!opts.hostname) {\n            opts.hostname = opts.host;\n          }\n\n          if (!opts.hostname) {\n            // Throwing an error in a Web Worker if no `hostname` is given, because we\n            // can not determine the `hostname` automatically.  If connecting to\n            // localhost, please supply the `hostname` as an argument.\n            if (typeof document === 'undefined') {\n              throw new Error('Could not determine host. Specify host manually.');\n            }\n            var parsed = urlModule.parse(document.URL);\n            opts.hostname = parsed.hostname;\n\n            if (!opts.port) {\n              opts.port = parsed.port;\n            }\n          }\n          return createWebSocket(client, opts);\n        }\n\n        if (IS_BROWSER) {\n          module.exports = buildBuilderBrowser;\n        } else {\n          module.exports = buildBuilder;\n        }\n\n      }).call(this, require('_process'));\n    }, { \"_process\": 92, \"url\": 113, \"websocket-stream\": 118 }], 6: [function (require, module, exports) {\n      (function (process, Buffer) {\n        'use strict';\n\n        var Transform = require('readable-stream').Transform;\n        var duplexify = require('duplexify');\n\n        /* global wx */\n        var socketTask;\n        var proxy;\n        var stream;\n\n        function buildProxy() {\n          var proxy = new Transform();\n          proxy._write = function (chunk, encoding, next) {\n            socketTask.send({\n              data: chunk.buffer,\n              success: function success() {\n                next();\n              },\n              fail: function fail(errMsg) {\n                next(new Error(errMsg));\n              } });\n\n          };\n          proxy._flush = function socketEnd(done) {\n            socketTask.close({\n              success: function success() {\n                done();\n              } });\n\n          };\n\n          return proxy;\n        }\n\n        function setDefaultOpts(opts) {\n          if (!opts.hostname) {\n            opts.hostname = 'localhost';\n          }\n          if (!opts.path) {\n            opts.path = '/';\n          }\n\n          if (!opts.wsOptions) {\n            opts.wsOptions = {};\n          }\n        }\n\n        function buildUrl(opts, client) {\n          var protocol = opts.protocol === 'wxs' ? 'wss' : 'ws';\n          var url = protocol + '://' + opts.hostname + opts.path;\n          if (opts.port && opts.port !== 80 && opts.port !== 443) {\n            url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n          }\n          if (typeof opts.transformWsUrl === 'function') {\n            url = opts.transformWsUrl(url, opts, client);\n          }\n          return url;\n        }\n\n        function bindEventHandler() {\n          socketTask.onOpen(function () {\n            stream.setReadable(proxy);\n            stream.setWritable(proxy);\n            stream.emit('connect');\n          });\n\n          socketTask.onMessage(function (res) {\n            var data = res.data;\n\n            if (data instanceof ArrayBuffer) data = Buffer.from(data);else\n            data = Buffer.from(data, 'utf8');\n            proxy.push(data);\n          });\n\n          socketTask.onClose(function () {\n            stream.end();\n            stream.destroy();\n          });\n\n          socketTask.onError(function (res) {\n            stream.destroy(new Error(res.errMsg));\n          });\n        }\n\n        function buildStream(client, opts) {\n          opts.hostname = opts.hostname || opts.host;\n\n          if (!opts.hostname) {\n            throw new Error('Could not determine host. Specify host manually.');\n          }\n\n          var websocketSubProtocol =\n          opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ?\n          'mqttv3.1' :\n          'mqtt';\n\n          setDefaultOpts(opts);\n\n          var url = buildUrl(opts, client);\n          socketTask = wx.connectSocket({\n            url: url,\n            protocols: websocketSubProtocol });\n\n\n          proxy = buildProxy();\n          stream = duplexify.obj();\n          stream._destroy = function (err, cb) {\n            socketTask.close({\n              success: function success() {\n                cb && cb(err);\n              } });\n\n          };\n\n          var destroyRef = stream.destroy;\n          stream.destroy = function () {\n            stream.destroy = destroyRef;\n\n            var self = this;\n            process.nextTick(function () {\n              socketTask.close({\n                fail: function fail() {\n                  self._destroy(new Error());\n                } });\n\n            });\n          }.bind(stream);\n\n          bindEventHandler();\n\n          return stream;\n        }\n\n        module.exports = buildStream;\n\n      }).call(this, require('_process'), require(\"buffer\").Buffer);\n    }, { \"_process\": 92, \"buffer\": 12, \"duplexify\": 17, \"readable-stream\": 108 }], 7: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        /**\n                       * Module dependencies\n                       */\n        var xtend = require('xtend');\n\n        var Readable = require('readable-stream').Readable;\n        var streamsOpts = { objectMode: true };\n        var defaultStoreOptions = {\n          clean: true };\n\n\n        /**\n                          * es6-map can preserve insertion order even if ES version is older.\n                          *\n                          * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Description\n                          * It should be noted that a Map which is a map of an object, especially\n                          * a dictionary of dictionaries, will only map to the object's insertion\n                          * order. In ES2015 this is ordered for objects but for older versions of\n                          * ES, this may be random and not ordered.\n                          *\n                          */\n        var Map = require('es6-map');\n\n        /**\n                                       * In-memory implementation of the message store\n                                       * This can actually be saved into files.\n                                       *\n                                       * @param {Object} [options] - store options\n                                       */\n        function Store(options) {\n          if (!(this instanceof Store)) {\n            return new Store(options);\n          }\n\n          this.options = options || {};\n\n          // Defaults\n          this.options = xtend(defaultStoreOptions, options);\n\n          this._inflights = new Map();\n        }\n\n        /**\n           * Adds a packet to the store, a packet is\n           * anything that has a messageId property.\n           *\n           */\n        Store.prototype.put = function (packet, cb) {\n          this._inflights.set(packet.messageId, packet);\n\n          if (cb) {\n            cb();\n          }\n\n          return this;\n        };\n\n        /**\n            * Creates a stream with all the packets in the store\n            *\n            */\n        Store.prototype.createStream = function () {\n          var stream = new Readable(streamsOpts);\n          var destroyed = false;\n          var values = [];\n          var i = 0;\n\n          this._inflights.forEach(function (value, key) {\n            values.push(value);\n          });\n\n          stream._read = function () {\n            if (!destroyed && i < values.length) {\n              this.push(values[i++]);\n            } else {\n              this.push(null);\n            }\n          };\n\n          stream.destroy = function () {\n            if (destroyed) {\n              return;\n            }\n\n            var self = this;\n\n            destroyed = true;\n\n            process.nextTick(function () {\n              self.emit('close');\n            });\n          };\n\n          return stream;\n        };\n\n        /**\n            * deletes a packet from the store.\n            */\n        Store.prototype.del = function (packet, cb) {\n          packet = this._inflights.get(packet.messageId);\n          if (packet) {\n            this._inflights.delete(packet.messageId);\n            cb(null, packet);\n          } else if (cb) {\n            cb(new Error('missing packet'));\n          }\n\n          return this;\n        };\n\n        /**\n            * get a packet from the store.\n            */\n        Store.prototype.get = function (packet, cb) {\n          packet = this._inflights.get(packet.messageId);\n          if (packet) {\n            cb(null, packet);\n          } else if (cb) {\n            cb(new Error('missing packet'));\n          }\n\n          return this;\n        };\n\n        /**\n            * Close the store\n            */\n        Store.prototype.close = function (cb) {\n          if (this.options.clean) {\n            this._inflights = null;\n          }\n          if (cb) {\n            cb();\n          }\n        };\n\n        module.exports = Store;\n\n      }).call(this, require('_process'));\n    }, { \"_process\": 92, \"es6-map\": 67, \"readable-stream\": 108, \"xtend\": 121 }], 8: [function (require, module, exports) {\n      'use strict';\n\n      /**\n                     * Validate a topic to see if it's valid or not.\n                     * A topic is valid if it follow below rules:\n                     * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'\n                     * - Rule #2: Part `#` must be located at the end of the mailbox\n                     *\n                     * @param {String} topic - A topic\n                     * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.\n                     */\n      function validateTopic(topic) {\n        var parts = topic.split('/');\n\n        for (var i = 0; i < parts.length; i++) {\n          if (parts[i] === '+') {\n            continue;\n          }\n\n          if (parts[i] === '#') {\n            // for Rule #2\n            return i === parts.length - 1;\n          }\n\n          if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      /**\n         * Validate an array of topics to see if any of them is valid or not\n          * @param {Array} topics - Array of topics\n         * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one\n         */\n      function validateTopics(topics) {\n        if (topics.length === 0) {\n          return 'empty_topic_list';\n        }\n        for (var i = 0; i < topics.length; i++) {\n          if (!validateTopic(topics[i])) {\n            return topics[i];\n          }\n        }\n        return null;\n      }\n\n      module.exports = {\n        validateTopics: validateTopics };\n\n\n    }, {}], 9: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        var MqttClient = require('../client');\n        var Store = require('../store');\n        var url = require('url');\n        var xtend = require('xtend');\n        var protocols = {};\n\n        if (process.title !== 'browser') {\n          protocols.mqtt = require('./tcp');\n          protocols.tcp = require('./tcp');\n          protocols.ssl = require('./tls');\n          protocols.tls = require('./tls');\n          protocols.mqtts = require('./tls');\n        } else {\n          protocols.wx = require('./wx');\n          protocols.wxs = require('./wx');\n\n          protocols.ali = require('./ali');\n          protocols.alis = require('./ali');\n        }\n\n        protocols.ws = require('./ws');\n        protocols.wss = require('./ws');\n\n        /**\n                                          * Parse the auth attribute and merge username and password in the options object.\n                                          *\n                                          * @param {Object} [opts] option object\n                                          */\n        function parseAuthOptions(opts) {\n          var matches;\n          if (opts.auth) {\n            matches = opts.auth.match(/^(.+):(.+)$/);\n            if (matches) {\n              opts.username = matches[1];\n              opts.password = matches[2];\n            } else {\n              opts.username = opts.auth;\n            }\n          }\n        }\n\n        /**\n           * connect - connect to an MQTT broker.\n           *\n           * @param {String} [brokerUrl] - url of the broker, optional\n           * @param {Object} opts - see MqttClient#constructor\n           */\n        function connect(brokerUrl, opts) {\n          if (typeof brokerUrl === 'object' && !opts) {\n            opts = brokerUrl;\n            brokerUrl = null;\n          }\n\n          opts = opts || {};\n\n          if (brokerUrl) {\n            var parsed = url.parse(brokerUrl, true);\n            if (parsed.port != null) {\n              parsed.port = Number(parsed.port);\n            }\n\n            opts = xtend(parsed, opts);\n\n            if (opts.protocol === null) {\n              throw new Error('Missing protocol');\n            }\n            opts.protocol = opts.protocol.replace(/:$/, '');\n          }\n\n          // merge in the auth options if supplied\n          parseAuthOptions(opts);\n\n          // support clientId passed in the query string of the url\n          if (opts.query && typeof opts.query.clientId === 'string') {\n            opts.clientId = opts.query.clientId;\n          }\n\n          if (opts.cert && opts.key) {\n            if (opts.protocol) {\n              if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {\n                switch (opts.protocol) {\n                  case 'mqtt':\n                    opts.protocol = 'mqtts';\n                    break;\n                  case 'ws':\n                    opts.protocol = 'wss';\n                    break;\n                  case 'wx':\n                    opts.protocol = 'wxs';\n                    break;\n                  case 'ali':\n                    opts.protocol = 'alis';\n                    break;\n                  default:\n                    throw new Error('Unknown protocol for secure connection: \"' + opts.protocol + '\"!');}\n\n              }\n            } else {\n              // don't know what protocol he want to use, mqtts or wss\n              throw new Error('Missing secure protocol key');\n            }\n          }\n\n          if (!protocols[opts.protocol]) {\n            var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1;\n            opts.protocol = [\n            'mqtt',\n            'mqtts',\n            'ws',\n            'wss',\n            'wx',\n            'wxs',\n            'ali',\n            'alis'].\n            filter(function (key, index) {\n              if (isSecure && index % 2 === 0) {\n                // Skip insecure protocols when requesting a secure one.\n                return false;\n              }\n              return typeof protocols[key] === 'function';\n            })[0];\n          }\n\n          if (opts.clean === false && !opts.clientId) {\n            throw new Error('Missing clientId for unclean clients');\n          }\n\n          if (opts.protocol) {\n            opts.defaultProtocol = opts.protocol;\n          }\n\n          function wrapper(client) {\n            if (opts.servers) {\n              if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\n                client._reconnectCount = 0;\n              }\n\n              opts.host = opts.servers[client._reconnectCount].host;\n              opts.port = opts.servers[client._reconnectCount].port;\n              opts.protocol = !opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol;\n              opts.hostname = opts.host;\n\n              client._reconnectCount++;\n            }\n\n            return protocols[opts.protocol](client, opts);\n          }\n\n          return new MqttClient(wrapper, opts);\n        }\n\n        module.exports = connect;\n        module.exports.connect = connect;\n        module.exports.MqttClient = MqttClient;\n        module.exports.Store = Store;\n\n      }).call(this, require('_process'));\n    }, { \"../client\": 1, \"../store\": 7, \"./ali\": 2, \"./tcp\": 3, \"./tls\": 4, \"./ws\": 5, \"./wx\": 6, \"_process\": 92, \"url\": 113, \"xtend\": 121 }], 10: [function (require, module, exports) {\n      'use strict';\n\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\n      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n      for (var i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n\n      // Support decoding URL-safe base64 strings, as Node.js does.\n      // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n      revLookup['-'.charCodeAt(0)] = 62;\n      revLookup['_'.charCodeAt(0)] = 63;\n\n      function getLens(b64) {\n        var len = b64.length;\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        }\n\n        // Trim off extra bytes after placeholder bytes are found\n        // See: https://github.com/beatgammit/base64-js/issues/42\n        var validLen = b64.indexOf('=');\n        if (validLen === -1) validLen = len;\n\n        var placeHoldersLen = validLen === len ?\n        0 :\n        4 - validLen % 4;\n\n        return [validLen, placeHoldersLen];\n      }\n\n      // base64 is 4/3 + up to two characters of the original data\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n        var curByte = 0;\n\n        // if there are placeholders, only get up to the last complete 4 chars\n        var len = placeHoldersLen > 0 ?\n        validLen - 4 :\n        validLen;\n\n        for (var i = 0; i < len; i += 4) {\n          tmp =\n          revLookup[b64.charCodeAt(i)] << 18 |\n          revLookup[b64.charCodeAt(i + 1)] << 12 |\n          revLookup[b64.charCodeAt(i + 2)] << 6 |\n          revLookup[b64.charCodeAt(i + 3)];\n          arr[curByte++] = tmp >> 16 & 0xFF;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        if (placeHoldersLen === 2) {\n          tmp =\n          revLookup[b64.charCodeAt(i)] << 2 |\n          revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        if (placeHoldersLen === 1) {\n          tmp =\n          revLookup[b64.charCodeAt(i)] << 10 |\n          revLookup[b64.charCodeAt(i + 1)] << 4 |\n          revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        return arr;\n      }\n\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3F] +\n        lookup[num >> 12 & 0x3F] +\n        lookup[num >> 6 & 0x3F] +\n        lookup[num & 0x3F];\n      }\n\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i = start; i < end; i += 3) {\n          tmp =\n          (uint8[i] << 16 & 0xFF0000) + (\n          uint8[i + 1] << 8 & 0xFF00) + (\n          uint8[i + 2] & 0xFF);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join('');\n      }\n\n      function fromByteArray(uint8) {\n        var tmp;\n        var len = uint8.length;\n        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n        var parts = [];\n        var maxChunkLength = 16383; // must be multiple of 3\n\n        // go through the array every three bytes, we'll deal with trailing stuff later\n        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n          parts.push(encodeChunk(\n          uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n\n        }\n\n        // pad the end with zeros, but make sure to not forget the extra bytes\n        if (extraBytes === 1) {\n          tmp = uint8[len - 1];\n          parts.push(\n          lookup[tmp >> 2] +\n          lookup[tmp << 4 & 0x3F] +\n          '==');\n\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n          parts.push(\n          lookup[tmp >> 10] +\n          lookup[tmp >> 4 & 0x3F] +\n          lookup[tmp << 2 & 0x3F] +\n          '=');\n\n        }\n\n        return parts.join('');\n      }\n\n    }, {}], 11: [function (require, module, exports) {\n\n    }, {}], 12: [function (require, module, exports) {\n      /*!\n                                                       * The buffer module from node.js, for the browser.\n                                                       *\n                                                       * @author   Feross Aboukhadijeh <https://feross.org>\n                                                       * @license  MIT\n                                                       */\n      /* eslint-disable no-proto */\n\n      'use strict';\n\n      var base64 = require('base64-js');\n      var ieee754 = require('ieee754');\n\n      exports.Buffer = Buffer;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n\n      var K_MAX_LENGTH = 0x7fffffff;\n      exports.kMaxLength = K_MAX_LENGTH;\n\n      /**\n                                          * If `Buffer.TYPED_ARRAY_SUPPORT`:\n                                          *   === true    Use Uint8Array implementation (fastest)\n                                          *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n                                          *               implementation (most compatible, even IE6)\n                                          *\n                                          * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n                                          * Opera 11.6+, iOS 4.2+.\n                                          *\n                                          * We report that the browser does not support typed arrays if the are not subclassable\n                                          * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n                                          * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n                                          * for __proto__ and has a buggy typed array implementation.\n                                          */\n      Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n      if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n      typeof console.error === 'function') {\n        __f__(\"error\",\n        'This browser lacks typed array (Uint8Array) support which is required by ' +\n        '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.', \" at utils/mqtt.js:2450\");\n\n      }\n\n      function typedArraySupport() {\n        // Can typed array instances can be augmented?\n        try {\n          var arr = new Uint8Array(1);\n          arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {return 42;} };\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      Object.defineProperty(Buffer.prototype, 'parent', {\n        enumerable: true,\n        get: function get() {\n          if (!Buffer.isBuffer(this)) return undefined;\n          return this.buffer;\n        } });\n\n\n      Object.defineProperty(Buffer.prototype, 'offset', {\n        enumerable: true,\n        get: function get() {\n          if (!Buffer.isBuffer(this)) return undefined;\n          return this.byteOffset;\n        } });\n\n\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        // Return an augmented `Uint8Array` instance\n        var buf = new Uint8Array(length);\n        buf.__proto__ = Buffer.prototype;\n        return buf;\n      }\n\n      /**\n         * The Buffer constructor returns instances of `Uint8Array` that have their\n         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n         * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n         * returns a single octet.\n         *\n         * The `Uint8Array` prototype remains unmodified.\n         */\n\n      function Buffer(arg, encodingOrOffset, length) {\n        // Common case.\n        if (typeof arg === 'number') {\n          if (typeof encodingOrOffset === 'string') {\n            throw new TypeError(\n            'The \"string\" argument must be of type string. Received type number');\n\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n\n      // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n      if (typeof Symbol !== 'undefined' && Symbol.species != null &&\n      Buffer[Symbol.species] === Buffer) {\n        Object.defineProperty(Buffer, Symbol.species, {\n          value: null,\n          configurable: true,\n          enumerable: false,\n          writable: false });\n\n      }\n\n      Buffer.poolSize = 8192; // not used by this implementation\n\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === 'string') {\n          return fromString(value, encodingOrOffset);\n        }\n\n        if (ArrayBuffer.isView(value)) {\n          return fromArrayLike(value);\n        }\n\n        if (value == null) {\n          throw TypeError(\n          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n          'or Array-like Object. Received type ' + typeof value);\n\n        }\n\n        if (isInstance(value, ArrayBuffer) ||\n        value && isInstance(value.buffer, ArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n\n        if (typeof value === 'number') {\n          throw new TypeError(\n          'The \"value\" argument must not be of type number. Received type number');\n\n        }\n\n        var valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer.from(valueOf, encodingOrOffset, length);\n        }\n\n        var b = fromObject(value);\n        if (b) return b;\n\n        if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n        typeof value[Symbol.toPrimitive] === 'function') {\n          return Buffer.from(\n          value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n\n        }\n\n        throw new TypeError(\n        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n        'or Array-like Object. Received type ' + typeof value);\n\n      }\n\n      /**\n         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n         * if value is a number.\n         * Buffer.from(str[, encoding])\n         * Buffer.from(array)\n         * Buffer.from(buffer)\n         * Buffer.from(arrayBuffer[, byteOffset[, length]])\n         **/\n      Buffer.from = function (value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n\n      // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n      // https://github.com/feross/buffer/pull/148\n      Buffer.prototype.__proto__ = Uint8Array.prototype;\n      Buffer.__proto__ = Uint8Array;\n\n      function assertSize(size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== undefined) {\n          // Only pay attention to encoding if it's a string. This\n          // prevents accidentally sending in a number that would\n          // be interpretted as a start offset.\n          return typeof encoding === 'string' ?\n          createBuffer(size).fill(fill, encoding) :\n          createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n\n      /**\n         * Creates a new filled Buffer instance.\n         * alloc(size[, fill[, encoding]])\n         **/\n      Buffer.alloc = function (size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n\n      /**\n         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n         * */\n      Buffer.allocUnsafe = function (size) {\n        return allocUnsafe(size);\n      };\n      /**\n          * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n          */\n      Buffer.allocUnsafeSlow = function (size) {\n        return allocUnsafe(size);\n      };\n\n      function fromString(string, encoding) {\n        if (typeof encoding !== 'string' || encoding === '') {\n          encoding = 'utf8';\n        }\n\n        if (!Buffer.isEncoding(encoding)) {\n          throw new TypeError('Unknown encoding: ' + encoding);\n        }\n\n        var length = byteLength(string, encoding) | 0;\n        var buf = createBuffer(length);\n\n        var actual = buf.write(string, encoding);\n\n        if (actual !== length) {\n          // Writing a hex string, for example, that contains invalid characters will\n          // cause everything after the first invalid character to be ignored. (e.g.\n          // 'abxxcd' will be treated as 'ab')\n          buf = buf.slice(0, actual);\n        }\n\n        return buf;\n      }\n\n      function fromArrayLike(array) {\n        var length = array.length < 0 ? 0 : checked(array.length) | 0;\n        var buf = createBuffer(length);\n        for (var i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n\n        var buf;\n        if (byteOffset === undefined && length === undefined) {\n          buf = new Uint8Array(array);\n        } else if (length === undefined) {\n          buf = new Uint8Array(array, byteOffset);\n        } else {\n          buf = new Uint8Array(array, byteOffset, length);\n        }\n\n        // Return an augmented `Uint8Array` instance\n        buf.__proto__ = Buffer.prototype;\n        return buf;\n      }\n\n      function fromObject(obj) {\n        if (Buffer.isBuffer(obj)) {\n          var len = checked(obj.length) | 0;\n          var buf = createBuffer(len);\n\n          if (buf.length === 0) {\n            return buf;\n          }\n\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n\n        if (obj.length !== undefined) {\n          if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n\n        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n\n      function checked(length) {\n        // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n        // length is NaN (which is otherwise coerced to zero.)\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n          'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n        }\n        return length | 0;\n      }\n\n      function SlowBuffer(length) {\n        if (+length != length) {// eslint-disable-line eqeqeq\n          length = 0;\n        }\n        return Buffer.alloc(+length);\n      }\n\n      Buffer.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true &&\n        b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n      };\n\n      Buffer.compare = function compare(a, b) {\n        if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n        if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n          throw new TypeError(\n          'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n\n        }\n\n        if (a === b) return 0;\n\n        var x = a.length;\n        var y = b.length;\n\n        for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n\n        if (x < y) return -1;\n        if (y < x) return 1;\n        return 0;\n      };\n\n      Buffer.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case 'hex':\n          case 'utf8':\n          case 'utf-8':\n          case 'ascii':\n          case 'latin1':\n          case 'binary':\n          case 'base64':\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            return true;\n          default:\n            return false;}\n\n      };\n\n      Buffer.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n\n        if (list.length === 0) {\n          return Buffer.alloc(0);\n        }\n\n        var i;\n        if (length === undefined) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n\n        var buffer = Buffer.allocUnsafe(length);\n        var pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          var buf = list[i];\n          if (isInstance(buf, Uint8Array)) {\n            buf = Buffer.from(buf);\n          }\n          if (!Buffer.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          }\n          buf.copy(buffer, pos);\n          pos += buf.length;\n        }\n        return buffer;\n      };\n\n      function byteLength(string, encoding) {\n        if (Buffer.isBuffer(string)) {\n          return string.length;\n        }\n        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== 'string') {\n          throw new TypeError(\n          'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n          'Received type ' + typeof string);\n\n        }\n\n        var len = string.length;\n        var mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0) return 0;\n\n        // Use a for loop to avoid recursion\n        var loweredCase = false;\n        for (;;) {\n          switch (encoding) {\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n              return len;\n            case 'utf8':\n            case 'utf-8':\n              return utf8ToBytes(string).length;\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return len * 2;\n            case 'hex':\n              return len >>> 1;\n            case 'base64':\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n              }\n              encoding = ('' + encoding).toLowerCase();\n              loweredCase = true;}\n\n        }\n      }\n      Buffer.byteLength = byteLength;\n\n      function slowToString(encoding, start, end) {\n        var loweredCase = false;\n\n        // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n        // property of a typed array.\n\n        // This behaves neither like String nor Uint8Array in that we set start/end\n        // to their upper/lower bounds if the value passed is out of range.\n        // undefined is handled specially as per ECMA-262 6th Edition,\n        // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n        if (start === undefined || start < 0) {\n          start = 0;\n        }\n        // Return early if start > this.length. Done here to prevent potential uint32\n        // coercion fail below.\n        if (start > this.length) {\n          return '';\n        }\n\n        if (end === undefined || end > this.length) {\n          end = this.length;\n        }\n\n        if (end <= 0) {\n          return '';\n        }\n\n        // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n        end >>>= 0;\n        start >>>= 0;\n\n        if (end <= start) {\n          return '';\n        }\n\n        if (!encoding) encoding = 'utf8';\n\n        while (true) {\n          switch (encoding) {\n            case 'hex':\n              return hexSlice(this, start, end);\n\n            case 'utf8':\n            case 'utf-8':\n              return utf8Slice(this, start, end);\n\n            case 'ascii':\n              return asciiSlice(this, start, end);\n\n            case 'latin1':\n            case 'binary':\n              return latin1Slice(this, start, end);\n\n            case 'base64':\n              return base64Slice(this, start, end);\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return utf16leSlice(this, start, end);\n\n            default:\n              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n              encoding = (encoding + '').toLowerCase();\n              loweredCase = true;}\n\n        }\n      }\n\n      // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n      // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n      // reliably in a browserify context because there could be multiple different\n      // copies of the 'buffer' package in use. This method works even for Buffer\n      // instances that were created from another copy of the `buffer` package.\n      // See: https://github.com/feross/buffer/issues/154\n      Buffer.prototype._isBuffer = true;\n\n      function swap(b, n, m) {\n        var i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n\n      Buffer.prototype.swap16 = function swap16() {\n        var len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError('Buffer size must be a multiple of 16-bits');\n        }\n        for (var i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n\n      Buffer.prototype.swap32 = function swap32() {\n        var len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError('Buffer size must be a multiple of 32-bits');\n        }\n        for (var i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n\n      Buffer.prototype.swap64 = function swap64() {\n        var len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError('Buffer size must be a multiple of 64-bits');\n        }\n        for (var i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n\n      Buffer.prototype.toString = function toString() {\n        var length = this.length;\n        if (length === 0) return '';\n        if (arguments.length === 0) return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n\n      Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n      Buffer.prototype.equals = function equals(b) {\n        if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n        if (this === b) return true;\n        return Buffer.compare(this, b) === 0;\n      };\n\n      Buffer.prototype.inspect = function inspect() {\n        var str = '';\n        var max = exports.INSPECT_MAX_BYTES;\n        str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n        if (this.length > max) str += ' ... ';\n        return '<Buffer ' + str + '>';\n      };\n\n      Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, Uint8Array)) {\n          target = Buffer.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer.isBuffer(target)) {\n          throw new TypeError(\n          'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n          'Received type ' + typeof target);\n\n        }\n\n        if (start === undefined) {\n          start = 0;\n        }\n        if (end === undefined) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === undefined) {\n          thisStart = 0;\n        }\n        if (thisEnd === undefined) {\n          thisEnd = this.length;\n        }\n\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError('out of range index');\n        }\n\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n\n        if (this === target) return 0;\n\n        var x = thisEnd - thisStart;\n        var y = end - start;\n        var len = Math.min(x, y);\n\n        var thisCopy = this.slice(thisStart, thisEnd);\n        var targetCopy = target.slice(start, end);\n\n        for (var i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n\n        if (x < y) return -1;\n        if (y < x) return 1;\n        return 0;\n      };\n\n      // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n      // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n      //\n      // Arguments:\n      // - buffer - a Buffer to search\n      // - val - a string, Buffer, or number\n      // - byteOffset - an index into `buffer`; will be clamped to an int32\n      // - encoding - an optional encoding, relevant is val is a string\n      // - dir - true for indexOf, false for lastIndexOf\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        // Empty buffer means no match\n        if (buffer.length === 0) return -1;\n\n        // Normalize byteOffset\n        if (typeof byteOffset === 'string') {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 0x7fffffff) {\n          byteOffset = 0x7fffffff;\n        } else if (byteOffset < -0x80000000) {\n          byteOffset = -0x80000000;\n        }\n        byteOffset = +byteOffset; // Coerce to Number.\n        if (numberIsNaN(byteOffset)) {\n          // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n\n        // Normalize byteOffset: negative offsets start from the end of the buffer\n        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir) return -1;else\n          byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir) byteOffset = 0;else\n          return -1;\n        }\n\n        // Normalize val\n        if (typeof val === 'string') {\n          val = Buffer.from(val, encoding);\n        }\n\n        // Finally, search either indexOf (if dir is true) or lastIndexOf\n        if (Buffer.isBuffer(val)) {\n          // Special case: looking for empty string/buffer always fails\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === 'number') {\n          val = val & 0xFF; // Search for a byte value [0-255]\n          if (typeof Uint8Array.prototype.indexOf === 'function') {\n            if (dir) {\n              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n\n        throw new TypeError('val must be string, number or Buffer');\n      }\n\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        var indexSize = 1;\n        var arrLength = arr.length;\n        var valLength = val.length;\n\n        if (encoding !== undefined) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n          encoding === 'utf16le' || encoding === 'utf-16le') {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n\n        function read(buf, i) {\n          if (indexSize === 1) {\n            return buf[i];\n          } else {\n            return buf.readUInt16BE(i * indexSize);\n          }\n        }\n\n        var i;\n        if (dir) {\n          var foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1) foundIndex = i;\n              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1) i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            var found = true;\n            for (var j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found) return i;\n          }\n        }\n\n        return -1;\n      }\n\n      Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n\n      Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n\n      Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        var remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n\n        var strLen = string.length;\n\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        for (var i = 0; i < length; ++i) {\n          var parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed)) return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n\n      function latin1Write(buf, string, offset, length) {\n        return asciiWrite(buf, string, offset, length);\n      }\n\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n\n      Buffer.prototype.write = function write(string, offset, length, encoding) {\n        // Buffer#write(string)\n        if (offset === undefined) {\n          encoding = 'utf8';\n          length = this.length;\n          offset = 0;\n          // Buffer#write(string, encoding)\n        } else if (length === undefined && typeof offset === 'string') {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n          // Buffer#write(string, offset[, length][, encoding])\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === undefined) encoding = 'utf8';\n          } else {\n            encoding = length;\n            length = undefined;\n          }\n        } else {\n          throw new Error(\n          'Buffer.write(string, encoding, offset[, length]) is no longer supported');\n\n        }\n\n        var remaining = this.length - offset;\n        if (length === undefined || length > remaining) length = remaining;\n\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError('Attempt to write outside buffer bounds');\n        }\n\n        if (!encoding) encoding = 'utf8';\n\n        var loweredCase = false;\n        for (;;) {\n          switch (encoding) {\n            case 'hex':\n              return hexWrite(this, string, offset, length);\n\n            case 'utf8':\n            case 'utf-8':\n              return utf8Write(this, string, offset, length);\n\n            case 'ascii':\n              return asciiWrite(this, string, offset, length);\n\n            case 'latin1':\n            case 'binary':\n              return latin1Write(this, string, offset, length);\n\n            case 'base64':\n              // Warning: maxLength not taken into account in base64Write\n              return base64Write(this, string, offset, length);\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return ucs2Write(this, string, offset, length);\n\n            default:\n              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n              encoding = ('' + encoding).toLowerCase();\n              loweredCase = true;}\n\n        }\n      };\n\n      Buffer.prototype.toJSON = function toJSON() {\n        return {\n          type: 'Buffer',\n          data: Array.prototype.slice.call(this._arr || this, 0) };\n\n      };\n\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        var res = [];\n\n        var i = start;\n        while (i < end) {\n          var firstByte = buf[i];\n          var codePoint = null;\n          var bytesPerSequence = firstByte > 0xEF ? 4 :\n          firstByte > 0xDF ? 3 :\n          firstByte > 0xBF ? 2 :\n          1;\n\n          if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 0x80) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 0xC0) === 0x80) {\n                  tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                  if (tempCodePoint > 0x7F) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                  tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                  if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                  tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                  if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                    codePoint = tempCodePoint;\n                  }\n                }}\n\n          }\n\n          if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n          } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n          }\n\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n\n        return decodeCodePointsArray(res);\n      }\n\n      // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n      // the lowest limit is Chrome, with 0x10000 args.\n      // We go 1 magnitude less, for safety\n      var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n      function decodeCodePointsArray(codePoints) {\n        var len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n        }\n\n        // Decode in chunks to avoid \"call stack size exceeded\".\n        var res = '';\n        var i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n          String,\n          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n\n        }\n        return res;\n      }\n\n      function asciiSlice(buf, start, end) {\n        var ret = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 0x7F);\n        }\n        return ret;\n      }\n\n      function latin1Slice(buf, start, end) {\n        var ret = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n\n      function hexSlice(buf, start, end) {\n        var len = buf.length;\n\n        if (!start || start < 0) start = 0;\n        if (!end || end < 0 || end > len) end = len;\n\n        var out = '';\n        for (var i = start; i < end; ++i) {\n          out += toHex(buf[i]);\n        }\n        return out;\n      }\n\n      function utf16leSlice(buf, start, end) {\n        var bytes = buf.slice(start, end);\n        var res = '';\n        for (var i = 0; i < bytes.length; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n\n      Buffer.prototype.slice = function slice(start, end) {\n        var len = this.length;\n        start = ~~start;\n        end = end === undefined ? len : ~~end;\n\n        if (start < 0) {\n          start += len;\n          if (start < 0) start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n\n        if (end < 0) {\n          end += len;\n          if (end < 0) end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n\n        if (end < start) end = start;\n\n        var newBuf = this.subarray(start, end);\n        // Return an augmented `Uint8Array` instance\n        newBuf.__proto__ = Buffer.prototype;\n        return newBuf;\n      };\n\n      /*\n          * Need to make sure that buffer isn't trying to write out of bounds.\n          */\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n        if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n      }\n\n      Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n        var val = this[offset];\n        var mul = 1;\n        var i = 0;\n        while (++i < byteLength && (mul *= 0x100)) {\n          val += this[offset + i] * mul;\n        }\n\n        return val;\n      };\n\n      Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength, this.length);\n        }\n\n        var val = this[offset + --byteLength];\n        var mul = 1;\n        while (byteLength > 0 && (mul *= 0x100)) {\n          val += this[offset + --byteLength] * mul;\n        }\n\n        return val;\n      };\n\n      Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n\n      Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n\n      Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n\n      Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 4, this.length);\n\n        return (this[offset] |\n        this[offset + 1] << 8 |\n        this[offset + 2] << 16) +\n        this[offset + 3] * 0x1000000;\n      };\n\n      Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 4, this.length);\n\n        return this[offset] * 0x1000000 + (\n        this[offset + 1] << 16 |\n        this[offset + 2] << 8 |\n        this[offset + 3]);\n      };\n\n      Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n        var val = this[offset];\n        var mul = 1;\n        var i = 0;\n        while (++i < byteLength && (mul *= 0x100)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 0x80;\n\n        if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n        return val;\n      };\n\n      Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n        var i = byteLength;\n        var mul = 1;\n        var val = this[offset + --i];\n        while (i > 0 && (mul *= 0x100)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 0x80;\n\n        if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n        return val;\n      };\n\n      Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 0x80)) return this[offset];\n        return (0xff - this[offset] + 1) * -1;\n      };\n\n      Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 2, this.length);\n        var val = this[offset] | this[offset + 1] << 8;\n        return val & 0x8000 ? val | 0xFFFF0000 : val;\n      };\n\n      Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 2, this.length);\n        var val = this[offset + 1] | this[offset] << 8;\n        return val & 0x8000 ? val | 0xFFFF0000 : val;\n      };\n\n      Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 4, this.length);\n\n        return this[offset] |\n        this[offset + 1] << 8 |\n        this[offset + 2] << 16 |\n        this[offset + 3] << 24;\n      };\n\n      Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 4, this.length);\n\n        return this[offset] << 24 |\n        this[offset + 1] << 16 |\n        this[offset + 2] << 8 |\n        this[offset + 3];\n      };\n\n      Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n\n      Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n\n      Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n\n      Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length) throw new RangeError('Index out of range');\n      }\n\n      Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) {\n          var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n          checkInt(this, value, offset, byteLength, maxBytes, 0);\n        }\n\n        var mul = 1;\n        var i = 0;\n        this[offset] = value & 0xFF;\n        while (++i < byteLength && (mul *= 0x100)) {\n          this[offset + i] = value / mul & 0xFF;\n        }\n\n        return offset + byteLength;\n      };\n\n      Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) {\n          var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n          checkInt(this, value, offset, byteLength, maxBytes, 0);\n        }\n\n        var i = byteLength - 1;\n        var mul = 1;\n        this[offset + i] = value & 0xFF;\n        while (--i >= 0 && (mul *= 0x100)) {\n          this[offset + i] = value / mul & 0xFF;\n        }\n\n        return offset + byteLength;\n      };\n\n      Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n        this[offset] = value & 0xff;\n        return offset + 1;\n      };\n\n      Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n\n      Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n        return offset + 2;\n      };\n\n      Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 0xff;\n        return offset + 4;\n      };\n\n      Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n        return offset + 4;\n      };\n\n      Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          var limit = Math.pow(2, 8 * byteLength - 1);\n\n          checkInt(this, value, offset, byteLength, limit - 1, -limit);\n        }\n\n        var i = 0;\n        var mul = 1;\n        var sub = 0;\n        this[offset] = value & 0xFF;\n        while (++i < byteLength && (mul *= 0x100)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n        }\n\n        return offset + byteLength;\n      };\n\n      Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          var limit = Math.pow(2, 8 * byteLength - 1);\n\n          checkInt(this, value, offset, byteLength, limit - 1, -limit);\n        }\n\n        var i = byteLength - 1;\n        var mul = 1;\n        var sub = 0;\n        this[offset + i] = value & 0xFF;\n        while (--i >= 0 && (mul *= 0x100)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n        }\n\n        return offset + byteLength;\n      };\n\n      Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n        if (value < 0) value = 0xff + value + 1;\n        this[offset] = value & 0xff;\n        return offset + 1;\n      };\n\n      Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n\n      Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n        return offset + 2;\n      };\n\n      Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n\n      Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n        if (value < 0) value = 0xffffffff + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n        return offset + 4;\n      };\n\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length) throw new RangeError('Index out of range');\n        if (offset < 0) throw new RangeError('Index out of range');\n      }\n\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n\n      Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n\n      Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n\n      // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n      Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n        if (!start) start = 0;\n        if (!end && end !== 0) end = this.length;\n        if (targetStart >= target.length) targetStart = target.length;\n        if (!targetStart) targetStart = 0;\n        if (end > 0 && end < start) end = start;\n\n        // Copy 0 bytes; we're done\n        if (end === start) return 0;\n        if (target.length === 0 || this.length === 0) return 0;\n\n        // Fatal error conditions\n        if (targetStart < 0) {\n          throw new RangeError('targetStart out of bounds');\n        }\n        if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n        if (end < 0) throw new RangeError('sourceEnd out of bounds');\n\n        // Are we oob?\n        if (end > this.length) end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n\n        var len = end - start;\n\n        if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n          // Use built-in when available, missing from IE11\n          this.copyWithin(targetStart, start, end);\n        } else if (this === target && start < targetStart && targetStart < end) {\n          // descending copy from end\n          for (var i = len - 1; i >= 0; --i) {\n            target[i + targetStart] = this[i + start];\n          }\n        } else {\n          Uint8Array.prototype.set.call(\n          target,\n          this.subarray(start, end),\n          targetStart);\n\n        }\n\n        return len;\n      };\n\n      // Usage:\n      //    buffer.fill(number[, offset[, end]])\n      //    buffer.fill(buffer[, offset[, end]])\n      //    buffer.fill(string[, offset[, end]][, encoding])\n      Buffer.prototype.fill = function fill(val, start, end, encoding) {\n        // Handle string cases:\n        if (typeof val === 'string') {\n          if (typeof start === 'string') {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === 'string') {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== undefined && typeof encoding !== 'string') {\n            throw new TypeError('encoding must be a string');\n          }\n          if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n            throw new TypeError('Unknown encoding: ' + encoding);\n          }\n          if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (encoding === 'utf8' && code < 128 ||\n            encoding === 'latin1') {\n              // Fast path: If `val` fits into a single byte, use that numeric value.\n              val = code;\n            }\n          }\n        } else if (typeof val === 'number') {\n          val = val & 255;\n        }\n\n        // Invalid ranges are not set to a default, so can range check early.\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError('Out of range index');\n        }\n\n        if (end <= start) {\n          return this;\n        }\n\n        start = start >>> 0;\n        end = end === undefined ? this.length : end >>> 0;\n\n        if (!val) val = 0;\n\n        var i;\n        if (typeof val === 'number') {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          var bytes = Buffer.isBuffer(val) ?\n          val :\n          Buffer.from(val, encoding);\n          var len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val +\n            '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n\n        return this;\n      };\n\n      // HELPER FUNCTIONS\n      // ================\n\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\n      function base64clean(str) {\n        // Node takes equal signs as end of the Base64 encoding\n        str = str.split('=')[0];\n        // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n        str = str.trim().replace(INVALID_BASE64_RE, '');\n        // Node converts strings with length < 2 to ''\n        if (str.length < 2) return '';\n        // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n        while (str.length % 4 !== 0) {\n          str = str + '=';\n        }\n        return str;\n      }\n\n      function toHex(n) {\n        if (n < 16) return '0' + n.toString(16);\n        return n.toString(16);\n      }\n\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        var codePoint;\n        var length = string.length;\n        var leadSurrogate = null;\n        var bytes = [];\n\n        for (var i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n\n          // is surrogate component\n          if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n              // no lead yet\n              if (codePoint > 0xDBFF) {\n                // unexpected trail\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                continue;\n              } else if (i + 1 === length) {\n                // unpaired lead\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                continue;\n              }\n\n              // valid lead\n              leadSurrogate = codePoint;\n\n              continue;\n            }\n\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n              leadSurrogate = codePoint;\n              continue;\n            }\n\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n          } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          }\n\n          leadSurrogate = null;\n\n          // encode utf8\n          if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n          } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(\n            codePoint >> 0x6 | 0xC0,\n            codePoint & 0x3F | 0x80);\n\n          } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(\n            codePoint >> 0xC | 0xE0,\n            codePoint >> 0x6 & 0x3F | 0x80,\n            codePoint & 0x3F | 0x80);\n\n          } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(\n            codePoint >> 0x12 | 0xF0,\n            codePoint >> 0xC & 0x3F | 0x80,\n            codePoint >> 0x6 & 0x3F | 0x80,\n            codePoint & 0x3F | 0x80);\n\n          } else {\n            throw new Error('Invalid code point');\n          }\n        }\n\n        return bytes;\n      }\n\n      function asciiToBytes(str) {\n        var byteArray = [];\n        for (var i = 0; i < str.length; ++i) {\n          // Node's code seems to be doing this and not & 0x7F..\n          byteArray.push(str.charCodeAt(i) & 0xFF);\n        }\n        return byteArray;\n      }\n\n      function utf16leToBytes(str, units) {\n        var c, hi, lo;\n        var byteArray = [];\n        for (var i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0) break;\n\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n\n        return byteArray;\n      }\n\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n\n      function blitBuffer(src, dst, offset, length) {\n        for (var i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length) break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n\n      // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n      // the `instanceof` check but they should be treated as of that type.\n      // See: https://github.com/feross/buffer/issues/166\n      function isInstance(obj, type) {\n        return obj instanceof type ||\n        obj != null && obj.constructor != null && obj.constructor.name != null &&\n        obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        // For IE11 support\n        return obj !== obj; // eslint-disable-line no-self-compare\n      }\n\n    }, { \"base64-js\": 10, \"ieee754\": 79 }], 13: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      var objectCreate = Object.create || objectCreatePolyfill;\n      var objectKeys = Object.keys || objectKeysPolyfill;\n      var bind = Function.prototype.bind || functionBindPolyfill;\n\n      function EventEmitter() {\n        if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        }\n\n        this._maxListeners = this._maxListeners || undefined;\n      }\n      module.exports = EventEmitter;\n\n      // Backwards-compat with node 0.10.x\n      EventEmitter.EventEmitter = EventEmitter;\n\n      EventEmitter.prototype._events = undefined;\n      EventEmitter.prototype._maxListeners = undefined;\n\n      // By default EventEmitters will print a warning if more than 10 listeners are\n      // added to it. This is a useful default which helps finding memory leaks.\n      var defaultMaxListeners = 10;\n\n      var hasDefineProperty;\n      try {\n        var o = {};\n        if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });\n        hasDefineProperty = o.x === 0;\n      } catch (err) {hasDefineProperty = false;}\n      if (hasDefineProperty) {\n        Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n          enumerable: true,\n          get: function get() {\n            return defaultMaxListeners;\n          },\n          set: function set(arg) {\n            // check whether the input is a positive number (whose value is zero or\n            // greater and not a NaN).\n            if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n            throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n            defaultMaxListeners = arg;\n          } });\n\n      } else {\n        EventEmitter.defaultMaxListeners = defaultMaxListeners;\n      }\n\n      // Obviously not all Emitters should be limited to 10. This function allows\n      // that to be increased. Set to zero for unlimited.\n      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n        if (typeof n !== 'number' || n < 0 || isNaN(n))\n        throw new TypeError('\"n\" argument must be a positive number');\n        this._maxListeners = n;\n        return this;\n      };\n\n      function $getMaxListeners(that) {\n        if (that._maxListeners === undefined)\n        return EventEmitter.defaultMaxListeners;\n        return that._maxListeners;\n      }\n\n      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n        return $getMaxListeners(this);\n      };\n\n      // These standalone emit* functions are used to optimize calling of event\n      // handlers for fast cases because emit() itself often has a variable number of\n      // arguments and can be deoptimized because of that. These functions always have\n      // the same number of arguments and thus do not get deoptimized, so the code\n      // inside them can execute faster.\n      function emitNone(handler, isFn, self) {\n        if (isFn)\n        handler.call(self);else\n        {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].call(self);}\n        }\n      }\n      function emitOne(handler, isFn, self, arg1) {\n        if (isFn)\n        handler.call(self, arg1);else\n        {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].call(self, arg1);}\n        }\n      }\n      function emitTwo(handler, isFn, self, arg1, arg2) {\n        if (isFn)\n        handler.call(self, arg1, arg2);else\n        {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].call(self, arg1, arg2);}\n        }\n      }\n      function emitThree(handler, isFn, self, arg1, arg2, arg3) {\n        if (isFn)\n        handler.call(self, arg1, arg2, arg3);else\n        {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].call(self, arg1, arg2, arg3);}\n        }\n      }\n\n      function emitMany(handler, isFn, self, args) {\n        if (isFn)\n        handler.apply(self, args);else\n        {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].apply(self, args);}\n        }\n      }\n\n      EventEmitter.prototype.emit = function emit(type) {\n        var er, handler, len, args, i, events;\n        var doError = type === 'error';\n\n        events = this._events;\n        if (events)\n        doError = doError && events.error == null;else\n        if (!doError)\n        return false;\n\n        // If there is no 'error' event listener then throw.\n        if (doError) {\n          if (arguments.length > 1)\n          er = arguments[1];\n          if (er instanceof Error) {\n            throw er; // Unhandled 'error' event\n          } else {\n            // At least give some kind of context to the user\n            var err = new Error('Unhandled \"error\" event. (' + er + ')');\n            err.context = er;\n            throw err;\n          }\n          return false;\n        }\n\n        handler = events[type];\n\n        if (!handler)\n        return false;\n\n        var isFn = typeof handler === 'function';\n        len = arguments.length;\n        switch (len) {\n          // fast cases\n          case 1:\n            emitNone(handler, isFn, this);\n            break;\n          case 2:\n            emitOne(handler, isFn, this, arguments[1]);\n            break;\n          case 3:\n            emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n            break;\n          case 4:\n            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n            break;\n          // slower\n          default:\n            args = new Array(len - 1);\n            for (i = 1; i < len; i++) {\n              args[i - 1] = arguments[i];}\n            emitMany(handler, isFn, this, args);}\n\n\n        return true;\n      };\n\n      function _addListener(target, type, listener, prepend) {\n        var m;\n        var events;\n        var existing;\n\n        if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n        events = target._events;\n        if (!events) {\n          events = target._events = objectCreate(null);\n          target._eventsCount = 0;\n        } else {\n          // To avoid recursion in the case that type === \"newListener\"! Before\n          // adding it to the listeners, first emit \"newListener\".\n          if (events.newListener) {\n            target.emit('newListener', type,\n            listener.listener ? listener.listener : listener);\n\n            // Re-assign `events` because a newListener handler could have caused the\n            // this._events to be assigned to a new object\n            events = target._events;\n          }\n          existing = events[type];\n        }\n\n        if (!existing) {\n          // Optimize the case of one listener. Don't need the extra array object.\n          existing = events[type] = listener;\n          ++target._eventsCount;\n        } else {\n          if (typeof existing === 'function') {\n            // Adding the second element, need to change to array.\n            existing = events[type] =\n            prepend ? [listener, existing] : [existing, listener];\n          } else {\n            // If we've already got an array, just append.\n            if (prepend) {\n              existing.unshift(listener);\n            } else {\n              existing.push(listener);\n            }\n          }\n\n          // Check for listener leak\n          if (!existing.warned) {\n            m = $getMaxListeners(target);\n            if (m && m > 0 && existing.length > m) {\n              existing.warned = true;\n              var w = new Error('Possible EventEmitter memory leak detected. ' +\n              existing.length + ' \"' + String(type) + '\" listeners ' +\n              'added. Use emitter.setMaxListeners() to ' +\n              'increase limit.');\n              w.name = 'MaxListenersExceededWarning';\n              w.emitter = target;\n              w.type = type;\n              w.count = existing.length;\n              if (typeof console === 'object' && console.warn) {\n                __f__(\"warn\", '%s: %s', w.name, w.message, \" at utils/mqtt.js:4451\");\n              }\n            }\n          }\n        }\n\n        return target;\n      }\n\n      EventEmitter.prototype.addListener = function addListener(type, listener) {\n        return _addListener(this, type, listener, false);\n      };\n\n      EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n      EventEmitter.prototype.prependListener =\n      function prependListener(type, listener) {\n        return _addListener(this, type, listener, true);\n      };\n\n      function onceWrapper() {\n        if (!this.fired) {\n          this.target.removeListener(this.type, this.wrapFn);\n          this.fired = true;\n          switch (arguments.length) {\n            case 0:\n              return this.listener.call(this.target);\n            case 1:\n              return this.listener.call(this.target, arguments[0]);\n            case 2:\n              return this.listener.call(this.target, arguments[0], arguments[1]);\n            case 3:\n              return this.listener.call(this.target, arguments[0], arguments[1],\n              arguments[2]);\n            default:\n              var args = new Array(arguments.length);\n              for (var i = 0; i < args.length; ++i) {\n                args[i] = arguments[i];}\n              this.listener.apply(this.target, args);}\n\n        }\n      }\n\n      function _onceWrap(target, type, listener) {\n        var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n        var wrapped = bind.call(onceWrapper, state);\n        wrapped.listener = listener;\n        state.wrapFn = wrapped;\n        return wrapped;\n      }\n\n      EventEmitter.prototype.once = function once(type, listener) {\n        if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n        this.on(type, _onceWrap(this, type, listener));\n        return this;\n      };\n\n      EventEmitter.prototype.prependOnceListener =\n      function prependOnceListener(type, listener) {\n        if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n        this.prependListener(type, _onceWrap(this, type, listener));\n        return this;\n      };\n\n      // Emits a 'removeListener' event if and only if the listener was removed.\n      EventEmitter.prototype.removeListener =\n      function removeListener(type, listener) {\n        var list, events, position, i, originalListener;\n\n        if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n        events = this._events;\n        if (!events)\n        return this;\n\n        list = events[type];\n        if (!list)\n        return this;\n\n        if (list === listener || list.listener === listener) {\n          if (--this._eventsCount === 0)\n          this._events = objectCreate(null);else\n          {\n            delete events[type];\n            if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n          }\n        } else if (typeof list !== 'function') {\n          position = -1;\n\n          for (i = list.length - 1; i >= 0; i--) {\n            if (list[i] === listener || list[i].listener === listener) {\n              originalListener = list[i].listener;\n              position = i;\n              break;\n            }\n          }\n\n          if (position < 0)\n          return this;\n\n          if (position === 0)\n          list.shift();else\n\n          spliceOne(list, position);\n\n          if (list.length === 1)\n          events[type] = list[0];\n\n          if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n        }\n\n        return this;\n      };\n\n      EventEmitter.prototype.removeAllListeners =\n      function removeAllListeners(type) {\n        var listeners, events, i;\n\n        events = this._events;\n        if (!events)\n        return this;\n\n        // not listening for removeListener, no need to emit\n        if (!events.removeListener) {\n          if (arguments.length === 0) {\n            this._events = objectCreate(null);\n            this._eventsCount = 0;\n          } else if (events[type]) {\n            if (--this._eventsCount === 0)\n            this._events = objectCreate(null);else\n\n            delete events[type];\n          }\n          return this;\n        }\n\n        // emit removeListener for all listeners on all events\n        if (arguments.length === 0) {\n          var keys = objectKeys(events);\n          var key;\n          for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n            if (key === 'removeListener') continue;\n            this.removeAllListeners(key);\n          }\n          this.removeAllListeners('removeListener');\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n          return this;\n        }\n\n        listeners = events[type];\n\n        if (typeof listeners === 'function') {\n          this.removeListener(type, listeners);\n        } else if (listeners) {\n          // LIFO order\n          for (i = listeners.length - 1; i >= 0; i--) {\n            this.removeListener(type, listeners[i]);\n          }\n        }\n\n        return this;\n      };\n\n      function _listeners(target, type, unwrap) {\n        var events = target._events;\n\n        if (!events)\n        return [];\n\n        var evlistener = events[type];\n        if (!evlistener)\n        return [];\n\n        if (typeof evlistener === 'function')\n        return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n      }\n\n      EventEmitter.prototype.listeners = function listeners(type) {\n        return _listeners(this, type, true);\n      };\n\n      EventEmitter.prototype.rawListeners = function rawListeners(type) {\n        return _listeners(this, type, false);\n      };\n\n      EventEmitter.listenerCount = function (emitter, type) {\n        if (typeof emitter.listenerCount === 'function') {\n          return emitter.listenerCount(type);\n        } else {\n          return listenerCount.call(emitter, type);\n        }\n      };\n\n      EventEmitter.prototype.listenerCount = listenerCount;\n      function listenerCount(type) {\n        var events = this._events;\n\n        if (events) {\n          var evlistener = events[type];\n\n          if (typeof evlistener === 'function') {\n            return 1;\n          } else if (evlistener) {\n            return evlistener.length;\n          }\n        }\n\n        return 0;\n      }\n\n      EventEmitter.prototype.eventNames = function eventNames() {\n        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n      };\n\n      // About 1.5x faster than the two-arg version of Array#splice().\n      function spliceOne(list, index) {\n        for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n          list[i] = list[k];}\n        list.pop();\n      }\n\n      function arrayClone(arr, n) {\n        var copy = new Array(n);\n        for (var i = 0; i < n; ++i) {\n          copy[i] = arr[i];}\n        return copy;\n      }\n\n      function unwrapListeners(arr) {\n        var ret = new Array(arr.length);\n        for (var i = 0; i < ret.length; ++i) {\n          ret[i] = arr[i].listener || arr[i];\n        }\n        return ret;\n      }\n\n      function objectCreatePolyfill(proto) {\n        var F = function F() {};\n        F.prototype = proto;\n        return new F();\n      }\n      function objectKeysPolyfill(obj) {\n        var keys = [];\n        for (var k in obj) {if (Object.prototype.hasOwnProperty.call(obj, k)) {\n            keys.push(k);\n          }}\n        return k;\n      }\n      function functionBindPolyfill(context) {\n        var fn = this;\n        return function () {\n          return fn.apply(context, arguments);\n        };\n      }\n\n    }, {}], 14: [function (require, module, exports) {\n      (function (Buffer) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        // NOTE: These type checking functions intentionally don't use `instanceof`\n        // because it is fragile and can be easily faked with `Object.create()`.\n\n        function isArray(arg) {\n          if (Array.isArray) {\n            return Array.isArray(arg);\n          }\n          return objectToString(arg) === '[object Array]';\n        }\n        exports.isArray = isArray;\n\n        function isBoolean(arg) {\n          return typeof arg === 'boolean';\n        }\n        exports.isBoolean = isBoolean;\n\n        function isNull(arg) {\n          return arg === null;\n        }\n        exports.isNull = isNull;\n\n        function isNullOrUndefined(arg) {\n          return arg == null;\n        }\n        exports.isNullOrUndefined = isNullOrUndefined;\n\n        function isNumber(arg) {\n          return typeof arg === 'number';\n        }\n        exports.isNumber = isNumber;\n\n        function isString(arg) {\n          return typeof arg === 'string';\n        }\n        exports.isString = isString;\n\n        function isSymbol(arg) {\n          return typeof arg === 'symbol';\n        }\n        exports.isSymbol = isSymbol;\n\n        function isUndefined(arg) {\n          return arg === void 0;\n        }\n        exports.isUndefined = isUndefined;\n\n        function isRegExp(re) {\n          return objectToString(re) === '[object RegExp]';\n        }\n        exports.isRegExp = isRegExp;\n\n        function isObject(arg) {\n          return typeof arg === 'object' && arg !== null;\n        }\n        exports.isObject = isObject;\n\n        function isDate(d) {\n          return objectToString(d) === '[object Date]';\n        }\n        exports.isDate = isDate;\n\n        function isError(e) {\n          return objectToString(e) === '[object Error]' || e instanceof Error;\n        }\n        exports.isError = isError;\n\n        function isFunction(arg) {\n          return typeof arg === 'function';\n        }\n        exports.isFunction = isFunction;\n\n        function isPrimitive(arg) {\n          return arg === null ||\n          typeof arg === 'boolean' ||\n          typeof arg === 'number' ||\n          typeof arg === 'string' ||\n          typeof arg === 'symbol' || // ES6 symbol\n          typeof arg === 'undefined';\n        }\n        exports.isPrimitive = isPrimitive;\n\n        exports.isBuffer = Buffer.isBuffer;\n\n        function objectToString(o) {\n          return Object.prototype.toString.call(o);\n        }\n\n      }).call(this, { \"isBuffer\": require(\"../../is-buffer/index.js\") });\n    }, { \"../../is-buffer/index.js\": 81 }], 15: [function (require, module, exports) {\n      'use strict';\n\n      var copy = require('es5-ext/object/copy'),\n      normalizeOptions = require('es5-ext/object/normalize-options'),\n      ensureCallable = require('es5-ext/object/valid-callable'),\n      map = require('es5-ext/object/map'),\n      callable = require('es5-ext/object/valid-callable'),\n      validValue = require('es5-ext/object/valid-value'),\n\n      bind = Function.prototype.bind,defineProperty = Object.defineProperty,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      define;\n\n      define = function define(name, desc, options) {\n        var value = validValue(desc) && callable(desc.value),dgs;\n        dgs = copy(desc);\n        delete dgs.writable;\n        delete dgs.value;\n        dgs.get = function () {\n          if (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;\n          desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);\n          defineProperty(this, name, desc);\n          return this[name];\n        };\n        return dgs;\n      };\n\n      module.exports = function (props /*, options*/) {\n        var options = normalizeOptions(arguments[1]);\n        if (options.resolveContext != null) ensureCallable(options.resolveContext);\n        return map(props, function (desc, name) {return define(name, desc, options);});\n      };\n\n    }, { \"es5-ext/object/copy\": 39, \"es5-ext/object/map\": 48, \"es5-ext/object/normalize-options\": 49, \"es5-ext/object/valid-callable\": 54, \"es5-ext/object/valid-value\": 55 }], 16: [function (require, module, exports) {\n      'use strict';\n\n      var assign = require('es5-ext/object/assign'),\n      normalizeOpts = require('es5-ext/object/normalize-options'),\n      isCallable = require('es5-ext/object/is-callable'),\n      contains = require('es5-ext/string/#/contains'),\n\n      d;\n\n      d = module.exports = function (dscr, value /*, options*/) {\n        var c, e, w, options, desc;\n        if (arguments.length < 2 || typeof dscr !== 'string') {\n          options = value;\n          value = dscr;\n          dscr = null;\n        } else {\n          options = arguments[2];\n        }\n        if (dscr == null) {\n          c = w = true;\n          e = false;\n        } else {\n          c = contains.call(dscr, 'c');\n          e = contains.call(dscr, 'e');\n          w = contains.call(dscr, 'w');\n        }\n\n        desc = { value: value, configurable: c, enumerable: e, writable: w };\n        return !options ? desc : assign(normalizeOpts(options), desc);\n      };\n\n      d.gs = function (dscr, get, set /*, options*/) {\n        var c, e, options, desc;\n        if (typeof dscr !== 'string') {\n          options = set;\n          set = get;\n          get = dscr;\n          dscr = null;\n        } else {\n          options = arguments[3];\n        }\n        if (get == null) {\n          get = undefined;\n        } else if (!isCallable(get)) {\n          options = get;\n          get = set = undefined;\n        } else if (set == null) {\n          set = undefined;\n        } else if (!isCallable(set)) {\n          options = set;\n          set = undefined;\n        }\n        if (dscr == null) {\n          c = true;\n          e = false;\n        } else {\n          c = contains.call(dscr, 'c');\n          e = contains.call(dscr, 'e');\n        }\n\n        desc = { get: get, set: set, configurable: c, enumerable: e };\n        return !options ? desc : assign(normalizeOpts(options), desc);\n      };\n\n    }, { \"es5-ext/object/assign\": 36, \"es5-ext/object/is-callable\": 42, \"es5-ext/object/normalize-options\": 49, \"es5-ext/string/#/contains\": 56 }], 17: [function (require, module, exports) {\n      (function (process, Buffer) {\n        var stream = require('readable-stream');\n        var eos = require('end-of-stream');\n        var inherits = require('inherits');\n        var shift = require('stream-shift');\n\n        var SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ?\n        Buffer.from([0]) :\n        new Buffer([0]);\n\n        var onuncork = function onuncork(self, fn) {\n          if (self._corked) self.once('uncork', fn);else\n          fn();\n        };\n\n        var autoDestroy = function autoDestroy(self, err) {\n          if (self._autoDestroy) self.destroy(err);\n        };\n\n        var destroyer = function destroyer(self, end) {\n          return function (err) {\n            if (err) autoDestroy(self, err.message === 'premature close' ? null : err);else\n            if (end && !self._ended) self.end();\n          };\n        };\n\n        var end = function end(ws, fn) {\n          if (!ws) return fn();\n          if (ws._writableState && ws._writableState.finished) return fn();\n          if (ws._writableState) return ws.end(fn);\n          ws.end();\n          fn();\n        };\n\n        var toStreams2 = function toStreams2(rs) {\n          return new stream.Readable({ objectMode: true, highWaterMark: 16 }).wrap(rs);\n        };\n\n        var Duplexify = function Duplexify(writable, readable, opts) {\n          if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts);\n          stream.Duplex.call(this, opts);\n\n          this._writable = null;\n          this._readable = null;\n          this._readable2 = null;\n\n          this._autoDestroy = !opts || opts.autoDestroy !== false;\n          this._forwardDestroy = !opts || opts.destroy !== false;\n          this._forwardEnd = !opts || opts.end !== false;\n          this._corked = 1; // start corked\n          this._ondrain = null;\n          this._drained = false;\n          this._forwarding = false;\n          this._unwrite = null;\n          this._unread = null;\n          this._ended = false;\n\n          this.destroyed = false;\n\n          if (writable) this.setWritable(writable);\n          if (readable) this.setReadable(readable);\n        };\n\n        inherits(Duplexify, stream.Duplex);\n\n        Duplexify.obj = function (writable, readable, opts) {\n          if (!opts) opts = {};\n          opts.objectMode = true;\n          opts.highWaterMark = 16;\n          return new Duplexify(writable, readable, opts);\n        };\n\n        Duplexify.prototype.cork = function () {\n          if (++this._corked === 1) this.emit('cork');\n        };\n\n        Duplexify.prototype.uncork = function () {\n          if (this._corked && --this._corked === 0) this.emit('uncork');\n        };\n\n        Duplexify.prototype.setWritable = function (writable) {\n          if (this._unwrite) this._unwrite();\n\n          if (this.destroyed) {\n            if (writable && writable.destroy) writable.destroy();\n            return;\n          }\n\n          if (writable === null || writable === false) {\n            this.end();\n            return;\n          }\n\n          var self = this;\n          var unend = eos(writable, { writable: true, readable: false }, destroyer(this, this._forwardEnd));\n\n          var ondrain = function ondrain() {\n            var ondrain = self._ondrain;\n            self._ondrain = null;\n            if (ondrain) ondrain();\n          };\n\n          var clear = function clear() {\n            self._writable.removeListener('drain', ondrain);\n            unend();\n          };\n\n          if (this._unwrite) process.nextTick(ondrain); // force a drain on stream reset to avoid livelocks\n\n          this._writable = writable;\n          this._writable.on('drain', ondrain);\n          this._unwrite = clear;\n\n          this.uncork(); // always uncork setWritable\n        };\n\n        Duplexify.prototype.setReadable = function (readable) {\n          if (this._unread) this._unread();\n\n          if (this.destroyed) {\n            if (readable && readable.destroy) readable.destroy();\n            return;\n          }\n\n          if (readable === null || readable === false) {\n            this.push(null);\n            this.resume();\n            return;\n          }\n\n          var self = this;\n          var unend = eos(readable, { writable: false, readable: true }, destroyer(this));\n\n          var onreadable = function onreadable() {\n            self._forward();\n          };\n\n          var onend = function onend() {\n            self.push(null);\n          };\n\n          var clear = function clear() {\n            self._readable2.removeListener('readable', onreadable);\n            self._readable2.removeListener('end', onend);\n            unend();\n          };\n\n          this._drained = true;\n          this._readable = readable;\n          this._readable2 = readable._readableState ? readable : toStreams2(readable);\n          this._readable2.on('readable', onreadable);\n          this._readable2.on('end', onend);\n          this._unread = clear;\n\n          this._forward();\n        };\n\n        Duplexify.prototype._read = function () {\n          this._drained = true;\n          this._forward();\n        };\n\n        Duplexify.prototype._forward = function () {\n          if (this._forwarding || !this._readable2 || !this._drained) return;\n          this._forwarding = true;\n\n          var data;\n\n          while (this._drained && (data = shift(this._readable2)) !== null) {\n            if (this.destroyed) continue;\n            this._drained = this.push(data);\n          }\n\n          this._forwarding = false;\n        };\n\n        Duplexify.prototype.destroy = function (err) {\n          if (this.destroyed) return;\n          this.destroyed = true;\n\n          var self = this;\n          process.nextTick(function () {\n            self._destroy(err);\n          });\n        };\n\n        Duplexify.prototype._destroy = function (err) {\n          if (err) {\n            var ondrain = this._ondrain;\n            this._ondrain = null;\n            if (ondrain) ondrain(err);else\n            this.emit('error', err);\n          }\n\n          if (this._forwardDestroy) {\n            if (this._readable && this._readable.destroy) this._readable.destroy();\n            if (this._writable && this._writable.destroy) this._writable.destroy();\n          }\n\n          this.emit('close');\n        };\n\n        Duplexify.prototype._write = function (data, enc, cb) {\n          if (this.destroyed) return cb();\n          if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb));\n          if (data === SIGNAL_FLUSH) return this._finish(cb);\n          if (!this._writable) return cb();\n\n          if (this._writable.write(data) === false) this._ondrain = cb;else\n          cb();\n        };\n\n        Duplexify.prototype._finish = function (cb) {\n          var self = this;\n          this.emit('preend');\n          onuncork(this, function () {\n            end(self._forwardEnd && self._writable, function () {\n              // haxx to not emit prefinish twice\n              if (self._writableState.prefinished === false) self._writableState.prefinished = true;\n              self.emit('prefinish');\n              onuncork(self, cb);\n            });\n          });\n        };\n\n        Duplexify.prototype.end = function (data, enc, cb) {\n          if (typeof data === 'function') return this.end(null, null, data);\n          if (typeof enc === 'function') return this.end(data, null, enc);\n          this._ended = true;\n          if (data) this.write(data);\n          if (!this._writableState.ending) this.write(SIGNAL_FLUSH);\n          return stream.Writable.prototype.end.call(this, cb);\n        };\n\n        module.exports = Duplexify;\n\n      }).call(this, require('_process'), require(\"buffer\").Buffer);\n    }, { \"_process\": 92, \"buffer\": 12, \"end-of-stream\": 18, \"inherits\": 80, \"readable-stream\": 108, \"stream-shift\": 111 }], 18: [function (require, module, exports) {\n      var once = require('once');\n\n      var noop = function noop() {};\n\n      var isRequest = function isRequest(stream) {\n        return stream.setHeader && typeof stream.abort === 'function';\n      };\n\n      var isChildProcess = function isChildProcess(stream) {\n        return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;\n      };\n\n      var eos = function eos(stream, opts, callback) {\n        if (typeof opts === 'function') return eos(stream, null, opts);\n        if (!opts) opts = {};\n\n        callback = once(callback || noop);\n\n        var ws = stream._writableState;\n        var rs = stream._readableState;\n        var readable = opts.readable || opts.readable !== false && stream.readable;\n        var writable = opts.writable || opts.writable !== false && stream.writable;\n\n        var onlegacyfinish = function onlegacyfinish() {\n          if (!stream.writable) onfinish();\n        };\n\n        var onfinish = function onfinish() {\n          writable = false;\n          if (!readable) callback.call(stream);\n        };\n\n        var onend = function onend() {\n          readable = false;\n          if (!writable) callback.call(stream);\n        };\n\n        var onexit = function onexit(exitCode) {\n          callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n        };\n\n        var onerror = function onerror(err) {\n          callback.call(stream, err);\n        };\n\n        var onclose = function onclose() {\n          if (readable && !(rs && rs.ended)) return callback.call(stream, new Error('premature close'));\n          if (writable && !(ws && ws.ended)) return callback.call(stream, new Error('premature close'));\n        };\n\n        var onrequest = function onrequest() {\n          stream.req.on('finish', onfinish);\n        };\n\n        if (isRequest(stream)) {\n          stream.on('complete', onfinish);\n          stream.on('abort', onclose);\n          if (stream.req) onrequest();else\n          stream.on('request', onrequest);\n        } else if (writable && !ws) {// legacy streams\n          stream.on('end', onlegacyfinish);\n          stream.on('close', onlegacyfinish);\n        }\n\n        if (isChildProcess(stream)) stream.on('exit', onexit);\n\n        stream.on('end', onend);\n        stream.on('finish', onfinish);\n        if (opts.error !== false) stream.on('error', onerror);\n        stream.on('close', onclose);\n\n        return function () {\n          stream.removeListener('complete', onfinish);\n          stream.removeListener('abort', onclose);\n          stream.removeListener('request', onrequest);\n          if (stream.req) stream.req.removeListener('finish', onfinish);\n          stream.removeListener('end', onlegacyfinish);\n          stream.removeListener('close', onlegacyfinish);\n          stream.removeListener('finish', onfinish);\n          stream.removeListener('exit', onexit);\n          stream.removeListener('end', onend);\n          stream.removeListener('error', onerror);\n          stream.removeListener('close', onclose);\n        };\n      };\n\n      module.exports = eos;\n\n    }, { \"once\": 90 }], 19: [function (require, module, exports) {\n      // Inspired by Google Closure:\n      // http://closure-library.googlecode.com/svn/docs/\n      // closure_goog_array_array.js.html#goog.array.clear\n\n      \"use strict\";\n\n      var value = require(\"../../object/valid-value\");\n\n      module.exports = function () {\n        value(this).length = 0;\n        return this;\n      };\n\n    }, { \"../../object/valid-value\": 55 }], 20: [function (require, module, exports) {\n      \"use strict\";\n\n      var numberIsNaN = require(\"../../number/is-nan\"),\n      toPosInt = require(\"../../number/to-pos-integer\"),\n      value = require(\"../../object/valid-value\"),\n      indexOf = Array.prototype.indexOf,\n      objHasOwnProperty = Object.prototype.hasOwnProperty,\n      abs = Math.abs,\n      floor = Math.floor;\n\n      module.exports = function (searchElement /*, fromIndex*/) {\n        var i, length, fromIndex, val;\n        if (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);\n\n        length = toPosInt(value(this).length);\n        fromIndex = arguments[1];\n        if (isNaN(fromIndex)) fromIndex = 0;else\n        if (fromIndex >= 0) fromIndex = floor(fromIndex);else\n        fromIndex = toPosInt(this.length) - floor(abs(fromIndex));\n\n        for (i = fromIndex; i < length; ++i) {\n          if (objHasOwnProperty.call(this, i)) {\n            val = this[i];\n            if (numberIsNaN(val)) return i; // Jslint: ignore\n          }\n        }\n        return -1;\n      };\n\n    }, { \"../../number/is-nan\": 30, \"../../number/to-pos-integer\": 34, \"../../object/valid-value\": 55 }], 21: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ?\n      Array.from :\n      require(\"./shim\");\n\n    }, { \"./is-implemented\": 22, \"./shim\": 23 }], 22: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var from = Array.from,arr,result;\n        if (typeof from !== \"function\") return false;\n        arr = [\"raz\", \"dwa\"];\n        result = from(arr);\n        return Boolean(result && result !== arr && result[1] === \"dwa\");\n      };\n\n    }, {}], 23: [function (require, module, exports) {\n      \"use strict\";\n\n      var iteratorSymbol = require(\"es6-symbol\").iterator,\n      isArguments = require(\"../../function/is-arguments\"),\n      isFunction = require(\"../../function/is-function\"),\n      toPosInt = require(\"../../number/to-pos-integer\"),\n      callable = require(\"../../object/valid-callable\"),\n      validValue = require(\"../../object/valid-value\"),\n      isValue = require(\"../../object/is-value\"),\n      isString = require(\"../../string/is-string\"),\n      isArray = Array.isArray,\n      call = Function.prototype.call,\n      desc = { configurable: true, enumerable: true, writable: true, value: null },\n      defineProperty = Object.defineProperty;\n\n      // eslint-disable-next-line complexity\n      module.exports = function (arrayLike /*, mapFn, thisArg*/) {\n        var mapFn = arguments[1],\n        thisArg = arguments[2],\n        Context,\n        i,\n        j,\n        arr,\n        length,\n        code,\n        iterator,\n        result,\n        getIterator,\n        value;\n\n        arrayLike = Object(validValue(arrayLike));\n\n        if (isValue(mapFn)) callable(mapFn);\n        if (!this || this === Array || !isFunction(this)) {\n          // Result: Plain array\n          if (!mapFn) {\n            if (isArguments(arrayLike)) {\n              // Source: Arguments\n              length = arrayLike.length;\n              if (length !== 1) return Array.apply(null, arrayLike);\n              arr = new Array(1);\n              arr[0] = arrayLike[0];\n              return arr;\n            }\n            if (isArray(arrayLike)) {\n              // Source: Array\n              arr = new Array(length = arrayLike.length);\n              for (i = 0; i < length; ++i) {arr[i] = arrayLike[i];}\n              return arr;\n            }\n          }\n          arr = [];\n        } else {\n          // Result: Non plain array\n          Context = this;\n        }\n\n        if (!isArray(arrayLike)) {\n          if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {\n            // Source: Iterator\n            iterator = callable(getIterator).call(arrayLike);\n            if (Context) arr = new Context();\n            result = iterator.next();\n            i = 0;\n            while (!result.done) {\n              value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;\n              if (Context) {\n                desc.value = value;\n                defineProperty(arr, i, desc);\n              } else {\n                arr[i] = value;\n              }\n              result = iterator.next();\n              ++i;\n            }\n            length = i;\n          } else if (isString(arrayLike)) {\n            // Source: String\n            length = arrayLike.length;\n            if (Context) arr = new Context();\n            for (i = 0, j = 0; i < length; ++i) {\n              value = arrayLike[i];\n              if (i + 1 < length) {\n                code = value.charCodeAt(0);\n                // eslint-disable-next-line max-depth\n                if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];\n              }\n              value = mapFn ? call.call(mapFn, thisArg, value, j) : value;\n              if (Context) {\n                desc.value = value;\n                defineProperty(arr, j, desc);\n              } else {\n                arr[j] = value;\n              }\n              ++j;\n            }\n            length = j;\n          }\n        }\n        if (length === undefined) {\n          // Source: array or array-like\n          length = toPosInt(arrayLike.length);\n          if (Context) arr = new Context(length);\n          for (i = 0; i < length; ++i) {\n            value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];\n            if (Context) {\n              desc.value = value;\n              defineProperty(arr, i, desc);\n            } else {\n              arr[i] = value;\n            }\n          }\n        }\n        if (Context) {\n          desc.value = null;\n          arr.length = length;\n        }\n        return arr;\n      };\n\n    }, { \"../../function/is-arguments\": 24, \"../../function/is-function\": 25, \"../../number/to-pos-integer\": 34, \"../../object/is-value\": 44, \"../../object/valid-callable\": 54, \"../../object/valid-value\": 55, \"../../string/is-string\": 59, \"es6-symbol\": 73 }], 24: [function (require, module, exports) {\n      \"use strict\";\n\n      var objToString = Object.prototype.toString,\n      id = objToString.call(\n      function () {\n        return arguments;\n      }());\n\n\n      module.exports = function (value) {\n        return objToString.call(value) === id;\n      };\n\n    }, {}], 25: [function (require, module, exports) {\n      \"use strict\";\n\n      var objToString = Object.prototype.toString,id = objToString.call(require(\"./noop\"));\n\n      module.exports = function (value) {\n        return typeof value === \"function\" && objToString.call(value) === id;\n      };\n\n    }, { \"./noop\": 26 }], 26: [function (require, module, exports) {\n      \"use strict\";\n\n      // eslint-disable-next-line no-empty-function\n      module.exports = function () {};\n\n    }, {}], 27: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ?\n      Math.sign :\n      require(\"./shim\");\n\n    }, { \"./is-implemented\": 28, \"./shim\": 29 }], 28: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var sign = Math.sign;\n        if (typeof sign !== \"function\") return false;\n        return sign(10) === 1 && sign(-20) === -1;\n      };\n\n    }, {}], 29: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (value) {\n        value = Number(value);\n        if (isNaN(value) || value === 0) return value;\n        return value > 0 ? 1 : -1;\n      };\n\n    }, {}], 30: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ?\n      Number.isNaN :\n      require(\"./shim\");\n\n    }, { \"./is-implemented\": 31, \"./shim\": 32 }], 31: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var numberIsNaN = Number.isNaN;\n        if (typeof numberIsNaN !== \"function\") return false;\n        return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);\n      };\n\n    }, {}], 32: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (value) {\n        // eslint-disable-next-line no-self-compare\n        return value !== value;\n      };\n\n    }, {}], 33: [function (require, module, exports) {\n      \"use strict\";\n\n      var sign = require(\"../math/sign\"),\n\n      abs = Math.abs,floor = Math.floor;\n\n      module.exports = function (value) {\n        if (isNaN(value)) return 0;\n        value = Number(value);\n        if (value === 0 || !isFinite(value)) return value;\n        return sign(value) * floor(abs(value));\n      };\n\n    }, { \"../math/sign\": 27 }], 34: [function (require, module, exports) {\n      \"use strict\";\n\n      var toInteger = require(\"./to-integer\"),\n\n      max = Math.max;\n\n      module.exports = function (value) {\n        return max(0, toInteger(value));\n      };\n\n    }, { \"./to-integer\": 33 }], 35: [function (require, module, exports) {\n      // Internal method, used by iteration functions.\n      // Calls a function for each key-value pair found in object\n      // Optionally takes compareFn to iterate object in specific order\n\n      \"use strict\";\n\n      var callable = require(\"./valid-callable\"),\n      value = require(\"./valid-value\"),\n      bind = Function.prototype.bind,\n      call = Function.prototype.call,\n      keys = Object.keys,\n      objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\n      module.exports = function (method, defVal) {\n        return function (obj, cb /*, thisArg, compareFn*/) {\n          var list,thisArg = arguments[2],compareFn = arguments[3];\n          obj = Object(value(obj));\n          callable(cb);\n\n          list = keys(obj);\n          if (compareFn) {\n            list.sort(typeof compareFn === \"function\" ? bind.call(compareFn, obj) : undefined);\n          }\n          if (typeof method !== \"function\") method = list[method];\n          return call.call(method, list, function (key, index) {\n            if (!objPropertyIsEnumerable.call(obj, key)) return defVal;\n            return call.call(cb, thisArg, obj[key], key, obj, index);\n          });\n        };\n      };\n\n    }, { \"./valid-callable\": 54, \"./valid-value\": 55 }], 36: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ?\n      Object.assign :\n      require(\"./shim\");\n\n    }, { \"./is-implemented\": 37, \"./shim\": 38 }], 37: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var assign = Object.assign,obj;\n        if (typeof assign !== \"function\") return false;\n        obj = { foo: \"raz\" };\n        assign(obj, { bar: \"dwa\" }, { trzy: \"trzy\" });\n        return obj.foo + obj.bar + obj.trzy === \"razdwatrzy\";\n      };\n\n    }, {}], 38: [function (require, module, exports) {\n      \"use strict\";\n\n      var keys = require(\"../keys\"),\n      value = require(\"../valid-value\"),\n      max = Math.max;\n\n      module.exports = function (dest, src /*, …srcn*/) {\n        var error,i,length = max(arguments.length, 2),assign;\n        dest = Object(value(dest));\n        assign = function assign(key) {\n          try {\n            dest[key] = src[key];\n          } catch (e) {\n            if (!error) error = e;\n          }\n        };\n        for (i = 1; i < length; ++i) {\n          src = arguments[i];\n          keys(src).forEach(assign);\n        }\n        if (error !== undefined) throw error;\n        return dest;\n      };\n\n    }, { \"../keys\": 45, \"../valid-value\": 55 }], 39: [function (require, module, exports) {\n      \"use strict\";\n\n      var aFrom = require(\"../array/from\"),\n      assign = require(\"./assign\"),\n      value = require(\"./valid-value\");\n\n      module.exports = function (obj /*, propertyNames, options*/) {\n        var copy = Object(value(obj)),propertyNames = arguments[1],options = Object(arguments[2]);\n        if (copy !== obj && !propertyNames) return copy;\n        var result = {};\n        if (propertyNames) {\n          aFrom(propertyNames, function (propertyName) {\n            if (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];\n          });\n        } else {\n          assign(result, obj);\n        }\n        return result;\n      };\n\n    }, { \"../array/from\": 21, \"./assign\": 36, \"./valid-value\": 55 }], 40: [function (require, module, exports) {\n      // Workaround for http://code.google.com/p/v8/issues/detail?id=2804\n\n      \"use strict\";\n\n      var create = Object.create,shim;\n\n      if (!require(\"./set-prototype-of/is-implemented\")()) {\n        shim = require(\"./set-prototype-of/shim\");\n      }\n\n      module.exports = function () {\n        var nullObject, polyProps, desc;\n        if (!shim) return create;\n        if (shim.level !== 1) return create;\n\n        nullObject = {};\n        polyProps = {};\n        desc = {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: undefined };\n\n        Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {\n          if (name === \"__proto__\") {\n            polyProps[name] = {\n              configurable: true,\n              enumerable: false,\n              writable: true,\n              value: undefined };\n\n            return;\n          }\n          polyProps[name] = desc;\n        });\n        Object.defineProperties(nullObject, polyProps);\n\n        Object.defineProperty(shim, \"nullPolyfill\", {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: nullObject });\n\n\n        return function (prototype, props) {\n          return create(prototype === null ? nullObject : prototype, props);\n        };\n      }();\n\n    }, { \"./set-prototype-of/is-implemented\": 52, \"./set-prototype-of/shim\": 53 }], 41: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./_iterate\")(\"forEach\");\n\n    }, { \"./_iterate\": 35 }], 42: [function (require, module, exports) {\n      // Deprecated\n\n      \"use strict\";\n\n      module.exports = function (obj) {\n        return typeof obj === \"function\";\n      };\n\n    }, {}], 43: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"./is-value\");\n\n      var map = { function: true, object: true };\n\n      module.exports = function (value) {\n        return isValue(value) && map[typeof value] || false;\n      };\n\n    }, { \"./is-value\": 44 }], 44: [function (require, module, exports) {\n      \"use strict\";\n\n      var _undefined = require(\"../function/noop\")(); // Support ES3 engines\n\n      module.exports = function (val) {\n        return val !== _undefined && val !== null;\n      };\n\n    }, { \"../function/noop\": 26 }], 45: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ? Object.keys : require(\"./shim\");\n\n    }, { \"./is-implemented\": 46, \"./shim\": 47 }], 46: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        try {\n          Object.keys(\"primitive\");\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n\n    }, {}], 47: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"../is-value\");\n\n      var keys = Object.keys;\n\n      module.exports = function (object) {return keys(isValue(object) ? Object(object) : object);};\n\n    }, { \"../is-value\": 44 }], 48: [function (require, module, exports) {\n      \"use strict\";\n\n      var callable = require(\"./valid-callable\"),\n      forEach = require(\"./for-each\"),\n      call = Function.prototype.call;\n\n      module.exports = function (obj, cb /*, thisArg*/) {\n        var result = {},thisArg = arguments[2];\n        callable(cb);\n        forEach(obj, function (value, key, targetObj, index) {\n          result[key] = call.call(cb, thisArg, value, key, targetObj, index);\n        });\n        return result;\n      };\n\n    }, { \"./for-each\": 41, \"./valid-callable\": 54 }], 49: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"./is-value\");\n\n      var forEach = Array.prototype.forEach,create = Object.create;\n\n      var process = function process(src, obj) {\n        var key;\n        for (key in src) {obj[key] = src[key];}\n      };\n\n      // eslint-disable-next-line no-unused-vars\n      module.exports = function (opts1 /*, …options*/) {\n        var result = create(null);\n        forEach.call(arguments, function (options) {\n          if (!isValue(options)) return;\n          process(Object(options), result);\n        });\n        return result;\n      };\n\n    }, { \"./is-value\": 44 }], 50: [function (require, module, exports) {\n      \"use strict\";\n\n      var forEach = Array.prototype.forEach,create = Object.create;\n\n      // eslint-disable-next-line no-unused-vars\n      module.exports = function (arg /*, …args*/) {\n        var set = create(null);\n        forEach.call(arguments, function (name) {\n          set[name] = true;\n        });\n        return set;\n      };\n\n    }, {}], 51: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ?\n      Object.setPrototypeOf :\n      require(\"./shim\");\n\n    }, { \"./is-implemented\": 52, \"./shim\": 53 }], 52: [function (require, module, exports) {\n      \"use strict\";\n\n      var create = Object.create,getPrototypeOf = Object.getPrototypeOf,plainObject = {};\n\n      module.exports = function () /* CustomCreate*/{\n        var setPrototypeOf = Object.setPrototypeOf,customCreate = arguments[0] || create;\n        if (typeof setPrototypeOf !== \"function\") return false;\n        return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;\n      };\n\n    }, {}], 53: [function (require, module, exports) {\n      /* eslint no-proto: \"off\" */\n\n      // Big thanks to @WebReflection for sorting this out\n      // https://gist.github.com/WebReflection/5593554\n\n      \"use strict\";\n\n      var isObject = require(\"../is-object\"),\n      value = require(\"../valid-value\"),\n      objIsPrototypeOf = Object.prototype.isPrototypeOf,\n      defineProperty = Object.defineProperty,\n      nullDesc = {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: undefined },\n\n      validate;\n\n      validate = function validate(obj, prototype) {\n        value(obj);\n        if (prototype === null || isObject(prototype)) return obj;\n        throw new TypeError(\"Prototype must be null or an object\");\n      };\n\n      module.exports = function (status) {\n        var fn, set;\n        if (!status) return null;\n        if (status.level === 2) {\n          if (status.set) {\n            set = status.set;\n            fn = function fn(obj, prototype) {\n              set.call(validate(obj, prototype), prototype);\n              return obj;\n            };\n          } else {\n            fn = function fn(obj, prototype) {\n              validate(obj, prototype).__proto__ = prototype;\n              return obj;\n            };\n          }\n        } else {\n          fn = function self(obj, prototype) {\n            var isNullBase;\n            validate(obj, prototype);\n            isNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);\n            if (isNullBase) delete self.nullPolyfill.__proto__;\n            if (prototype === null) prototype = self.nullPolyfill;\n            obj.__proto__ = prototype;\n            if (isNullBase) defineProperty(self.nullPolyfill, \"__proto__\", nullDesc);\n            return obj;\n          };\n        }\n        return Object.defineProperty(fn, \"level\", {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: status.level });\n\n      }(\n      function () {\n        var tmpObj1 = Object.create(null),\n        tmpObj2 = {},\n        set,\n        desc = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\");\n\n        if (desc) {\n          try {\n            set = desc.set; // Opera crashes at this point\n            set.call(tmpObj1, tmpObj2);\n          } catch (ignore) {}\n          if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };\n        }\n\n        tmpObj1.__proto__ = tmpObj2;\n        if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };\n\n        tmpObj1 = {};\n        tmpObj1.__proto__ = tmpObj2;\n        if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };\n\n        return false;\n      }());\n\n\n      require(\"../create\");\n\n    }, { \"../create\": 40, \"../is-object\": 43, \"../valid-value\": 55 }], 54: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (fn) {\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        return fn;\n      };\n\n    }, {}], 55: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"./is-value\");\n\n      module.exports = function (value) {\n        if (!isValue(value)) throw new TypeError(\"Cannot use null or undefined\");\n        return value;\n      };\n\n    }, { \"./is-value\": 44 }], 56: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ?\n      String.prototype.contains :\n      require(\"./shim\");\n\n    }, { \"./is-implemented\": 57, \"./shim\": 58 }], 57: [function (require, module, exports) {\n      \"use strict\";\n\n      var str = \"razdwatrzy\";\n\n      module.exports = function () {\n        if (typeof str.contains !== \"function\") return false;\n        return str.contains(\"dwa\") === true && str.contains(\"foo\") === false;\n      };\n\n    }, {}], 58: [function (require, module, exports) {\n      \"use strict\";\n\n      var indexOf = String.prototype.indexOf;\n\n      module.exports = function (searchString /*, position*/) {\n        return indexOf.call(this, searchString, arguments[1]) > -1;\n      };\n\n    }, {}], 59: [function (require, module, exports) {\n      \"use strict\";\n\n      var objToString = Object.prototype.toString,id = objToString.call(\"\");\n\n      module.exports = function (value) {\n        return (\n          typeof value === \"string\" ||\n          value &&\n          typeof value === \"object\" && (\n          value instanceof String || objToString.call(value) === id) ||\n          false);\n\n      };\n\n    }, {}], 60: [function (require, module, exports) {\n      \"use strict\";\n\n      var setPrototypeOf = require(\"es5-ext/object/set-prototype-of\"),\n      contains = require(\"es5-ext/string/#/contains\"),\n      d = require(\"d\"),\n      Symbol = require(\"es6-symbol\"),\n      Iterator = require(\"./\");\n\n      var defineProperty = Object.defineProperty,ArrayIterator;\n\n      ArrayIterator = module.exports = function (arr, kind) {\n        if (!(this instanceof ArrayIterator)) throw new TypeError(\"Constructor requires 'new'\");\n        Iterator.call(this, arr);\n        if (!kind) kind = \"value\";else\n        if (contains.call(kind, \"key+value\")) kind = \"key+value\";else\n        if (contains.call(kind, \"key\")) kind = \"key\";else\n        kind = \"value\";\n        defineProperty(this, \"__kind__\", d(\"\", kind));\n      };\n      if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);\n\n      // Internal %ArrayIteratorPrototype% doesn't expose its constructor\n      delete ArrayIterator.prototype.constructor;\n\n      ArrayIterator.prototype = Object.create(Iterator.prototype, {\n        _resolve: d(function (i) {\n          if (this.__kind__ === \"value\") return this.__list__[i];\n          if (this.__kind__ === \"key+value\") return [i, this.__list__[i]];\n          return i;\n        }) });\n\n      defineProperty(ArrayIterator.prototype, Symbol.toStringTag, d(\"c\", \"Array Iterator\"));\n\n    }, { \"./\": 63, \"d\": 16, \"es5-ext/object/set-prototype-of\": 51, \"es5-ext/string/#/contains\": 56, \"es6-symbol\": 73 }], 61: [function (require, module, exports) {\n      \"use strict\";\n\n      var isArguments = require(\"es5-ext/function/is-arguments\"),\n      callable = require(\"es5-ext/object/valid-callable\"),\n      isString = require(\"es5-ext/string/is-string\"),\n      get = require(\"./get\");\n\n      var isArray = Array.isArray,call = Function.prototype.call,some = Array.prototype.some;\n\n      module.exports = function (iterable, cb /*, thisArg*/) {\n        var mode,thisArg = arguments[2],result,doBreak,broken,i,length,_char,code;\n        if (isArray(iterable) || isArguments(iterable)) mode = \"array\";else\n        if (isString(iterable)) mode = \"string\";else\n        iterable = get(iterable);\n\n        callable(cb);\n        doBreak = function doBreak() {\n          broken = true;\n        };\n        if (mode === \"array\") {\n          some.call(iterable, function (value) {\n            call.call(cb, thisArg, value, doBreak);\n            return broken;\n          });\n          return;\n        }\n        if (mode === \"string\") {\n          length = iterable.length;\n          for (i = 0; i < length; ++i) {\n            _char = iterable[i];\n            if (i + 1 < length) {\n              code = _char.charCodeAt(0);\n              if (code >= 0xd800 && code <= 0xdbff) _char += iterable[++i];\n            }\n            call.call(cb, thisArg, _char, doBreak);\n            if (broken) break;\n          }\n          return;\n        }\n        result = iterable.next();\n\n        while (!result.done) {\n          call.call(cb, thisArg, result.value, doBreak);\n          if (broken) return;\n          result = iterable.next();\n        }\n      };\n\n    }, { \"./get\": 62, \"es5-ext/function/is-arguments\": 24, \"es5-ext/object/valid-callable\": 54, \"es5-ext/string/is-string\": 59 }], 62: [function (require, module, exports) {\n      \"use strict\";\n\n      var isArguments = require(\"es5-ext/function/is-arguments\"),\n      isString = require(\"es5-ext/string/is-string\"),\n      ArrayIterator = require(\"./array\"),\n      StringIterator = require(\"./string\"),\n      iterable = require(\"./valid-iterable\"),\n      iteratorSymbol = require(\"es6-symbol\").iterator;\n\n      module.exports = function (obj) {\n        if (typeof iterable(obj)[iteratorSymbol] === \"function\") return obj[iteratorSymbol]();\n        if (isArguments(obj)) return new ArrayIterator(obj);\n        if (isString(obj)) return new StringIterator(obj);\n        return new ArrayIterator(obj);\n      };\n\n    }, { \"./array\": 60, \"./string\": 65, \"./valid-iterable\": 66, \"es5-ext/function/is-arguments\": 24, \"es5-ext/string/is-string\": 59, \"es6-symbol\": 73 }], 63: [function (require, module, exports) {\n      \"use strict\";\n\n      var clear = require(\"es5-ext/array/#/clear\"),\n      assign = require(\"es5-ext/object/assign\"),\n      callable = require(\"es5-ext/object/valid-callable\"),\n      value = require(\"es5-ext/object/valid-value\"),\n      d = require(\"d\"),\n      autoBind = require(\"d/auto-bind\"),\n      Symbol = require(\"es6-symbol\");\n\n      var defineProperty = Object.defineProperty,defineProperties = Object.defineProperties,_Iterator;\n\n      module.exports = _Iterator = function Iterator(list, context) {\n        if (!(this instanceof _Iterator)) throw new TypeError(\"Constructor requires 'new'\");\n        defineProperties(this, {\n          __list__: d(\"w\", value(list)),\n          __context__: d(\"w\", context),\n          __nextIndex__: d(\"w\", 0) });\n\n        if (!context) return;\n        callable(context.on);\n        context.on(\"_add\", this._onAdd);\n        context.on(\"_delete\", this._onDelete);\n        context.on(\"_clear\", this._onClear);\n      };\n\n      // Internal %IteratorPrototype% doesn't expose its constructor\n      delete _Iterator.prototype.constructor;\n\n      defineProperties(\n      _Iterator.prototype,\n      assign(\n      {\n        _next: d(function () {\n          var i;\n          if (!this.__list__) return undefined;\n          if (this.__redo__) {\n            i = this.__redo__.shift();\n            if (i !== undefined) return i;\n          }\n          if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;\n          this._unBind();\n          return undefined;\n        }),\n        next: d(function () {\n          return this._createResult(this._next());\n        }),\n        _createResult: d(function (i) {\n          if (i === undefined) return { done: true, value: undefined };\n          return { done: false, value: this._resolve(i) };\n        }),\n        _resolve: d(function (i) {\n          return this.__list__[i];\n        }),\n        _unBind: d(function () {\n          this.__list__ = null;\n          delete this.__redo__;\n          if (!this.__context__) return;\n          this.__context__.off(\"_add\", this._onAdd);\n          this.__context__.off(\"_delete\", this._onDelete);\n          this.__context__.off(\"_clear\", this._onClear);\n          this.__context__ = null;\n        }),\n        toString: d(function () {\n          return \"[object \" + (this[Symbol.toStringTag] || \"Object\") + \"]\";\n        }) },\n\n      autoBind({\n        _onAdd: d(function (index) {\n          if (index >= this.__nextIndex__) return;\n          ++this.__nextIndex__;\n          if (!this.__redo__) {\n            defineProperty(this, \"__redo__\", d(\"c\", [index]));\n            return;\n          }\n          this.__redo__.forEach(function (redo, i) {\n            if (redo >= index) this.__redo__[i] = ++redo;\n          }, this);\n          this.__redo__.push(index);\n        }),\n        _onDelete: d(function (index) {\n          var i;\n          if (index >= this.__nextIndex__) return;\n          --this.__nextIndex__;\n          if (!this.__redo__) return;\n          i = this.__redo__.indexOf(index);\n          if (i !== -1) this.__redo__.splice(i, 1);\n          this.__redo__.forEach(function (redo, j) {\n            if (redo > index) this.__redo__[j] = --redo;\n          }, this);\n        }),\n        _onClear: d(function () {\n          if (this.__redo__) clear.call(this.__redo__);\n          this.__nextIndex__ = 0;\n        }) })));\n\n\n\n\n      defineProperty(\n      _Iterator.prototype,\n      Symbol.iterator,\n      d(function () {\n        return this;\n      }));\n\n\n    }, { \"d\": 16, \"d/auto-bind\": 15, \"es5-ext/array/#/clear\": 19, \"es5-ext/object/assign\": 36, \"es5-ext/object/valid-callable\": 54, \"es5-ext/object/valid-value\": 55, \"es6-symbol\": 73 }], 64: [function (require, module, exports) {\n      \"use strict\";\n\n      var isArguments = require(\"es5-ext/function/is-arguments\"),\n      isValue = require(\"es5-ext/object/is-value\"),\n      isString = require(\"es5-ext/string/is-string\");\n\n      var iteratorSymbol = require(\"es6-symbol\").iterator,\n      isArray = Array.isArray;\n\n      module.exports = function (value) {\n        if (!isValue(value)) return false;\n        if (isArray(value)) return true;\n        if (isString(value)) return true;\n        if (isArguments(value)) return true;\n        return typeof value[iteratorSymbol] === \"function\";\n      };\n\n    }, { \"es5-ext/function/is-arguments\": 24, \"es5-ext/object/is-value\": 44, \"es5-ext/string/is-string\": 59, \"es6-symbol\": 73 }], 65: [function (require, module, exports) {\n      // Thanks @mathiasbynens\n      // http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols\n\n      \"use strict\";\n\n      var setPrototypeOf = require(\"es5-ext/object/set-prototype-of\"),\n      d = require(\"d\"),\n      Symbol = require(\"es6-symbol\"),\n      Iterator = require(\"./\");\n\n      var defineProperty = Object.defineProperty,StringIterator;\n\n      StringIterator = module.exports = function (str) {\n        if (!(this instanceof StringIterator)) throw new TypeError(\"Constructor requires 'new'\");\n        str = String(str);\n        Iterator.call(this, str);\n        defineProperty(this, \"__length__\", d(\"\", str.length));\n      };\n      if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);\n\n      // Internal %ArrayIteratorPrototype% doesn't expose its constructor\n      delete StringIterator.prototype.constructor;\n\n      StringIterator.prototype = Object.create(Iterator.prototype, {\n        _next: d(function () {\n          if (!this.__list__) return undefined;\n          if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;\n          this._unBind();\n          return undefined;\n        }),\n        _resolve: d(function (i) {\n          var _char2 = this.__list__[i],code;\n          if (this.__nextIndex__ === this.__length__) return _char2;\n          code = _char2.charCodeAt(0);\n          if (code >= 0xd800 && code <= 0xdbff) return _char2 + this.__list__[this.__nextIndex__++];\n          return _char2;\n        }) });\n\n      defineProperty(StringIterator.prototype, Symbol.toStringTag, d(\"c\", \"String Iterator\"));\n\n    }, { \"./\": 63, \"d\": 16, \"es5-ext/object/set-prototype-of\": 51, \"es6-symbol\": 73 }], 66: [function (require, module, exports) {\n      \"use strict\";\n\n      var isIterable = require(\"./is-iterable\");\n\n      module.exports = function (value) {\n        if (!isIterable(value)) throw new TypeError(value + \" is not iterable\");\n        return value;\n      };\n\n    }, { \"./is-iterable\": 64 }], 67: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = require('./is-implemented')() ? Map : require('./polyfill');\n\n    }, { \"./is-implemented\": 68, \"./polyfill\": 72 }], 68: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = function () {\n        var map, iterator, result;\n        if (typeof Map !== 'function') return false;\n        try {\n          // WebKit doesn't support arguments and crashes\n          map = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);\n        } catch (e) {\n          return false;\n        }\n        if (String(map) !== '[object Map]') return false;\n        if (map.size !== 3) return false;\n        if (typeof map.clear !== 'function') return false;\n        if (typeof map.delete !== 'function') return false;\n        if (typeof map.entries !== 'function') return false;\n        if (typeof map.forEach !== 'function') return false;\n        if (typeof map.get !== 'function') return false;\n        if (typeof map.has !== 'function') return false;\n        if (typeof map.keys !== 'function') return false;\n        if (typeof map.set !== 'function') return false;\n        if (typeof map.values !== 'function') return false;\n\n        iterator = map.entries();\n        result = iterator.next();\n        if (result.done !== false) return false;\n        if (!result.value) return false;\n        if (result.value[0] !== 'raz') return false;\n        if (result.value[1] !== 'one') return false;\n\n        return true;\n      };\n\n    }, {}], 69: [function (require, module, exports) {\n      // Exports true if environment provides native `Map` implementation,\n      // whatever that is.\n\n      'use strict';\n\n      module.exports = function () {\n        if (typeof Map === 'undefined') return false;\n        return Object.prototype.toString.call(new Map()) === '[object Map]';\n      }();\n\n    }, {}], 70: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = require('es5-ext/object/primitive-set')('key',\n      'value', 'key+value');\n\n    }, { \"es5-ext/object/primitive-set\": 50 }], 71: [function (require, module, exports) {\n      'use strict';\n\n      var setPrototypeOf = require('es5-ext/object/set-prototype-of'),\n      d = require('d'),\n      Iterator = require('es6-iterator'),\n      toStringTagSymbol = require('es6-symbol').toStringTag,\n      kinds = require('./iterator-kinds'),\n\n      defineProperties = Object.defineProperties,\n      unBind = Iterator.prototype._unBind,\n      MapIterator;\n\n      MapIterator = module.exports = function (map, kind) {\n        if (!(this instanceof MapIterator)) return new MapIterator(map, kind);\n        Iterator.call(this, map.__mapKeysData__, map);\n        if (!kind || !kinds[kind]) kind = 'key+value';\n        defineProperties(this, {\n          __kind__: d('', kind),\n          __values__: d('w', map.__mapValuesData__) });\n\n      };\n      if (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);\n\n      MapIterator.prototype = Object.create(Iterator.prototype, {\n        constructor: d(MapIterator),\n        _resolve: d(function (i) {\n          if (this.__kind__ === 'value') return this.__values__[i];\n          if (this.__kind__ === 'key') return this.__list__[i];\n          return [this.__list__[i], this.__values__[i]];\n        }),\n        _unBind: d(function () {\n          this.__values__ = null;\n          unBind.call(this);\n        }),\n        toString: d(function () {return '[object Map Iterator]';}) });\n\n      Object.defineProperty(MapIterator.prototype, toStringTagSymbol,\n      d('c', 'Map Iterator'));\n\n    }, { \"./iterator-kinds\": 70, \"d\": 16, \"es5-ext/object/set-prototype-of\": 51, \"es6-iterator\": 63, \"es6-symbol\": 73 }], 72: [function (require, module, exports) {\n      'use strict';\n\n      var clear = require('es5-ext/array/#/clear'),\n      eIndexOf = require('es5-ext/array/#/e-index-of'),\n      setPrototypeOf = require('es5-ext/object/set-prototype-of'),\n      callable = require('es5-ext/object/valid-callable'),\n      validValue = require('es5-ext/object/valid-value'),\n      d = require('d'),\n      ee = require('event-emitter'),\n      Symbol = require('es6-symbol'),\n      iterator = require('es6-iterator/valid-iterable'),\n      forOf = require('es6-iterator/for-of'),\n      Iterator = require('./lib/iterator'),\n      isNative = require('./is-native-implemented'),\n\n      call = Function.prototype.call,\n      defineProperties = Object.defineProperties,getPrototypeOf = Object.getPrototypeOf,\n      _MapPoly;\n\n      module.exports = _MapPoly = function MapPoly() /*iterable*/{\n        var iterable = arguments[0],keys,values,self;\n        if (!(this instanceof _MapPoly)) throw new TypeError('Constructor requires \\'new\\'');\n        if (isNative && setPrototypeOf && Map !== _MapPoly) {\n          self = setPrototypeOf(new Map(), getPrototypeOf(this));\n        } else {\n          self = this;\n        }\n        if (iterable != null) iterator(iterable);\n        defineProperties(self, {\n          __mapKeysData__: d('c', keys = []),\n          __mapValuesData__: d('c', values = []) });\n\n        if (!iterable) return self;\n        forOf(iterable, function (value) {\n          var key = validValue(value)[0];\n          value = value[1];\n          if (eIndexOf.call(keys, key) !== -1) return;\n          keys.push(key);\n          values.push(value);\n        }, self);\n        return self;\n      };\n\n      if (isNative) {\n        if (setPrototypeOf) setPrototypeOf(_MapPoly, Map);\n        _MapPoly.prototype = Object.create(Map.prototype, {\n          constructor: d(_MapPoly) });\n\n      }\n\n      ee(defineProperties(_MapPoly.prototype, {\n        clear: d(function () {\n          if (!this.__mapKeysData__.length) return;\n          clear.call(this.__mapKeysData__);\n          clear.call(this.__mapValuesData__);\n          this.emit('_clear');\n        }),\n        delete: d(function (key) {\n          var index = eIndexOf.call(this.__mapKeysData__, key);\n          if (index === -1) return false;\n          this.__mapKeysData__.splice(index, 1);\n          this.__mapValuesData__.splice(index, 1);\n          this.emit('_delete', index, key);\n          return true;\n        }),\n        entries: d(function () {return new Iterator(this, 'key+value');}),\n        forEach: d(function (cb /*, thisArg*/) {\n          var thisArg = arguments[1],iterator,result;\n          callable(cb);\n          iterator = this.entries();\n          result = iterator._next();\n          while (result !== undefined) {\n            call.call(cb, thisArg, this.__mapValuesData__[result],\n            this.__mapKeysData__[result], this);\n            result = iterator._next();\n          }\n        }),\n        get: d(function (key) {\n          var index = eIndexOf.call(this.__mapKeysData__, key);\n          if (index === -1) return;\n          return this.__mapValuesData__[index];\n        }),\n        has: d(function (key) {\n          return eIndexOf.call(this.__mapKeysData__, key) !== -1;\n        }),\n        keys: d(function () {return new Iterator(this, 'key');}),\n        set: d(function (key, value) {\n          var index = eIndexOf.call(this.__mapKeysData__, key),emit;\n          if (index === -1) {\n            index = this.__mapKeysData__.push(key) - 1;\n            emit = true;\n          }\n          this.__mapValuesData__[index] = value;\n          if (emit) this.emit('_add', index, key);\n          return this;\n        }),\n        size: d.gs(function () {return this.__mapKeysData__.length;}),\n        values: d(function () {return new Iterator(this, 'value');}),\n        toString: d(function () {return '[object Map]';}) }));\n\n      Object.defineProperty(_MapPoly.prototype, Symbol.iterator, d(function () {\n        return this.entries();\n      }));\n      Object.defineProperty(_MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));\n\n    }, { \"./is-native-implemented\": 69, \"./lib/iterator\": 71, \"d\": 16, \"es5-ext/array/#/clear\": 19, \"es5-ext/array/#/e-index-of\": 20, \"es5-ext/object/set-prototype-of\": 51, \"es5-ext/object/valid-callable\": 54, \"es5-ext/object/valid-value\": 55, \"es6-iterator/for-of\": 61, \"es6-iterator/valid-iterable\": 66, \"es6-symbol\": 73, \"event-emitter\": 78 }], 73: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = require('./is-implemented')() ? Symbol : require('./polyfill');\n\n    }, { \"./is-implemented\": 74, \"./polyfill\": 76 }], 74: [function (require, module, exports) {\n      'use strict';\n\n      var validTypes = { object: true, symbol: true };\n\n      module.exports = function () {\n        var symbol;\n        if (typeof Symbol !== 'function') return false;\n        symbol = Symbol('test symbol');\n        try {String(symbol);} catch (e) {return false;}\n\n        // Return 'true' also for polyfills\n        if (!validTypes[typeof Symbol.iterator]) return false;\n        if (!validTypes[typeof Symbol.toPrimitive]) return false;\n        if (!validTypes[typeof Symbol.toStringTag]) return false;\n\n        return true;\n      };\n\n    }, {}], 75: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = function (x) {\n        if (!x) return false;\n        if (typeof x === 'symbol') return true;\n        if (!x.constructor) return false;\n        if (x.constructor.name !== 'Symbol') return false;\n        return x[x.constructor.toStringTag] === 'Symbol';\n      };\n\n    }, {}], 76: [function (require, module, exports) {\n      // ES2015 Symbol polyfill for environments that do not (or partially) support it\n\n      'use strict';\n\n      var d = require('d'),\n      validateSymbol = require('./validate-symbol'),\n\n      create = Object.create,defineProperties = Object.defineProperties,\n      defineProperty = Object.defineProperty,objPrototype = Object.prototype,\n      NativeSymbol,SymbolPolyfill,HiddenSymbol,globalSymbols = create(null),\n      isNativeSafe;\n\n      if (typeof Symbol === 'function') {\n        NativeSymbol = Symbol;\n        try {\n          String(NativeSymbol());\n          isNativeSafe = true;\n        } catch (ignore) {}\n      }\n\n      var generateName = function () {\n        var created = create(null);\n        return function (desc) {\n          var postfix = 0,name,ie11BugWorkaround;\n          while (created[desc + (postfix || '')]) {++postfix;}\n          desc += postfix || '';\n          created[desc] = true;\n          name = '@@' + desc;\n          defineProperty(objPrototype, name, d.gs(null, function (value) {\n            // For IE11 issue see:\n            // https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n            //    ie11-broken-getters-on-dom-objects\n            // https://github.com/medikoo/es6-symbol/issues/12\n            if (ie11BugWorkaround) return;\n            ie11BugWorkaround = true;\n            defineProperty(this, name, d(value));\n            ie11BugWorkaround = false;\n          }));\n          return name;\n        };\n      }();\n\n      // Internal constructor (not one exposed) for creating Symbol instances.\n      // This one is used to ensure that `someSymbol instanceof Symbol` always return false\n      HiddenSymbol = function Symbol(description) {\n        if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');\n        return SymbolPolyfill(description);\n      };\n\n      // Exposed `Symbol` constructor\n      // (returns instances of HiddenSymbol)\n      module.exports = SymbolPolyfill = function Symbol(description) {\n        var symbol;\n        if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');\n        if (isNativeSafe) return NativeSymbol(description);\n        symbol = create(HiddenSymbol.prototype);\n        description = description === undefined ? '' : String(description);\n        return defineProperties(symbol, {\n          __description__: d('', description),\n          __name__: d('', generateName(description)) });\n\n      };\n      defineProperties(SymbolPolyfill, {\n        for: d(function (key) {\n          if (globalSymbols[key]) return globalSymbols[key];\n          return globalSymbols[key] = SymbolPolyfill(String(key));\n        }),\n        keyFor: d(function (s) {\n          var key;\n          validateSymbol(s);\n          for (key in globalSymbols) {if (globalSymbols[key] === s) return key;}\n        }),\n\n        // To ensure proper interoperability with other native functions (e.g. Array.from)\n        // fallback to eventual native implementation of given symbol\n        hasInstance: d('', NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill('hasInstance')),\n        isConcatSpreadable: d('', NativeSymbol && NativeSymbol.isConcatSpreadable ||\n        SymbolPolyfill('isConcatSpreadable')),\n        iterator: d('', NativeSymbol && NativeSymbol.iterator || SymbolPolyfill('iterator')),\n        match: d('', NativeSymbol && NativeSymbol.match || SymbolPolyfill('match')),\n        replace: d('', NativeSymbol && NativeSymbol.replace || SymbolPolyfill('replace')),\n        search: d('', NativeSymbol && NativeSymbol.search || SymbolPolyfill('search')),\n        species: d('', NativeSymbol && NativeSymbol.species || SymbolPolyfill('species')),\n        split: d('', NativeSymbol && NativeSymbol.split || SymbolPolyfill('split')),\n        toPrimitive: d('', NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill('toPrimitive')),\n        toStringTag: d('', NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill('toStringTag')),\n        unscopables: d('', NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill('unscopables')) });\n\n\n      // Internal tweaks for real symbol producer\n      defineProperties(HiddenSymbol.prototype, {\n        constructor: d(SymbolPolyfill),\n        toString: d('', function () {return this.__name__;}) });\n\n\n      // Proper implementation of methods exposed on Symbol.prototype\n      // They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\n      defineProperties(SymbolPolyfill.prototype, {\n        toString: d(function () {return 'Symbol (' + validateSymbol(this).__description__ + ')';}),\n        valueOf: d(function () {return validateSymbol(this);}) });\n\n      defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {\n        var symbol = validateSymbol(this);\n        if (typeof symbol === 'symbol') return symbol;\n        return symbol.toString();\n      }));\n      defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));\n\n      // Proper implementaton of toPrimitive and toStringTag for returned symbol instances\n      defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,\n      d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));\n\n      // Note: It's important to define `toPrimitive` as last one, as some implementations\n      // implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n      // And that may invoke error in definition flow:\n      // See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\n      defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,\n      d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));\n\n    }, { \"./validate-symbol\": 77, \"d\": 16 }], 77: [function (require, module, exports) {\n      'use strict';\n\n      var isSymbol = require('./is-symbol');\n\n      module.exports = function (value) {\n        if (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n        return value;\n      };\n\n    }, { \"./is-symbol\": 75 }], 78: [function (require, module, exports) {\n      'use strict';\n\n      var d = require('d'),\n      callable = require('es5-ext/object/valid-callable'),\n\n      apply = Function.prototype.apply,call = Function.prototype.call,\n      create = Object.create,defineProperty = Object.defineProperty,\n      defineProperties = Object.defineProperties,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      descriptor = { configurable: true, enumerable: false, writable: true },\n\n      on,_once2,off,emit,methods,descriptors,base;\n\n      on = function on(type, listener) {\n        var data;\n\n        callable(listener);\n\n        if (!hasOwnProperty.call(this, '__ee__')) {\n          data = descriptor.value = create(null);\n          defineProperty(this, '__ee__', descriptor);\n          descriptor.value = null;\n        } else {\n          data = this.__ee__;\n        }\n        if (!data[type]) data[type] = listener;else\n        if (typeof data[type] === 'object') data[type].push(listener);else\n        data[type] = [data[type], listener];\n\n        return this;\n      };\n\n      _once2 = function once(type, listener) {\n        var _once, self;\n\n        callable(listener);\n        self = this;\n        on.call(this, type, _once = function once() {\n          off.call(self, type, _once);\n          apply.call(listener, this, arguments);\n        });\n\n        _once.__eeOnceListener__ = listener;\n        return this;\n      };\n\n      off = function off(type, listener) {\n        var data, listeners, candidate, i;\n\n        callable(listener);\n\n        if (!hasOwnProperty.call(this, '__ee__')) return this;\n        data = this.__ee__;\n        if (!data[type]) return this;\n        listeners = data[type];\n\n        if (typeof listeners === 'object') {\n          for (i = 0; candidate = listeners[i]; ++i) {\n            if (candidate === listener ||\n            candidate.__eeOnceListener__ === listener) {\n              if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];else\n              listeners.splice(i, 1);\n            }\n          }\n        } else {\n          if (listeners === listener ||\n          listeners.__eeOnceListener__ === listener) {\n            delete data[type];\n          }\n        }\n\n        return this;\n      };\n\n      emit = function emit(type) {\n        var i, l, listener, listeners, args;\n\n        if (!hasOwnProperty.call(this, '__ee__')) return;\n        listeners = this.__ee__[type];\n        if (!listeners) return;\n\n        if (typeof listeners === 'object') {\n          l = arguments.length;\n          args = new Array(l - 1);\n          for (i = 1; i < l; ++i) {args[i - 1] = arguments[i];}\n\n          listeners = listeners.slice();\n          for (i = 0; listener = listeners[i]; ++i) {\n            apply.call(listener, this, args);\n          }\n        } else {\n          switch (arguments.length) {\n            case 1:\n              call.call(listeners, this);\n              break;\n            case 2:\n              call.call(listeners, this, arguments[1]);\n              break;\n            case 3:\n              call.call(listeners, this, arguments[1], arguments[2]);\n              break;\n            default:\n              l = arguments.length;\n              args = new Array(l - 1);\n              for (i = 1; i < l; ++i) {\n                args[i - 1] = arguments[i];\n              }\n              apply.call(listeners, this, args);}\n\n        }\n      };\n\n      methods = {\n        on: on,\n        once: _once2,\n        off: off,\n        emit: emit };\n\n\n      descriptors = {\n        on: d(on),\n        once: d(_once2),\n        off: d(off),\n        emit: d(emit) };\n\n\n      base = defineProperties({}, descriptors);\n\n      module.exports = exports = function exports(o) {\n        return o == null ? create(base) : defineProperties(Object(o), descriptors);\n      };\n      exports.methods = methods;\n\n    }, { \"d\": 16, \"es5-ext/object/valid-callable\": 54 }], 79: [function (require, module, exports) {\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n\n        i += d;\n\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n        value = Math.abs(value);\n\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n        buffer[offset + i - d] |= s * 128;\n      };\n\n    }, {}], 80: [function (require, module, exports) {\n      if (typeof Object.create === 'function') {\n        // implementation from standard node.js 'util' module\n        module.exports = function inherits(ctor, superCtor) {\n          ctor.super_ = superCtor;\n          ctor.prototype = Object.create(superCtor.prototype, {\n            constructor: {\n              value: ctor,\n              enumerable: false,\n              writable: true,\n              configurable: true } });\n\n\n        };\n      } else {\n        // old school shim for old browsers\n        module.exports = function inherits(ctor, superCtor) {\n          ctor.super_ = superCtor;\n          var TempCtor = function TempCtor() {};\n          TempCtor.prototype = superCtor.prototype;\n          ctor.prototype = new TempCtor();\n          ctor.prototype.constructor = ctor;\n        };\n      }\n\n    }, {}], 81: [function (require, module, exports) {\n      /*!\n                                                       * Determine if an object is a Buffer\n                                                       *\n                                                       * @author   Feross Aboukhadijeh <https://feross.org>\n                                                       * @license  MIT\n                                                       */\n\n      // The _isBuffer check is for Safari 5-7 support, because it's missing\n      // Object.prototype.constructor. Remove this eventually\n      module.exports = function (obj) {\n        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n      };\n\n      function isBuffer(obj) {\n        return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n      }\n\n      // For Node v0.10 support. Remove this eventually.\n      function isSlowBuffer(obj) {\n        return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));\n      }\n\n    }, {}], 82: [function (require, module, exports) {\n      'use strict';\n\n      var Buffer = require('safe-buffer').Buffer;\n\n      /* Protocol - protocol constants */\n      var protocol = module.exports;\n\n      /* Command code => mnemonic */\n      protocol.types = {\n        0: 'reserved',\n        1: 'connect',\n        2: 'connack',\n        3: 'publish',\n        4: 'puback',\n        5: 'pubrec',\n        6: 'pubrel',\n        7: 'pubcomp',\n        8: 'subscribe',\n        9: 'suback',\n        10: 'unsubscribe',\n        11: 'unsuback',\n        12: 'pingreq',\n        13: 'pingresp',\n        14: 'disconnect',\n        15: 'auth' };\n\n\n      /* Mnemonic => Command code */\n      protocol.codes = {};\n      for (var k in protocol.types) {\n        var v = protocol.types[k];\n        protocol.codes[v] = k;\n      }\n\n      /* Header */\n      protocol.CMD_SHIFT = 4;\n      protocol.CMD_MASK = 0xF0;\n      protocol.DUP_MASK = 0x08;\n      protocol.QOS_MASK = 0x03;\n      protocol.QOS_SHIFT = 1;\n      protocol.RETAIN_MASK = 0x01;\n\n      /* Length */\n      protocol.LENGTH_MASK = 0x7F;\n      protocol.LENGTH_FIN_MASK = 0x80;\n\n      /* Connack */\n      protocol.SESSIONPRESENT_MASK = 0x01;\n      protocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK]);\n      protocol.CONNACK_HEADER = Buffer.from([protocol.codes['connack'] << protocol.CMD_SHIFT]);\n\n      /* Connect */\n      protocol.USERNAME_MASK = 0x80;\n      protocol.PASSWORD_MASK = 0x40;\n      protocol.WILL_RETAIN_MASK = 0x20;\n      protocol.WILL_QOS_MASK = 0x18;\n      protocol.WILL_QOS_SHIFT = 3;\n      protocol.WILL_FLAG_MASK = 0x04;\n      protocol.CLEAN_SESSION_MASK = 0x02;\n      protocol.CONNECT_HEADER = Buffer.from([protocol.codes['connect'] << protocol.CMD_SHIFT]);\n\n      /* Properties */\n      protocol.properties = {\n        sessionExpiryInterval: 17,\n        willDelayInterval: 24,\n        receiveMaximum: 33,\n        maximumPacketSize: 39,\n        topicAliasMaximum: 34,\n        requestResponseInformation: 25,\n        requestProblemInformation: 23,\n        userProperties: 38,\n        authenticationMethod: 21,\n        authenticationData: 22,\n        payloadFormatIndicator: 1,\n        messageExpiryInterval: 2,\n        contentType: 3,\n        responseTopic: 8,\n        correlationData: 9,\n        maximumQoS: 36,\n        retainAvailable: 37,\n        assignedClientIdentifier: 18,\n        reasonString: 31,\n        wildcardSubscriptionAvailable: 40,\n        subscriptionIdentifiersAvailable: 41,\n        sharedSubscriptionAvailable: 42,\n        serverKeepAlive: 19,\n        responseInformation: 26,\n        serverReference: 28,\n        topicAlias: 35,\n        subscriptionIdentifier: 11 };\n\n      protocol.propertiesCodes = {};\n      for (var prop in protocol.properties) {\n        var id = protocol.properties[prop];\n        protocol.propertiesCodes[id] = prop;\n      }\n      protocol.propertiesTypes = {\n        sessionExpiryInterval: 'int32',\n        willDelayInterval: 'int32',\n        receiveMaximum: 'int16',\n        maximumPacketSize: 'int32',\n        topicAliasMaximum: 'int16',\n        requestResponseInformation: 'byte',\n        requestProblemInformation: 'byte',\n        userProperties: 'pair',\n        authenticationMethod: 'string',\n        authenticationData: 'binary',\n        payloadFormatIndicator: 'byte',\n        messageExpiryInterval: 'int32',\n        contentType: 'string',\n        responseTopic: 'string',\n        correlationData: 'binary',\n        maximumQoS: 'int8',\n        retainAvailable: 'byte',\n        assignedClientIdentifier: 'string',\n        reasonString: 'string',\n        wildcardSubscriptionAvailable: 'byte',\n        subscriptionIdentifiersAvailable: 'byte',\n        sharedSubscriptionAvailable: 'byte',\n        serverKeepAlive: 'int32',\n        responseInformation: 'string',\n        serverReference: 'string',\n        topicAlias: 'int16',\n        subscriptionIdentifier: 'var' };\n\n\n      function genHeader(type) {\n        return [0, 1, 2].map(function (qos) {\n          return [0, 1].map(function (dup) {\n            return [0, 1].map(function (retain) {\n              var buf = new Buffer(1);\n              buf.writeUInt8(\n              protocol.codes[type] << protocol.CMD_SHIFT | (\n              dup ? protocol.DUP_MASK : 0) |\n              qos << protocol.QOS_SHIFT | retain, 0, true);\n              return buf;\n            });\n          });\n        });\n      }\n\n      /* Publish */\n      protocol.PUBLISH_HEADER = genHeader('publish');\n\n      /* Subscribe */\n      protocol.SUBSCRIBE_HEADER = genHeader('subscribe');\n      protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 0x03;\n      protocol.SUBSCRIBE_OPTIONS_NL_MASK = 0x01;\n      protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2;\n      protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 0x01;\n      protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3;\n      protocol.SUBSCRIBE_OPTIONS_RH_MASK = 0x03;\n      protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4;\n      protocol.SUBSCRIBE_OPTIONS_RH = [0x00, 0x10, 0x20];\n      protocol.SUBSCRIBE_OPTIONS_NL = 0x04;\n      protocol.SUBSCRIBE_OPTIONS_RAP = 0x08;\n      protocol.SUBSCRIBE_OPTIONS_QOS = [0x00, 0x01, 0x02];\n\n      /* Unsubscribe */\n      protocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe');\n\n      /* Confirmations */\n      protocol.ACKS = {\n        unsuback: genHeader('unsuback'),\n        puback: genHeader('puback'),\n        pubcomp: genHeader('pubcomp'),\n        pubrel: genHeader('pubrel'),\n        pubrec: genHeader('pubrec') };\n\n\n      protocol.SUBACK_HEADER = Buffer.from([protocol.codes['suback'] << protocol.CMD_SHIFT]);\n\n      /* Protocol versions */\n      protocol.VERSION3 = Buffer.from([3]);\n      protocol.VERSION4 = Buffer.from([4]);\n      protocol.VERSION5 = Buffer.from([5]);\n\n      /* QoS */\n      protocol.QOS = [0, 1, 2].map(function (qos) {\n        return Buffer.from([qos]);\n      });\n\n      /* Empty packets */\n      protocol.EMPTY = {\n        pingreq: Buffer.from([protocol.codes['pingreq'] << 4, 0]),\n        pingresp: Buffer.from([protocol.codes['pingresp'] << 4, 0]),\n        disconnect: Buffer.from([protocol.codes['disconnect'] << 4, 0]) };\n\n\n    }, { \"safe-buffer\": 110 }], 83: [function (require, module, exports) {\n      'use strict';\n\n      var Buffer = require('safe-buffer').Buffer;\n      var writeToStream = require('./writeToStream');\n      var EE = require('events').EventEmitter;\n      var inherits = require('inherits');\n\n      function generate(packet, opts) {\n        var stream = new Accumulator();\n        writeToStream(packet, stream, opts);\n        return stream.concat();\n      }\n\n      function Accumulator() {\n        this._array = new Array(20);\n        this._i = 0;\n      }\n\n      inherits(Accumulator, EE);\n\n      Accumulator.prototype.write = function (chunk) {\n        this._array[this._i++] = chunk;\n        return true;\n      };\n\n      Accumulator.prototype.concat = function () {\n        var length = 0;\n        var lengths = new Array(this._array.length);\n        var list = this._array;\n        var pos = 0;\n        var i;\n        var result;\n\n        for (i = 0; i < list.length && list[i] !== undefined; i++) {\n          if (typeof list[i] !== 'string') lengths[i] = list[i].length;else\n          lengths[i] = Buffer.byteLength(list[i]);\n\n          length += lengths[i];\n        }\n\n        result = Buffer.allocUnsafe(length);\n\n        for (i = 0; i < list.length && list[i] !== undefined; i++) {\n          if (typeof list[i] !== 'string') {\n            list[i].copy(result, pos);\n            pos += lengths[i];\n          } else {\n            result.write(list[i], pos);\n            pos += lengths[i];\n          }\n        }\n\n        return result;\n      };\n\n      module.exports = generate;\n\n    }, { \"./writeToStream\": 89, \"events\": 13, \"inherits\": 80, \"safe-buffer\": 110 }], 84: [function (require, module, exports) {\n      'use strict';\n\n      exports.parser = require('./parser');\n      exports.generate = require('./generate');\n      exports.writeToStream = require('./writeToStream');\n\n    }, { \"./generate\": 83, \"./parser\": 88, \"./writeToStream\": 89 }], 85: [function (require, module, exports) {\n      var DuplexStream = require('readable-stream/duplex'),\n      util = require('util'),\n      Buffer = require('safe-buffer').Buffer;\n\n\n      function BufferList(callback) {\n        if (!(this instanceof BufferList))\n        return new BufferList(callback);\n\n        this._bufs = [];\n        this.length = 0;\n\n        if (typeof callback == 'function') {\n          this._callback = callback;\n\n          var piper = function piper(err) {\n            if (this._callback) {\n              this._callback(err);\n              this._callback = null;\n            }\n          }.bind(this);\n\n          this.on('pipe', function onPipe(src) {\n            src.on('error', piper);\n          });\n          this.on('unpipe', function onUnpipe(src) {\n            src.removeListener('error', piper);\n          });\n        } else {\n          this.append(callback);\n        }\n\n        DuplexStream.call(this);\n      }\n\n\n      util.inherits(BufferList, DuplexStream);\n\n\n      BufferList.prototype._offset = function _offset(offset) {\n        var tot = 0,i = 0,_t;\n        if (offset === 0) return [0, 0];\n        for (; i < this._bufs.length; i++) {\n          _t = tot + this._bufs[i].length;\n          if (offset < _t || i == this._bufs.length - 1)\n          return [i, offset - tot];\n          tot = _t;\n        }\n      };\n\n\n      BufferList.prototype.append = function append(buf) {\n        var i = 0;\n\n        if (Buffer.isBuffer(buf)) {\n          this._appendBuffer(buf);\n        } else if (Array.isArray(buf)) {\n          for (; i < buf.length; i++) {\n            this.append(buf[i]);}\n        } else if (buf instanceof BufferList) {\n          // unwrap argument into individual BufferLists\n          for (; i < buf._bufs.length; i++) {\n            this.append(buf._bufs[i]);}\n        } else if (buf != null) {\n          // coerce number arguments to strings, since Buffer(number) does\n          // uninitialized memory allocation\n          if (typeof buf == 'number')\n          buf = buf.toString();\n\n          this._appendBuffer(Buffer.from(buf));\n        }\n\n        return this;\n      };\n\n\n      BufferList.prototype._appendBuffer = function appendBuffer(buf) {\n        this._bufs.push(buf);\n        this.length += buf.length;\n      };\n\n\n      BufferList.prototype._write = function _write(buf, encoding, callback) {\n        this._appendBuffer(buf);\n\n        if (typeof callback == 'function')\n        callback();\n      };\n\n\n      BufferList.prototype._read = function _read(size) {\n        if (!this.length)\n        return this.push(null);\n\n        size = Math.min(size, this.length);\n        this.push(this.slice(0, size));\n        this.consume(size);\n      };\n\n\n      BufferList.prototype.end = function end(chunk) {\n        DuplexStream.prototype.end.call(this, chunk);\n\n        if (this._callback) {\n          this._callback(null, this.slice());\n          this._callback = null;\n        }\n      };\n\n\n      BufferList.prototype.get = function get(index) {\n        return this.slice(index, index + 1)[0];\n      };\n\n\n      BufferList.prototype.slice = function slice(start, end) {\n        if (typeof start == 'number' && start < 0)\n        start += this.length;\n        if (typeof end == 'number' && end < 0)\n        end += this.length;\n        return this.copy(null, 0, start, end);\n      };\n\n\n      BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {\n        if (typeof srcStart != 'number' || srcStart < 0)\n        srcStart = 0;\n        if (typeof srcEnd != 'number' || srcEnd > this.length)\n        srcEnd = this.length;\n        if (srcStart >= this.length)\n        return dst || Buffer.alloc(0);\n        if (srcEnd <= 0)\n        return dst || Buffer.alloc(0);\n\n        var copy = !!dst,\n        off = this._offset(srcStart),\n        len = srcEnd - srcStart,\n        bytes = len,\n        bufoff = copy && dstStart || 0,\n        start = off[1],\n        l,\n        i;\n\n        // copy/slice everything\n        if (srcStart === 0 && srcEnd == this.length) {\n          if (!copy) {// slice, but full concat if multiple buffers\n            return this._bufs.length === 1 ?\n            this._bufs[0] :\n            Buffer.concat(this._bufs, this.length);\n          }\n\n          // copy, need to copy individual buffers\n          for (i = 0; i < this._bufs.length; i++) {\n            this._bufs[i].copy(dst, bufoff);\n            bufoff += this._bufs[i].length;\n          }\n\n          return dst;\n        }\n\n        // easy, cheap case where it's a subset of one of the buffers\n        if (bytes <= this._bufs[off[0]].length - start) {\n          return copy ?\n          this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) :\n          this._bufs[off[0]].slice(start, start + bytes);\n        }\n\n        if (!copy) // a slice, we need something to copy in to\n          dst = Buffer.allocUnsafe(len);\n\n        for (i = off[0]; i < this._bufs.length; i++) {\n          l = this._bufs[i].length - start;\n\n          if (bytes > l) {\n            this._bufs[i].copy(dst, bufoff, start);\n          } else {\n            this._bufs[i].copy(dst, bufoff, start, start + bytes);\n            break;\n          }\n\n          bufoff += l;\n          bytes -= l;\n\n          if (start)\n          start = 0;\n        }\n\n        return dst;\n      };\n\n      BufferList.prototype.shallowSlice = function shallowSlice(start, end) {\n        start = start || 0;\n        end = end || this.length;\n\n        if (start < 0)\n        start += this.length;\n        if (end < 0)\n        end += this.length;\n\n        var startOffset = this._offset(start),\n        endOffset = this._offset(end),\n        buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);\n\n        if (endOffset[1] == 0)\n        buffers.pop();else\n\n        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);\n\n        if (startOffset[1] != 0)\n        buffers[0] = buffers[0].slice(startOffset[1]);\n\n        return new BufferList(buffers);\n      };\n\n      BufferList.prototype.toString = function toString(encoding, start, end) {\n        return this.slice(start, end).toString(encoding);\n      };\n\n      BufferList.prototype.consume = function consume(bytes) {\n        while (this._bufs.length) {\n          if (bytes >= this._bufs[0].length) {\n            bytes -= this._bufs[0].length;\n            this.length -= this._bufs[0].length;\n            this._bufs.shift();\n          } else {\n            this._bufs[0] = this._bufs[0].slice(bytes);\n            this.length -= bytes;\n            break;\n          }\n        }\n        return this;\n      };\n\n\n      BufferList.prototype.duplicate = function duplicate() {\n        var i = 0,\n        copy = new BufferList();\n\n        for (; i < this._bufs.length; i++) {\n          copy.append(this._bufs[i]);}\n\n        return copy;\n      };\n\n\n      BufferList.prototype.destroy = function destroy() {\n        this._bufs.length = 0;\n        this.length = 0;\n        this.push(null);\n      };\n\n\n      (function () {\n        var methods = {\n          'readDoubleBE': 8,\n          'readDoubleLE': 8,\n          'readFloatBE': 4,\n          'readFloatLE': 4,\n          'readInt32BE': 4,\n          'readInt32LE': 4,\n          'readUInt32BE': 4,\n          'readUInt32LE': 4,\n          'readInt16BE': 2,\n          'readInt16LE': 2,\n          'readUInt16BE': 2,\n          'readUInt16LE': 2,\n          'readInt8': 1,\n          'readUInt8': 1 };\n\n\n        for (var m in methods) {\n          (function (m) {\n            BufferList.prototype[m] = function (offset) {\n              return this.slice(offset, offset + methods[m])[m](0);\n            };\n          })(m);\n        }\n      })();\n\n\n      module.exports = BufferList;\n\n    }, { \"readable-stream/duplex\": 97, \"safe-buffer\": 110, \"util\": 117 }], 86: [function (require, module, exports) {\n      'use strict';\n\n      var Buffer = require('safe-buffer').Buffer;\n      var max = 65536;\n      var cache = {};\n\n      function generateBuffer(i) {\n        var buffer = Buffer.allocUnsafe(2);\n        buffer.writeUInt8(i >> 8, 0);\n        buffer.writeUInt8(i & 0x00FF, 0 + 1);\n\n        return buffer;\n      }\n\n      function generateCache() {\n        for (var i = 0; i < max; i++) {\n          cache[i] = generateBuffer(i);\n        }\n      }\n\n      /**\n         * calcVariableByteIntLength - calculate the variable byte integer\n         * length field\n         *\n         * @api private\n         */\n      function calcVariableByteIntLength(length) {\n        if (length >= 0 && length < 128) return 1;else\n        if (length >= 128 && length < 16384) return 2;else\n        if (length >= 16384 && length < 2097152) return 3;else\n        if (length >= 2097152 && length < 268435456) return 4;else\n        return 0;\n      }\n\n      function genBufVariableByteInt(num) {\n        var digit = 0;\n        var pos = 0;\n        var length = calcVariableByteIntLength(num);\n        var buffer = Buffer.allocUnsafe(length);\n\n        do {\n          digit = num % 128 | 0;\n          num = num / 128 | 0;\n          if (num > 0) digit = digit | 0x80;\n\n          buffer.writeUInt8(digit, pos++);\n        } while (num > 0);\n\n        return {\n          data: buffer,\n          length: length };\n\n      }\n\n      function generate4ByteBuffer(num) {\n        var buffer = Buffer.allocUnsafe(4);\n        buffer.writeUInt32BE(num, 0);\n        return buffer;\n      }\n\n      module.exports = {\n        cache: cache,\n        generateCache: generateCache,\n        generateNumber: generateBuffer,\n        genBufVariableByteInt: genBufVariableByteInt,\n        generate4ByteBuffer: generate4ByteBuffer };\n\n\n    }, { \"safe-buffer\": 110 }], 87: [function (require, module, exports) {\n\n      function Packet() {\n        this.cmd = null;\n        this.retain = false;\n        this.qos = 0;\n        this.dup = false;\n        this.length = -1;\n        this.topic = null;\n        this.payload = null;\n      }\n\n      module.exports = Packet;\n\n    }, {}], 88: [function (require, module, exports) {\n      'use strict';\n\n      var bl = require('bl');\n      var inherits = require('inherits');\n      var EE = require('events').EventEmitter;\n      var Packet = require('./packet');\n      var constants = require('./constants');\n\n      function Parser(opt) {\n        if (!(this instanceof Parser)) return new Parser(opt);\n\n        this.settings = opt || {};\n\n        this._states = [\n        '_parseHeader',\n        '_parseLength',\n        '_parsePayload',\n        '_newPacket'];\n\n\n        this._resetState();\n      }\n\n      inherits(Parser, EE);\n\n      Parser.prototype._resetState = function () {\n        this.packet = new Packet();\n        this.error = null;\n        this._list = bl();\n        this._stateCounter = 0;\n      };\n\n      Parser.prototype.parse = function (buf) {\n        if (this.error) this._resetState();\n\n        this._list.append(buf);\n\n        while ((this.packet.length !== -1 || this._list.length > 0) &&\n        this[this._states[this._stateCounter]]() &&\n        !this.error) {\n          this._stateCounter++;\n\n          if (this._stateCounter >= this._states.length) this._stateCounter = 0;\n        }\n\n        return this._list.length;\n      };\n\n      Parser.prototype._parseHeader = function () {\n        // There is at least one byte in the buffer\n        var zero = this._list.readUInt8(0);\n        this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT];\n        this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;\n        this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;\n        this.packet.dup = (zero & constants.DUP_MASK) !== 0;\n\n        this._list.consume(1);\n\n        return true;\n      };\n\n      Parser.prototype._parseLength = function () {\n        // There is at least one byte in the list\n        var result = this._parseVarByteNum(true);\n\n        if (result) {\n          this.packet.length = result.value;\n          this._list.consume(result.bytes);\n        }\n\n        return !!result;\n      };\n\n      Parser.prototype._parsePayload = function () {\n        var result = false;\n\n        // Do we have a payload? Do we have enough data to complete the payload?\n        // PINGs have no payload\n        if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n          this._pos = 0;\n\n          switch (this.packet.cmd) {\n            case 'connect':\n              this._parseConnect();\n              break;\n            case 'connack':\n              this._parseConnack();\n              break;\n            case 'publish':\n              this._parsePublish();\n              break;\n            case 'puback':\n            case 'pubrec':\n            case 'pubrel':\n            case 'pubcomp':\n              this._parseConfirmation();\n              break;\n            case 'subscribe':\n              this._parseSubscribe();\n              break;\n            case 'suback':\n              this._parseSuback();\n              break;\n            case 'unsubscribe':\n              this._parseUnsubscribe();\n              break;\n            case 'unsuback':\n              this._parseUnsuback();\n              break;\n            case 'pingreq':\n            case 'pingresp':\n              // These are empty, nothing to do\n              break;\n            case 'disconnect':\n              this._parseDisconnect();\n              break;\n            case 'auth':\n              this._parseAuth();\n              break;\n            default:\n              this._emitError(new Error('Not supported'));}\n\n\n          result = true;\n        }\n\n        return result;\n      };\n\n      Parser.prototype._parseConnect = function () {\n        var protocolId; // Protocol ID\n        var clientId; // Client ID\n        var topic; // Will topic\n        var payload; // Will payload\n        var password; // Password\n        var username; // Username\n        var flags = {};\n        var packet = this.packet;\n\n        // Parse protocolId\n        protocolId = this._parseString();\n\n        if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'));\n        if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n          return this._emitError(new Error('Invalid protocolId'));\n        }\n\n        packet.protocolId = protocolId;\n\n        // Parse constants version number\n        if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'));\n\n        packet.protocolVersion = this._list.readUInt8(this._pos);\n\n        if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n          return this._emitError(new Error('Invalid protocol version'));\n        }\n\n        this._pos++;\n\n        if (this._pos >= this._list.length) {\n          return this._emitError(new Error('Packet too short'));\n        }\n\n        // Parse connect flags\n        flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;\n        flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;\n        flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;\n\n        if (flags.will) {\n          packet.will = {};\n          packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0;\n          packet.will.qos = (this._list.readUInt8(this._pos) &\n          constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;\n        }\n\n        packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;\n        this._pos++;\n\n        // Parse keepalive\n        packet.keepalive = this._parseNum();\n        if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'));\n\n        // parse properties\n        if (packet.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n        // Parse clientId\n        clientId = this._parseString();\n        if (clientId === null) return this._emitError(new Error('Packet too short'));\n        packet.clientId = clientId;\n\n        if (flags.will) {\n          if (packet.protocolVersion === 5) {\n            var willProperties = this._parseProperties();\n            if (Object.getOwnPropertyNames(willProperties).length) {\n              packet.will.properties = willProperties;\n            }\n          }\n          // Parse will topic\n          topic = this._parseString();\n          if (topic === null) return this._emitError(new Error('Cannot parse will topic'));\n          packet.will.topic = topic;\n\n          // Parse will payload\n          payload = this._parseBuffer();\n          if (payload === null) return this._emitError(new Error('Cannot parse will payload'));\n          packet.will.payload = payload;\n        }\n\n        // Parse username\n        if (flags.username) {\n          username = this._parseString();\n          if (username === null) return this._emitError(new Error('Cannot parse username'));\n          packet.username = username;\n        }\n\n        // Parse password\n        if (flags.password) {\n          password = this._parseBuffer();\n          if (password === null) return this._emitError(new Error('Cannot parse password'));\n          packet.password = password;\n        }\n        // need for right parse auth packet and self set up\n        this.settings = packet;\n\n        return packet;\n      };\n\n      Parser.prototype._parseConnack = function () {\n        var packet = this.packet;\n\n        if (this._list.length < 2) return null;\n\n        packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK);\n        if (this.settings.protocolVersion === 5) {\n          packet.reasonCode = this._list.readUInt8(this._pos++);\n        } else {\n          packet.returnCode = this._list.readUInt8(this._pos++);\n        }\n\n        if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'));\n        // mqtt 5 properties\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n      };\n\n      Parser.prototype._parsePublish = function () {\n        var packet = this.packet;\n        packet.topic = this._parseString();\n\n        if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'));\n\n        // Parse messageId\n        if (packet.qos > 0) if (!this._parseMessageId()) {return;}\n\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n\n        packet.payload = this._list.slice(this._pos, packet.length);\n      };\n\n      Parser.prototype._parseSubscribe = function () {\n        var packet = this.packet;\n        var topic;\n        var options;\n        var qos;\n        var rh;\n        var rap;\n        var nl;\n        var subscription;\n\n        if (packet.qos !== 1) {\n          return this._emitError(new Error('Wrong subscribe header'));\n        }\n\n        packet.subscriptions = [];\n\n        if (!this._parseMessageId()) {return;}\n\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n\n        while (this._pos < packet.length) {\n          // Parse topic\n          topic = this._parseString();\n          if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n\n          options = this._parseByte();\n          qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;\n          nl = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;\n          rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;\n          rh = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;\n\n          subscription = { topic: topic, qos: qos };\n\n          // mqtt 5 options\n          if (this.settings.protocolVersion === 5) {\n            subscription.nl = nl;\n            subscription.rap = rap;\n            subscription.rh = rh;\n          }\n\n          // Push pair to subscriptions\n          packet.subscriptions.push(subscription);\n        }\n      };\n\n      Parser.prototype._parseSuback = function () {\n        var packet = this.packet;\n        this.packet.granted = [];\n\n        if (!this._parseMessageId()) {return;}\n\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n\n        // Parse granted QoSes\n        while (this._pos < this.packet.length) {\n          this.packet.granted.push(this._list.readUInt8(this._pos++));\n        }\n      };\n\n      Parser.prototype._parseUnsubscribe = function () {\n        var packet = this.packet;\n\n        packet.unsubscriptions = [];\n\n        // Parse messageId\n        if (!this._parseMessageId()) {return;}\n\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n\n        while (this._pos < packet.length) {\n          var topic;\n\n          // Parse topic\n          topic = this._parseString();\n          if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n\n          // Push topic to unsubscriptions\n          packet.unsubscriptions.push(topic);\n        }\n      };\n\n      Parser.prototype._parseUnsuback = function () {\n        var packet = this.packet;\n        if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'));\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n          // Parse granted QoSes\n          packet.granted = [];\n          while (this._pos < this.packet.length) {\n            this.packet.granted.push(this._list.readUInt8(this._pos++));\n          }\n        }\n      };\n\n      // parse packets like puback, pubrec, pubrel, pubcomp\n      Parser.prototype._parseConfirmation = function () {\n        var packet = this.packet;\n\n        this._parseMessageId();\n\n        if (this.settings.protocolVersion === 5) {\n          if (packet.length > 2) {\n            // response code\n            packet.reasonCode = this._parseByte();\n            // properies mqtt 5\n            var properties = this._parseProperties();\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n        }\n\n        return true;\n      };\n\n      // parse disconnect packet\n      Parser.prototype._parseDisconnect = function () {\n        var packet = this.packet;\n\n        if (this.settings.protocolVersion === 5) {\n          // response code\n          packet.reasonCode = this._parseByte();\n          // properies mqtt 5\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n\n        return true;\n      };\n\n      // parse auth packet\n      Parser.prototype._parseAuth = function () {\n        var packet = this.packet;\n\n        if (this.settings.protocolVersion !== 5) {\n          return this._emitError(new Error('Not supported auth packet for this version MQTT'));\n        }\n\n        // response code\n        packet.reasonCode = this._parseByte();\n        // properies mqtt 5\n        var properties = this._parseProperties();\n        if (Object.getOwnPropertyNames(properties).length) {\n          packet.properties = properties;\n        }\n\n        return true;\n      };\n\n      Parser.prototype._parseMessageId = function () {\n        var packet = this.packet;\n\n        packet.messageId = this._parseNum();\n\n        if (packet.messageId === null) {\n          this._emitError(new Error('Cannot parse messageId'));\n          return false;\n        }\n\n        return true;\n      };\n\n      Parser.prototype._parseString = function (maybeBuffer) {\n        var length = this._parseNum();\n        var result;\n        var end = length + this._pos;\n\n        if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n\n        result = this._list.toString('utf8', this._pos, end);\n        this._pos += length;\n\n        return result;\n      };\n\n      Parser.prototype._parseStringPair = function () {\n        return {\n          name: this._parseString(),\n          value: this._parseString() };\n\n      };\n\n      Parser.prototype._parseBuffer = function () {\n        var length = this._parseNum();\n        var result;\n        var end = length + this._pos;\n\n        if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n\n        result = this._list.slice(this._pos, end);\n\n        this._pos += length;\n\n        return result;\n      };\n\n      Parser.prototype._parseNum = function () {\n        if (this._list.length - this._pos < 2) return -1;\n\n        var result = this._list.readUInt16BE(this._pos);\n        this._pos += 2;\n\n        return result;\n      };\n\n      Parser.prototype._parse4ByteNum = function () {\n        if (this._list.length - this._pos < 4) return -1;\n\n        var result = this._list.readUInt32BE(this._pos);\n        this._pos += 4;\n\n        return result;\n      };\n\n      Parser.prototype._parseVarByteNum = function (fullInfoFlag) {\n        var bytes = 0;\n        var mul = 1;\n        var length = 0;\n        var result = true;\n        var current;\n        var padding = this._pos ? this._pos : 0;\n\n        while (bytes < 5) {\n          current = this._list.readUInt8(padding + bytes++);\n          length += mul * (current & constants.LENGTH_MASK);\n          mul *= 0x80;\n\n          if ((current & constants.LENGTH_FIN_MASK) === 0) break;\n          if (this._list.length <= bytes) {\n            result = false;\n            break;\n          }\n        }\n\n        if (padding) {\n          this._pos += bytes;\n        }\n\n        result = result ?\n        fullInfoFlag ? {\n          bytes: bytes,\n          value: length } :\n        length :\n        false;\n\n        return result;\n      };\n\n      Parser.prototype._parseByte = function () {\n        var result = this._list.readUInt8(this._pos);\n        this._pos++;\n        return result;\n      };\n\n      Parser.prototype._parseByType = function (type) {\n        switch (type) {\n          case 'byte':{\n              return this._parseByte() !== 0;\n            }\n          case 'int8':{\n              return this._parseByte();\n            }\n          case 'int16':{\n              return this._parseNum();\n            }\n          case 'int32':{\n              return this._parse4ByteNum();\n            }\n          case 'var':{\n              return this._parseVarByteNum();\n            }\n          case 'string':{\n              return this._parseString();\n            }\n          case 'pair':{\n              return this._parseStringPair();\n            }\n          case 'binary':{\n              return this._parseBuffer();\n            }}\n\n      };\n\n      Parser.prototype._parseProperties = function () {\n        var length = this._parseVarByteNum();\n        var start = this._pos;\n        var end = start + length;\n        var result = {};\n        while (this._pos < end) {\n          var type = this._parseByte();\n          var name = constants.propertiesCodes[type];\n          if (!name) {\n            this._emitError(new Error('Unknown property'));\n            return false;\n          }\n          // user properties process\n          if (name === 'userProperties') {\n            if (!result[name]) {\n              result[name] = {};\n            }\n            var currentUserProperty = this._parseByType(constants.propertiesTypes[name]);\n            result[name][currentUserProperty.name] = currentUserProperty.value;\n            continue;\n          }\n          result[name] = this._parseByType(constants.propertiesTypes[name]);\n        }\n        return result;\n      };\n\n      Parser.prototype._newPacket = function () {\n        if (this.packet) {\n          this._list.consume(this.packet.length);\n          this.emit('packet', this.packet);\n        }\n\n        this.packet = new Packet();\n\n        this._pos = 0;\n\n        return true;\n      };\n\n      Parser.prototype._emitError = function (err) {\n        this.error = err;\n        this.emit('error', err);\n      };\n\n      module.exports = Parser;\n\n    }, { \"./constants\": 82, \"./packet\": 87, \"bl\": 85, \"events\": 13, \"inherits\": 80 }], 89: [function (require, module, exports) {\n      'use strict';\n\n      var protocol = require('./constants');\n      var Buffer = require('safe-buffer').Buffer;\n      var empty = Buffer.allocUnsafe(0);\n      var zeroBuf = Buffer.from([0]);\n      var numbers = require('./numbers');\n      var nextTick = require('process-nextick-args').nextTick;\n\n      var numCache = numbers.cache;\n      var generateNumber = numbers.generateNumber;\n      var generateCache = numbers.generateCache;\n      var genBufVariableByteInt = numbers.genBufVariableByteInt;\n      var generate4ByteBuffer = numbers.generate4ByteBuffer;\n      var writeNumber = writeNumberCached;\n      var toGenerate = true;\n\n      function generate(packet, stream, opts) {\n        if (stream.cork) {\n          stream.cork();\n          nextTick(uncork, stream);\n        }\n\n        if (toGenerate) {\n          toGenerate = false;\n          generateCache();\n        }\n\n        switch (packet.cmd) {\n          case 'connect':\n            return connect(packet, stream, opts);\n          case 'connack':\n            return connack(packet, stream, opts);\n          case 'publish':\n            return publish(packet, stream, opts);\n          case 'puback':\n          case 'pubrec':\n          case 'pubrel':\n          case 'pubcomp':\n            return confirmation(packet, stream, opts);\n          case 'subscribe':\n            return subscribe(packet, stream, opts);\n          case 'suback':\n            return suback(packet, stream, opts);\n          case 'unsubscribe':\n            return unsubscribe(packet, stream, opts);\n          case 'unsuback':\n            return unsuback(packet, stream, opts);\n          case 'pingreq':\n          case 'pingresp':\n            return emptyPacket(packet, stream, opts);\n          case 'disconnect':\n            return disconnect(packet, stream, opts);\n          case 'auth':\n            return auth(packet, stream, opts);\n          default:\n            stream.emit('error', new Error('Unknown command'));\n            return false;}\n\n      }\n      /**\n         * Controls numbers cache.\n         * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n         */\n      Object.defineProperty(generate, 'cacheNumbers', {\n        get: function get() {\n          return writeNumber === writeNumberCached;\n        },\n        set: function set(value) {\n          if (value) {\n            if (!numCache || Object.keys(numCache).length === 0) toGenerate = true;\n            writeNumber = writeNumberCached;\n          } else {\n            toGenerate = false;\n            writeNumber = writeNumberGenerated;\n          }\n        } });\n\n\n      function uncork(stream) {\n        stream.uncork();\n      }\n\n      function connect(packet, stream, opts) {\n        var settings = packet || {};\n        var protocolId = settings.protocolId || 'MQTT';\n        var protocolVersion = settings.protocolVersion || 4;\n        var will = settings.will;\n        var clean = settings.clean;\n        var keepalive = settings.keepalive || 0;\n        var clientId = settings.clientId || '';\n        var username = settings.username;\n        var password = settings.password;\n        /* mqtt5 new oprions */\n        var properties = settings.properties;\n\n        if (clean === undefined) clean = true;\n\n        var length = 0;\n\n        // Must be a string and non-falsy\n        if (!protocolId ||\n        typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId)) {\n          stream.emit('error', new Error('Invalid protocolId'));\n          return false;\n        } else length += protocolId.length + 2;\n\n        // Must be 3 or 4 or 5\n        if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n          stream.emit('error', new Error('Invalid protocol version'));\n          return false;\n        } else length += 1;\n\n        // ClientId might be omitted in 3.1.1, but only if cleanSession is set to 1\n        if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) && (\n        clientId || protocolVersion === 4) && (clientId || clean)) {\n          length += clientId.length + 2;\n        } else {\n          if (protocolVersion < 4) {\n            stream.emit('error', new Error('clientId must be supplied before 3.1.1'));\n            return false;\n          }\n          if (clean * 1 === 0) {\n            stream.emit('error', new Error('clientId must be given if cleanSession set to 0'));\n            return false;\n          }\n        }\n\n        // Must be a two byte number\n        if (typeof keepalive !== 'number' ||\n        keepalive < 0 ||\n        keepalive > 65535 ||\n        keepalive % 1 !== 0) {\n          stream.emit('error', new Error('Invalid keepalive'));\n          return false;\n        } else length += 2;\n\n        // Connect flags\n        length += 1;\n\n        // Properties\n        if (protocolVersion === 5) {\n          var propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        // If will exists...\n        if (will) {\n          // It must be an object\n          if (typeof will !== 'object') {\n            stream.emit('error', new Error('Invalid will'));\n            return false;\n          }\n          // It must have topic typeof string\n          if (!will.topic || typeof will.topic !== 'string') {\n            stream.emit('error', new Error('Invalid will topic'));\n            return false;\n          } else {\n            length += Buffer.byteLength(will.topic) + 2;\n          }\n\n          // Payload\n          if (will.payload) {\n            if (will.payload.length >= 0) {\n              if (typeof will.payload === 'string') {\n                length += Buffer.byteLength(will.payload) + 2;\n              } else {\n                length += will.payload.length + 2;\n              }\n            } else {\n              stream.emit('error', new Error('Invalid will payload'));\n              return false;\n            }\n\n            // will properties\n            var willProperties = {};\n            if (protocolVersion === 5) {\n              willProperties = getProperties(stream, will.properties);\n              length += willProperties.length;\n            }\n          }\n        }\n\n        // Username\n        var providedUsername = false;\n        if (username != null) {\n          if (isStringOrBuffer(username)) {\n            providedUsername = true;\n            length += Buffer.byteLength(username) + 2;\n          } else {\n            stream.emit('error', new Error('Invalid username'));\n            return false;\n          }\n        }\n\n        // Password\n        if (password != null) {\n          if (!providedUsername) {\n            stream.emit('error', new Error('Username is required to use password'));\n            return false;\n          }\n\n          if (isStringOrBuffer(password)) {\n            length += byteLength(password) + 2;\n          } else {\n            stream.emit('error', new Error('Invalid password'));\n            return false;\n          }\n        }\n\n        // Generate header\n        stream.write(protocol.CONNECT_HEADER);\n\n        // Generate length\n        writeVarByteInt(stream, length);\n\n        // Generate protocol ID\n        writeStringOrBuffer(stream, protocolId);\n        stream.write(\n        protocolVersion === 4 ?\n        protocol.VERSION4 :\n        protocolVersion === 5 ?\n        protocol.VERSION5 :\n        protocol.VERSION3);\n\n\n        // Connect flags\n        var flags = 0;\n        flags |= username != null ? protocol.USERNAME_MASK : 0;\n        flags |= password != null ? protocol.PASSWORD_MASK : 0;\n        flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;\n        flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;\n        flags |= will ? protocol.WILL_FLAG_MASK : 0;\n        flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;\n\n        stream.write(Buffer.from([flags]));\n\n        // Keepalive\n        writeNumber(stream, keepalive);\n\n        // Properties\n        if (protocolVersion === 5) {\n          propertiesData.write();\n        }\n\n        // Client ID\n        writeStringOrBuffer(stream, clientId);\n\n        // Will\n        if (will) {\n          if (protocolVersion === 5) {\n            willProperties.write();\n          }\n          writeString(stream, will.topic);\n          writeStringOrBuffer(stream, will.payload);\n        }\n\n        // Username and password\n        if (username != null) {\n          writeStringOrBuffer(stream, username);\n        }\n        if (password != null) {\n          writeStringOrBuffer(stream, password);\n        }\n        // This is a small packet that happens only once on a stream\n        // We assume the stream is always free to receive more data after this\n        return true;\n      }\n\n      function connack(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var rc = version === 5 ? settings.reasonCode : settings.returnCode;\n        var properties = settings.properties;\n        var length = 2; // length of rc and sessionHeader\n\n        // Check return code\n        if (typeof rc !== 'number') {\n          stream.emit('error', new Error('Invalid return code'));\n          return false;\n        }\n        // mqtt5 properties\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        stream.write(protocol.CONNACK_HEADER);\n        // length\n        writeVarByteInt(stream, length);\n        stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);\n\n        stream.write(Buffer.from([rc]));\n        if (propertiesData != null) {\n          propertiesData.write();\n        }\n        return true;\n      }\n\n      function publish(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var qos = settings.qos || 0;\n        var retain = settings.retain ? protocol.RETAIN_MASK : 0;\n        var topic = settings.topic;\n        var payload = settings.payload || empty;\n        var id = settings.messageId;\n        var properties = settings.properties;\n\n        var length = 0;\n\n        // Topic must be a non-empty string or Buffer\n        if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2;else\n        if (Buffer.isBuffer(topic)) length += topic.length + 2;else\n        {\n          stream.emit('error', new Error('Invalid topic'));\n          return false;\n        }\n\n        // Get the payload length\n        if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload);else\n        length += payload.length;\n\n        // Message ID must a number if qos > 0\n        if (qos && typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        } else if (qos) length += 2;\n\n        // mqtt5 properties\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]);\n\n        // Remaining length\n        writeVarByteInt(stream, length);\n\n        // Topic\n        writeNumber(stream, byteLength(topic));\n        stream.write(topic);\n\n        // Message ID\n        if (qos > 0) writeNumber(stream, id);\n\n        // Properties\n        if (propertiesData != null) {\n          propertiesData.write();\n        }\n\n        // Payload\n        return stream.write(payload);\n      }\n\n      /* Puback, pubrec, pubrel and pubcomp */\n      function confirmation(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var type = settings.cmd || 'puback';\n        var id = settings.messageId;\n        var dup = settings.dup && type === 'pubrel' ? protocol.DUP_MASK : 0;\n        var qos = 0;\n        var reasonCode = settings.reasonCode;\n        var properties = settings.properties;\n        var length = version === 5 ? 3 : 2;\n\n        if (type === 'pubrel') qos = 1;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        }\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n          if (!propertiesData) {return false;}\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(protocol.ACKS[type][qos][dup][0]);\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // Message ID\n        writeNumber(stream, id);\n\n        // reason code in header\n        if (version === 5) {\n          stream.write(Buffer.from([reasonCode]));\n        }\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n        return true;\n      }\n\n      function subscribe(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var dup = settings.dup ? protocol.DUP_MASK : 0;\n        var id = settings.messageId;\n        var subs = settings.subscriptions;\n        var properties = settings.properties;\n\n        var length = 0;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        } else length += 2;\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        // Check subscriptions\n        if (typeof subs === 'object' && subs.length) {\n          for (var i = 0; i < subs.length; i += 1) {\n            var itopic = subs[i].topic;\n            var iqos = subs[i].qos;\n\n            if (typeof itopic !== 'string') {\n              stream.emit('error', new Error('Invalid subscriptions - invalid topic'));\n              return false;\n            }\n            if (typeof iqos !== 'number') {\n              stream.emit('error', new Error('Invalid subscriptions - invalid qos'));\n              return false;\n            }\n\n            if (version === 5) {\n              var nl = subs[i].nl || false;\n              if (typeof nl !== 'boolean') {\n                stream.emit('error', new Error('Invalid subscriptions - invalid No Local'));\n                return false;\n              }\n              var rap = subs[i].rap || false;\n              if (typeof rap !== 'boolean') {\n                stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'));\n                return false;\n              }\n              var rh = subs[i].rh || 0;\n              if (typeof rh !== 'number' || rh > 2) {\n                stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'));\n                return false;\n              }\n            }\n\n            length += Buffer.byteLength(itopic) + 2 + 1;\n          }\n        } else {\n          stream.emit('error', new Error('Invalid subscriptions'));\n          return false;\n        }\n\n        // Generate header\n        stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);\n\n        // Generate length\n        writeVarByteInt(stream, length);\n\n        // Generate message ID\n        writeNumber(stream, id);\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n\n        var result = true;\n\n        // Generate subs\n        for (var j = 0; j < subs.length; j++) {\n          var sub = subs[j];\n          var jtopic = sub.topic;\n          var jqos = sub.qos;\n          var jnl = +sub.nl;\n          var jrap = +sub.rap;\n          var jrh = sub.rh;\n          var joptions;\n\n          // Write topic string\n          writeString(stream, jtopic);\n\n          // options process\n          joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];\n          if (version === 5) {\n            joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;\n            joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;\n            joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;\n          }\n          // Write options\n          result = stream.write(Buffer.from([joptions]));\n        }\n\n        return result;\n      }\n\n      function suback(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var id = settings.messageId;\n        var granted = settings.granted;\n        var properties = settings.properties;\n        var length = 0;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        } else length += 2;\n\n        // Check granted qos vector\n        if (typeof granted === 'object' && granted.length) {\n          for (var i = 0; i < granted.length; i += 1) {\n            if (typeof granted[i] !== 'number') {\n              stream.emit('error', new Error('Invalid qos vector'));\n              return false;\n            }\n            length += 1;\n          }\n        } else {\n          stream.emit('error', new Error('Invalid qos vector'));\n          return false;\n        }\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n          if (!propertiesData) {return false;}\n          length += propertiesData.length;\n        }\n\n        // header\n        stream.write(protocol.SUBACK_HEADER);\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // Message ID\n        writeNumber(stream, id);\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n\n        return stream.write(Buffer.from(granted));\n      }\n\n      function unsubscribe(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var id = settings.messageId;\n        var dup = settings.dup ? protocol.DUP_MASK : 0;\n        var unsubs = settings.unsubscriptions;\n        var properties = settings.properties;\n\n        var length = 0;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        } else {\n          length += 2;\n        }\n        // Check unsubs\n        if (typeof unsubs === 'object' && unsubs.length) {\n          for (var i = 0; i < unsubs.length; i += 1) {\n            if (typeof unsubs[i] !== 'string') {\n              stream.emit('error', new Error('Invalid unsubscriptions'));\n              return false;\n            }\n            length += Buffer.byteLength(unsubs[i]) + 2;\n          }\n        } else {\n          stream.emit('error', new Error('Invalid unsubscriptions'));\n          return false;\n        }\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // Message ID\n        writeNumber(stream, id);\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n\n        // Unsubs\n        var result = true;\n        for (var j = 0; j < unsubs.length; j++) {\n          result = writeString(stream, unsubs[j]);\n        }\n\n        return result;\n      }\n\n      function unsuback(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var id = settings.messageId;\n        var dup = settings.dup ? protocol.DUP_MASK : 0;\n        var granted = settings.granted;\n        var properties = settings.properties;\n        var type = settings.cmd;\n        var qos = 0;\n\n        var length = 2;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        }\n\n        // Check granted\n        if (version === 5) {\n          if (typeof granted === 'object' && granted.length) {\n            for (var i = 0; i < granted.length; i += 1) {\n              if (typeof granted[i] !== 'number') {\n                stream.emit('error', new Error('Invalid qos vector'));\n                return false;\n              }\n              length += 1;\n            }\n          } else {\n            stream.emit('error', new Error('Invalid qos vector'));\n            return false;\n          }\n        }\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n          if (!propertiesData) {return false;}\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(protocol.ACKS[type][qos][dup][0]);\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // Message ID\n        writeNumber(stream, id);\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n\n        // payload\n        if (version === 5) {\n          stream.write(Buffer.from(granted));\n        }\n        return true;\n      }\n\n      function emptyPacket(packet, stream, opts) {\n        return stream.write(protocol.EMPTY[packet.cmd]);\n      }\n\n      function disconnect(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var reasonCode = settings.reasonCode;\n        var properties = settings.properties;\n        var length = version === 5 ? 1 : 0;\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n          if (!propertiesData) {return false;}\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(Buffer.from([protocol.codes['disconnect'] << 4]));\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // reason code in header\n        if (version === 5) {\n          stream.write(Buffer.from([reasonCode]));\n        }\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n\n        return true;\n      }\n\n      function auth(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var reasonCode = settings.reasonCode;\n        var properties = settings.properties;\n        var length = version === 5 ? 1 : 0;\n\n        if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet'));\n\n        // properies mqtt 5\n        var propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n        if (!propertiesData) {return false;}\n        length += propertiesData.length;\n\n        // Header\n        stream.write(Buffer.from([protocol.codes['auth'] << 4]));\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // reason code in header\n        stream.write(Buffer.from([reasonCode]));\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n        return true;\n      }\n\n      /**\n         * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n         *\n         * @param <Buffer> buffer - destination\n         * @param <Number> pos - offset\n         * @param <Number> length - length (>0)\n         * @returns <Number> number of bytes written\n         *\n         * @api private\n         */\n\n      var varByteIntCache = {};\n      function writeVarByteInt(stream, num) {\n        var buffer = varByteIntCache[num];\n\n        if (!buffer) {\n          buffer = genBufVariableByteInt(num).data;\n          if (num < 16384) varByteIntCache[num] = buffer;\n        }\n\n        stream.write(buffer);\n      }\n\n      /**\n         * writeString - write a utf8 string to the buffer\n         *\n         * @param <Buffer> buffer - destination\n         * @param <Number> pos - offset\n         * @param <String> string - string to write\n         * @return <Number> number of bytes written\n         *\n         * @api private\n         */\n\n      function writeString(stream, string) {\n        var strlen = Buffer.byteLength(string);\n        writeNumber(stream, strlen);\n\n        stream.write(string, 'utf8');\n      }\n\n      /**\n         * writeStringPair - write a utf8 string pairs to the buffer\n         *\n         * @param <Buffer> buffer - destination\n         * @param <String> name - string name to write\n         * @param <String> value - string value to write\n         * @return <Number> number of bytes written\n         *\n         * @api private\n         */\n      function writeStringPair(stream, name, value) {\n        writeString(stream, name);\n        writeString(stream, value);\n      }\n\n      /**\n         * writeNumber - write a two byte number to the buffer\n         *\n         * @param <Buffer> buffer - destination\n         * @param <Number> pos - offset\n         * @param <String> number - number to write\n         * @return <Number> number of bytes written\n         *\n         * @api private\n         */\n      function writeNumberCached(stream, number) {\n        return stream.write(numCache[number]);\n      }\n      function writeNumberGenerated(stream, number) {\n        return stream.write(generateNumber(number));\n      }\n      function write4ByteNumber(stream, number) {\n        return stream.write(generate4ByteBuffer(number));\n      }\n      /**\n         * writeStringOrBuffer - write a String or Buffer with the its length prefix\n         *\n         * @param <Buffer> buffer - destination\n         * @param <Number> pos - offset\n         * @param <String> toWrite - String or Buffer\n         * @return <Number> number of bytes written\n         */\n      function writeStringOrBuffer(stream, toWrite) {\n        if (typeof toWrite === 'string') {\n          writeString(stream, toWrite);\n        } else if (toWrite) {\n          writeNumber(stream, toWrite.length);\n          stream.write(toWrite);\n        } else writeNumber(stream, 0);\n      }\n\n      function getProperties(stream, properties) {\n        /* connect properties */\n        if (typeof properties !== 'object' || properties.length != null) {\n          return {\n            length: 1,\n            write: function write() {\n              writeProperties(stream, {}, 0);\n            } };\n\n        }\n        var propertiesLength = 0;\n        function getLengthProperty(name) {\n          var type = protocol.propertiesTypes[name];\n          var value = properties[name];\n          var length = 0;\n          switch (type) {\n            case 'byte':{\n                if (typeof value !== 'boolean') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 1;\n                break;\n              }\n            case 'int8':{\n                if (typeof value !== 'number') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 1;\n                break;\n              }\n            case 'binary':{\n                if (value && value === null) {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + Buffer.byteLength(value) + 2;\n                break;\n              }\n            case 'int16':{\n                if (typeof value !== 'number') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 2;\n                break;\n              }\n            case 'int32':{\n                if (typeof value !== 'number') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 4;\n                break;\n              }\n            case 'var':{\n                if (typeof value !== 'number') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + genBufVariableByteInt(value).length;\n                break;\n              }\n            case 'string':{\n                if (typeof value !== 'string') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 2 + Buffer.byteLength(value.toString());\n                break;\n              }\n            case 'pair':{\n                if (typeof value !== 'object') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += Object.getOwnPropertyNames(value).reduce(function (result, name) {\n                  result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString());\n                  return result;\n                }, 0);\n                break;\n              }\n            default:{\n                stream.emit('error', new Error('Invalid property ' + name));\n                return false;\n              }}\n\n          return length;\n        }\n        if (properties) {\n          for (var propName in properties) {\n            var propLength = getLengthProperty(propName);\n            if (!propLength) return false;\n            propertiesLength += propLength;\n          }\n        }\n        var propertiesLengthLength = genBufVariableByteInt(propertiesLength).length;\n\n        return {\n          length: propertiesLengthLength + propertiesLength,\n          write: function write() {\n            writeProperties(stream, properties, propertiesLength);\n          } };\n\n      }\n\n      function getPropertiesByMaximumPacketSize(stream, properties, opts, length) {\n        var mayEmptyProps = ['reasonString', 'userProperties'];\n        var maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;\n\n        var propertiesData = getProperties(stream, properties);\n        if (maximumPacketSize) {\n          while (length + propertiesData.length > maximumPacketSize) {\n            var currentMayEmptyProp = mayEmptyProps.shift();\n            if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n              delete properties[currentMayEmptyProp];\n              propertiesData = getProperties(stream, properties);\n            } else {\n              return false;\n            }\n          }\n        }\n        return propertiesData;\n      }\n\n      function writeProperties(stream, properties, propertiesLength) {\n        /* write properties to stream */\n        writeVarByteInt(stream, propertiesLength);\n        for (var propName in properties) {\n          if (properties.hasOwnProperty(propName) && properties[propName] !== null) {\n            var value = properties[propName];\n            var type = protocol.propertiesTypes[propName];\n            switch (type) {\n              case 'byte':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  stream.write(Buffer.from([+value]));\n                  break;\n                }\n              case 'int8':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  stream.write(Buffer.from([value]));\n                  break;\n                }\n              case 'binary':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeStringOrBuffer(stream, value);\n                  break;\n                }\n              case 'int16':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeNumber(stream, value);\n                  break;\n                }\n              case 'int32':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  write4ByteNumber(stream, value);\n                  break;\n                }\n              case 'var':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeVarByteInt(stream, value);\n                  break;\n                }\n              case 'string':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeString(stream, value);\n                  break;\n                }\n              case 'pair':{\n                  Object.getOwnPropertyNames(value).forEach(function (name) {\n                    stream.write(Buffer.from([protocol.properties[propName]]));\n                    writeStringPair(stream, name.toString(), value[name].toString());\n                  });\n                  break;\n                }\n              default:{\n                  stream.emit('error', new Error('Invalid property ' + propName));\n                  return false;\n                }}\n\n          }\n        }\n      }\n\n      function byteLength(bufOrString) {\n        if (!bufOrString) return 0;else\n        if (bufOrString instanceof Buffer) return bufOrString.length;else\n        return Buffer.byteLength(bufOrString);\n      }\n\n      function isStringOrBuffer(field) {\n        return typeof field === 'string' || field instanceof Buffer;\n      }\n\n      module.exports = generate;\n\n    }, { \"./constants\": 82, \"./numbers\": 86, \"process-nextick-args\": 91, \"safe-buffer\": 110 }], 90: [function (require, module, exports) {\n      var wrappy = require('wrappy');\n      module.exports = wrappy(once);\n      module.exports.strict = wrappy(onceStrict);\n\n      once.proto = once(function () {\n        Object.defineProperty(Function.prototype, 'once', {\n          value: function value() {\n            return once(this);\n          },\n          configurable: true });\n\n\n        Object.defineProperty(Function.prototype, 'onceStrict', {\n          value: function value() {\n            return onceStrict(this);\n          },\n          configurable: true });\n\n      });\n\n      function once(fn) {\n        var f = function f() {\n          if (f.called) return f.value;\n          f.called = true;\n          return f.value = fn.apply(this, arguments);\n        };\n        f.called = false;\n        return f;\n      }\n\n      function onceStrict(fn) {\n        var f = function f() {\n          if (f.called)\n          throw new Error(f.onceError);\n          f.called = true;\n          return f.value = fn.apply(this, arguments);\n        };\n        var name = fn.name || 'Function wrapped with `once`';\n        f.onceError = name + \" shouldn't be called more than once\";\n        f.called = false;\n        return f;\n      }\n\n    }, { \"wrappy\": 120 }], 91: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        if (!process.version ||\n        process.version.indexOf('v0.') === 0 ||\n        process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n          module.exports = { nextTick: nextTick };\n        } else {\n          module.exports = process;\n        }\n\n        function nextTick(fn, arg1, arg2, arg3) {\n          if (typeof fn !== 'function') {\n            throw new TypeError('\"callback\" argument must be a function');\n          }\n          var len = arguments.length;\n          var args, i;\n          switch (len) {\n            case 0:\n            case 1:\n              return process.nextTick(fn);\n            case 2:\n              return process.nextTick(function afterTickOne() {\n                fn.call(null, arg1);\n              });\n            case 3:\n              return process.nextTick(function afterTickTwo() {\n                fn.call(null, arg1, arg2);\n              });\n            case 4:\n              return process.nextTick(function afterTickThree() {\n                fn.call(null, arg1, arg2, arg3);\n              });\n            default:\n              args = new Array(len - 1);\n              i = 0;\n              while (i < args.length) {\n                args[i++] = arguments[i];\n              }\n              return process.nextTick(function afterTick() {\n                fn.apply(null, args);\n              });}\n\n        }\n\n\n      }).call(this, require('_process'));\n    }, { \"_process\": 92 }], 92: [function (require, module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {};\n\n      // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        }\n        // if setTimeout wasn't available but was latter defined\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n\n\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        }\n        // if clearTimeout wasn't available but was latter defined\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n\n\n\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n\n      // v8 likes predictible objects\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n      process.versions = {};\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n\n      process.listeners = function (name) {return [];};\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () {return '/';};\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n      process.umask = function () {return 0;};\n\n    }, {}], 93: [function (require, module, exports) {\n      (function (global) {\n        /*! https://mths.be/punycode v1.4.1 by @mathias */\n        ;(function (root) {\n\n          /** Detect free variables */\n          var freeExports = typeof exports == 'object' && exports &&\n          !exports.nodeType && exports;\n          var freeModule = typeof module == 'object' && module &&\n          !module.nodeType && module;\n          var freeGlobal = typeof global == 'object' && global;\n          if (\n          freeGlobal.global === freeGlobal ||\n          freeGlobal.window === freeGlobal ||\n          freeGlobal.self === freeGlobal)\n          {\n            root = freeGlobal;\n          }\n\n          /**\n             * The `punycode` object.\n             * @name punycode\n             * @type Object\n             */\n          var punycode,\n\n          /** Highest positive signed 32-bit float value */\n          maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n          /** Bootstring parameters */\n          base = 36,\n          tMin = 1,\n          tMax = 26,\n          skew = 38,\n          damp = 700,\n          initialBias = 72,\n          initialN = 128, // 0x80\n          delimiter = '-', // '\\x2D'\n\n          /** Regular expressions */\n          regexPunycode = /^xn--/,\n          regexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n          regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n          /** Error messages */\n          errors = {\n            'overflow': 'Overflow: input needs wider integers to process',\n            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n            'invalid-input': 'Invalid input' },\n\n\n          /** Convenience shortcuts */\n          baseMinusTMin = base - tMin,\n          floor = Math.floor,\n          stringFromCharCode = String.fromCharCode,\n\n          /** Temporary variable */\n          key;\n\n          /*--------------------------------------------------------------------------*/\n\n          /**\n                                                                                          * A generic error utility function.\n                                                                                          * @private\n                                                                                          * @param {String} type The error type.\n                                                                                          * @returns {Error} Throws a `RangeError` with the applicable error message.\n                                                                                          */\n          function error(type) {\n            throw new RangeError(errors[type]);\n          }\n\n          /**\n             * A generic `Array#map` utility function.\n             * @private\n             * @param {Array} array The array to iterate over.\n             * @param {Function} callback The function that gets called for every array\n             * item.\n             * @returns {Array} A new array of values returned by the callback function.\n             */\n          function map(array, fn) {\n            var length = array.length;\n            var result = [];\n            while (length--) {\n              result[length] = fn(array[length]);\n            }\n            return result;\n          }\n\n          /**\n             * A simple `Array#map`-like wrapper to work with domain name strings or email\n             * addresses.\n             * @private\n             * @param {String} domain The domain name or email address.\n             * @param {Function} callback The function that gets called for every\n             * character.\n             * @returns {Array} A new string of characters returned by the callback\n             * function.\n             */\n          function mapDomain(string, fn) {\n            var parts = string.split('@');\n            var result = '';\n            if (parts.length > 1) {\n              // In email addresses, only the domain name should be punycoded. Leave\n              // the local part (i.e. everything up to `@`) intact.\n              result = parts[0] + '@';\n              string = parts[1];\n            }\n            // Avoid `split(regex)` for IE8 compatibility. See #17.\n            string = string.replace(regexSeparators, '\\x2E');\n            var labels = string.split('.');\n            var encoded = map(labels, fn).join('.');\n            return result + encoded;\n          }\n\n          /**\n             * Creates an array containing the numeric code points of each Unicode\n             * character in the string. While JavaScript uses UCS-2 internally,\n             * this function will convert a pair of surrogate halves (each of which\n             * UCS-2 exposes as separate characters) into a single code point,\n             * matching UTF-16.\n             * @see `punycode.ucs2.encode`\n             * @see <https://mathiasbynens.be/notes/javascript-encoding>\n             * @memberOf punycode.ucs2\n             * @name decode\n             * @param {String} string The Unicode input string (UCS-2).\n             * @returns {Array} The new array of code points.\n             */\n          function ucs2decode(string) {\n            var output = [],\n            counter = 0,\n            length = string.length,\n            value,\n            extra;\n            while (counter < length) {\n              value = string.charCodeAt(counter++);\n              if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // high surrogate, and there is a next character\n                extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) {// low surrogate\n                  output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                  // unmatched surrogate; only append this code unit, in case the next\n                  // code unit is the high surrogate of a surrogate pair\n                  output.push(value);\n                  counter--;\n                }\n              } else {\n                output.push(value);\n              }\n            }\n            return output;\n          }\n\n          /**\n             * Creates a string based on an array of numeric code points.\n             * @see `punycode.ucs2.decode`\n             * @memberOf punycode.ucs2\n             * @name encode\n             * @param {Array} codePoints The array of numeric code points.\n             * @returns {String} The new Unicode string (UCS-2).\n             */\n          function ucs2encode(array) {\n            return map(array, function (value) {\n              var output = '';\n              if (value > 0xFFFF) {\n                value -= 0x10000;\n                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                value = 0xDC00 | value & 0x3FF;\n              }\n              output += stringFromCharCode(value);\n              return output;\n            }).join('');\n          }\n\n          /**\n             * Converts a basic code point into a digit/integer.\n             * @see `digitToBasic()`\n             * @private\n             * @param {Number} codePoint The basic numeric code point value.\n             * @returns {Number} The numeric value of a basic code point (for use in\n             * representing integers) in the range `0` to `base - 1`, or `base` if\n             * the code point does not represent a value.\n             */\n          function basicToDigit(codePoint) {\n            if (codePoint - 48 < 10) {\n              return codePoint - 22;\n            }\n            if (codePoint - 65 < 26) {\n              return codePoint - 65;\n            }\n            if (codePoint - 97 < 26) {\n              return codePoint - 97;\n            }\n            return base;\n          }\n\n          /**\n             * Converts a digit/integer into a basic code point.\n             * @see `basicToDigit()`\n             * @private\n             * @param {Number} digit The numeric value of a basic code point.\n             * @returns {Number} The basic code point whose value (when used for\n             * representing integers) is `digit`, which needs to be in the range\n             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n             * used; else, the lowercase form is used. The behavior is undefined\n             * if `flag` is non-zero and `digit` has no uppercase form.\n             */\n          function digitToBasic(digit, flag) {\n            //  0..25 map to ASCII a..z or A..Z\n            // 26..35 map to ASCII 0..9\n            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n          }\n\n          /**\n             * Bias adaptation function as per section 3.4 of RFC 3492.\n             * https://tools.ietf.org/html/rfc3492#section-3.4\n             * @private\n             */\n          function adapt(delta, numPoints, firstTime) {\n            var k = 0;\n            delta = firstTime ? floor(delta / damp) : delta >> 1;\n            delta += floor(delta / numPoints);\n            for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n              delta = floor(delta / baseMinusTMin);\n            }\n            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n          }\n\n          /**\n             * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n             * symbols.\n             * @memberOf punycode\n             * @param {String} input The Punycode string of ASCII-only symbols.\n             * @returns {String} The resulting string of Unicode symbols.\n             */\n          function decode(input) {\n            // Don't use UCS-2\n            var output = [],\n            inputLength = input.length,\n            out,\n            i = 0,\n            n = initialN,\n            bias = initialBias,\n            basic,\n            j,\n            index,\n            oldi,\n            w,\n            k,\n            digit,\n            t,\n            /** Cached calculation results */\n            baseMinusT;\n\n            // Handle the basic code points: let `basic` be the number of input code\n            // points before the last delimiter, or `0` if there is none, then copy\n            // the first basic code points to the output.\n\n            basic = input.lastIndexOf(delimiter);\n            if (basic < 0) {\n              basic = 0;\n            }\n\n            for (j = 0; j < basic; ++j) {\n              // if it's not a basic code point\n              if (input.charCodeAt(j) >= 0x80) {\n                error('not-basic');\n              }\n              output.push(input.charCodeAt(j));\n            }\n\n            // Main decoding loop: start just after the last delimiter if any basic code\n            // points were copied; start at the beginning otherwise.\n\n            for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n              // `index` is the index of the next character to be consumed.\n              // Decode a generalized variable-length integer into `delta`,\n              // which gets added to `i`. The overflow checking is easier\n              // if we increase `i` as we go, then subtract off its starting\n              // value at the end to obtain `delta`.\n              for (oldi = i, w = 1, k = base;; /* no condition */k += base) {\n\n                if (index >= inputLength) {\n                  error('invalid-input');\n                }\n\n                digit = basicToDigit(input.charCodeAt(index++));\n\n                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                  error('overflow');\n                }\n\n                i += digit * w;\n                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                if (digit < t) {\n                  break;\n                }\n\n                baseMinusT = base - t;\n                if (w > floor(maxInt / baseMinusT)) {\n                  error('overflow');\n                }\n\n                w *= baseMinusT;\n\n              }\n\n              out = output.length + 1;\n              bias = adapt(i - oldi, out, oldi == 0);\n\n              // `i` was supposed to wrap around from `out` to `0`,\n              // incrementing `n` each time, so we'll fix that now:\n              if (floor(i / out) > maxInt - n) {\n                error('overflow');\n              }\n\n              n += floor(i / out);\n              i %= out;\n\n              // Insert `n` at position `i` of the output\n              output.splice(i++, 0, n);\n\n            }\n\n            return ucs2encode(output);\n          }\n\n          /**\n             * Converts a string of Unicode symbols (e.g. a domain name label) to a\n             * Punycode string of ASCII-only symbols.\n             * @memberOf punycode\n             * @param {String} input The string of Unicode symbols.\n             * @returns {String} The resulting Punycode string of ASCII-only symbols.\n             */\n          function encode(input) {\n            var n,\n            delta,\n            handledCPCount,\n            basicLength,\n            bias,\n            j,\n            m,\n            q,\n            k,\n            t,\n            currentValue,\n            output = [],\n            /** `inputLength` will hold the number of code points in `input`. */\n            inputLength,\n            /** Cached calculation results */\n            handledCPCountPlusOne,\n            baseMinusT,\n            qMinusT;\n\n            // Convert the input in UCS-2 to Unicode\n            input = ucs2decode(input);\n\n            // Cache the length\n            inputLength = input.length;\n\n            // Initialize the state\n            n = initialN;\n            delta = 0;\n            bias = initialBias;\n\n            // Handle the basic code points\n            for (j = 0; j < inputLength; ++j) {\n              currentValue = input[j];\n              if (currentValue < 0x80) {\n                output.push(stringFromCharCode(currentValue));\n              }\n            }\n\n            handledCPCount = basicLength = output.length;\n\n            // `handledCPCount` is the number of code points that have been handled;\n            // `basicLength` is the number of basic code points.\n\n            // Finish the basic string - if it is not empty - with a delimiter\n            if (basicLength) {\n              output.push(delimiter);\n            }\n\n            // Main encoding loop:\n            while (handledCPCount < inputLength) {\n\n              // All non-basic code points < n have been handled already. Find the next\n              // larger one:\n              for (m = maxInt, j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n                if (currentValue >= n && currentValue < m) {\n                  m = currentValue;\n                }\n              }\n\n              // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n              // but guard against overflow\n              handledCPCountPlusOne = handledCPCount + 1;\n              if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                error('overflow');\n              }\n\n              delta += (m - n) * handledCPCountPlusOne;\n              n = m;\n\n              for (j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n\n                if (currentValue < n && ++delta > maxInt) {\n                  error('overflow');\n                }\n\n                if (currentValue == n) {\n                  // Represent delta as a generalized variable-length integer\n                  for (q = delta, k = base;; /* no condition */k += base) {\n                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                    if (q < t) {\n                      break;\n                    }\n                    qMinusT = q - t;\n                    baseMinusT = base - t;\n                    output.push(\n                    stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\n                    q = floor(qMinusT / baseMinusT);\n                  }\n\n                  output.push(stringFromCharCode(digitToBasic(q, 0)));\n                  bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                  delta = 0;\n                  ++handledCPCount;\n                }\n              }\n\n              ++delta;\n              ++n;\n\n            }\n            return output.join('');\n          }\n\n          /**\n             * Converts a Punycode string representing a domain name or an email address\n             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n             * it doesn't matter if you call it on a string that has already been\n             * converted to Unicode.\n             * @memberOf punycode\n             * @param {String} input The Punycoded domain name or email address to\n             * convert to Unicode.\n             * @returns {String} The Unicode representation of the given Punycode\n             * string.\n             */\n          function toUnicode(input) {\n            return mapDomain(input, function (string) {\n              return regexPunycode.test(string) ?\n              decode(string.slice(4).toLowerCase()) :\n              string;\n            });\n          }\n\n          /**\n             * Converts a Unicode string representing a domain name or an email address to\n             * Punycode. Only the non-ASCII parts of the domain name will be converted,\n             * i.e. it doesn't matter if you call it with a domain that's already in\n             * ASCII.\n             * @memberOf punycode\n             * @param {String} input The domain name or email address to convert, as a\n             * Unicode string.\n             * @returns {String} The Punycode representation of the given domain name or\n             * email address.\n             */\n          function toASCII(input) {\n            return mapDomain(input, function (string) {\n              return regexNonASCII.test(string) ?\n              'xn--' + encode(string) :\n              string;\n            });\n          }\n\n          /*--------------------------------------------------------------------------*/\n\n          /** Define the public API */\n          punycode = {\n            /**\n                        * A string representing the current Punycode.js version number.\n                        * @memberOf punycode\n                        * @type String\n                        */\n            'version': '1.4.1',\n            /**\n                                 * An object of methods to convert from JavaScript's internal character\n                                 * representation (UCS-2) to Unicode code points, and back.\n                                 * @see <https://mathiasbynens.be/notes/javascript-encoding>\n                                 * @memberOf punycode\n                                 * @type Object\n                                 */\n            'ucs2': {\n              'decode': ucs2decode,\n              'encode': ucs2encode },\n\n            'decode': decode,\n            'encode': encode,\n            'toASCII': toASCII,\n            'toUnicode': toUnicode };\n\n\n          /** Expose `punycode` */\n          // Some AMD build optimizers, like r.js, check for specific condition patterns\n          // like the following:\n          if (\n          typeof define == 'function' &&\n          typeof define.amd == 'object' &&\n          define.amd)\n          {\n            define('punycode', function () {\n              return punycode;\n            });\n          } else if (freeExports && freeModule) {\n            if (module.exports == freeExports) {\n              // in Node.js, io.js, or RingoJS v0.8.0+\n              freeModule.exports = punycode;\n            } else {\n              // in Narwhal or RingoJS v0.7.0-\n              for (key in punycode) {\n                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n              }\n            }\n          } else {\n            // in Rhino or a web browser\n            root.punycode = punycode;\n          }\n\n        })(this);\n\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}], 94: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      'use strict';\n\n      // If obj.hasOwnProperty has been overridden, then calling\n      // obj.hasOwnProperty(prop) will break.\n      // See: https://github.com/joyent/node/issues/1707\n      function hasOwnProperty(obj, prop) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n      }\n\n      module.exports = function (qs, sep, eq, options) {\n        sep = sep || '&';\n        eq = eq || '=';\n        var obj = {};\n\n        if (typeof qs !== 'string' || qs.length === 0) {\n          return obj;\n        }\n\n        var regexp = /\\+/g;\n        qs = qs.split(sep);\n\n        var maxKeys = 1000;\n        if (options && typeof options.maxKeys === 'number') {\n          maxKeys = options.maxKeys;\n        }\n\n        var len = qs.length;\n        // maxKeys <= 0 means that we should not limit keys count\n        if (maxKeys > 0 && len > maxKeys) {\n          len = maxKeys;\n        }\n\n        for (var i = 0; i < len; ++i) {\n          var x = qs[i].replace(regexp, '%20'),\n          idx = x.indexOf(eq),\n          kstr,vstr,k,v;\n\n          if (idx >= 0) {\n            kstr = x.substr(0, idx);\n            vstr = x.substr(idx + 1);\n          } else {\n            kstr = x;\n            vstr = '';\n          }\n\n          k = decodeURIComponent(kstr);\n          v = decodeURIComponent(vstr);\n\n          if (!hasOwnProperty(obj, k)) {\n            obj[k] = v;\n          } else if (isArray(obj[k])) {\n            obj[k].push(v);\n          } else {\n            obj[k] = [obj[k], v];\n          }\n        }\n\n        return obj;\n      };\n\n      var isArray = Array.isArray || function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]';\n      };\n\n    }, {}], 95: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      'use strict';\n\n      var stringifyPrimitive = function stringifyPrimitive(v) {\n        switch (typeof v) {\n          case 'string':\n            return v;\n\n          case 'boolean':\n            return v ? 'true' : 'false';\n\n          case 'number':\n            return isFinite(v) ? v : '';\n\n          default:\n            return '';}\n\n      };\n\n      module.exports = function (obj, sep, eq, name) {\n        sep = sep || '&';\n        eq = eq || '=';\n        if (obj === null) {\n          obj = undefined;\n        }\n\n        if (typeof obj === 'object') {\n          return map(objectKeys(obj), function (k) {\n            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n            if (isArray(obj[k])) {\n              return map(obj[k], function (v) {\n                return ks + encodeURIComponent(stringifyPrimitive(v));\n              }).join(sep);\n            } else {\n              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n            }\n          }).join(sep);\n\n        }\n\n        if (!name) return '';\n        return encodeURIComponent(stringifyPrimitive(name)) + eq +\n        encodeURIComponent(stringifyPrimitive(obj));\n      };\n\n      var isArray = Array.isArray || function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]';\n      };\n\n      function map(xs, f) {\n        if (xs.map) return xs.map(f);\n        var res = [];\n        for (var i = 0; i < xs.length; i++) {\n          res.push(f(xs[i], i));\n        }\n        return res;\n      }\n\n      var objectKeys = Object.keys || function (obj) {\n        var res = [];\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n        }\n        return res;\n      };\n\n    }, {}], 96: [function (require, module, exports) {\n      'use strict';\n\n      exports.decode = exports.parse = require('./decode');\n      exports.encode = exports.stringify = require('./encode');\n\n    }, { \"./decode\": 94, \"./encode\": 95 }], 97: [function (require, module, exports) {\n      module.exports = require('./lib/_stream_duplex.js');\n\n    }, { \"./lib/_stream_duplex.js\": 98 }], 98: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      // a duplex stream is just a stream that is both readable and writable.\n      // Since JS doesn't have multiple prototypal inheritance, this class\n      // prototypally inherits from Readable, and then parasitically from\n      // Writable.\n\n      'use strict';\n\n      /*<replacement>*/\n\n      var pna = require('process-nextick-args');\n      /*</replacement>*/\n\n      /*<replacement>*/\n      var objectKeys = Object.keys || function (obj) {\n        var keys = [];\n        for (var key in obj) {\n          keys.push(key);\n        }return keys;\n      };\n      /*</replacement>*/\n\n      module.exports = Duplex;\n\n      /*<replacement>*/\n      var util = require('core-util-is');\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      var Readable = require('./_stream_readable');\n      var Writable = require('./_stream_writable');\n\n      util.inherits(Duplex, Readable);\n\n      {\n        // avoid scope creep, the keys array can then be collected\n        var keys = objectKeys(Writable.prototype);\n        for (var v = 0; v < keys.length; v++) {\n          var method = keys[v];\n          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n        }\n      }\n\n      function Duplex(options) {\n        if (!(this instanceof Duplex)) return new Duplex(options);\n\n        Readable.call(this, options);\n        Writable.call(this, options);\n\n        if (options && options.readable === false) this.readable = false;\n\n        if (options && options.writable === false) this.writable = false;\n\n        this.allowHalfOpen = true;\n        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n        this.once('end', onend);\n      }\n\n      Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n        // making it explicit this property is not enumerable\n        // because otherwise some prototype manipulation in\n        // userland will fail\n        enumerable: false,\n        get: function get() {\n          return this._writableState.highWaterMark;\n        } });\n\n\n      // the no-half-open enforcer\n      function onend() {\n        // if we allow half-open state, or if the writable side ended,\n        // then we're ok.\n        if (this.allowHalfOpen || this._writableState.ended) return;\n\n        // no more data can be written.\n        // But allow more writes to happen in this tick.\n        pna.nextTick(onEndNT, this);\n      }\n\n      function onEndNT(self) {\n        self.end();\n      }\n\n      Object.defineProperty(Duplex.prototype, 'destroyed', {\n        get: function get() {\n          if (this._readableState === undefined || this._writableState === undefined) {\n            return false;\n          }\n          return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set: function set(value) {\n          // we ignore the value if the stream\n          // has not been initialized yet\n          if (this._readableState === undefined || this._writableState === undefined) {\n            return;\n          }\n\n          // backward compatibility, the user is explicitly\n          // managing destroyed\n          this._readableState.destroyed = value;\n          this._writableState.destroyed = value;\n        } });\n\n\n      Duplex.prototype._destroy = function (err, cb) {\n        this.push(null);\n        this.end();\n\n        pna.nextTick(cb, err);\n      };\n    }, { \"./_stream_readable\": 100, \"./_stream_writable\": 102, \"core-util-is\": 14, \"inherits\": 80, \"process-nextick-args\": 91 }], 99: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      // a passthrough stream.\n      // basically just the most minimal sort of Transform stream.\n      // Every written chunk gets output as-is.\n\n      'use strict';\n\n      module.exports = PassThrough;\n\n      var Transform = require('./_stream_transform');\n\n      /*<replacement>*/\n      var util = require('core-util-is');\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      util.inherits(PassThrough, Transform);\n\n      function PassThrough(options) {\n        if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n        Transform.call(this, options);\n      }\n\n      PassThrough.prototype._transform = function (chunk, encoding, cb) {\n        cb(null, chunk);\n      };\n    }, { \"./_stream_transform\": 101, \"core-util-is\": 14, \"inherits\": 80 }], 100: [function (require, module, exports) {\n      (function (process, global) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        'use strict';\n\n        /*<replacement>*/\n\n        var pna = require('process-nextick-args');\n        /*</replacement>*/\n\n        module.exports = Readable;\n\n        /*<replacement>*/\n        var isArray = require('isarray');\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var Duplex;\n        /*</replacement>*/\n\n        Readable.ReadableState = ReadableState;\n\n        /*<replacement>*/\n        var EE = require('events').EventEmitter;\n\n        var EElistenerCount = function EElistenerCount(emitter, type) {\n          return emitter.listeners(type).length;\n        };\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var Stream = require('./internal/streams/stream');\n        /*</replacement>*/\n\n        /*<replacement>*/\n\n        var Buffer = require('safe-buffer').Buffer;\n        var OurUint8Array = global.Uint8Array || function () {};\n        function _uint8ArrayToBuffer(chunk) {\n          return Buffer.from(chunk);\n        }\n        function _isUint8Array(obj) {\n          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n        }\n\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var util = require('core-util-is');\n        util.inherits = require('inherits');\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var debugUtil = require('util');\n        var debug = void 0;\n        if (debugUtil && debugUtil.debuglog) {\n          debug = debugUtil.debuglog('stream');\n        } else {\n          debug = function debug() {};\n        }\n        /*</replacement>*/\n\n        var BufferList = require('./internal/streams/BufferList');\n        var destroyImpl = require('./internal/streams/destroy');\n        var StringDecoder;\n\n        util.inherits(Readable, Stream);\n\n        var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\n        function prependListener(emitter, event, fn) {\n          // Sadly this is not cacheable as some libraries bundle their own\n          // event emitter implementation with them.\n          if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n          // This is a hack to make sure that our error handler is attached before any\n          // userland ones.  NEVER DO THIS. This is here only because this code needs\n          // to continue to work with older versions of Node.js that do not include\n          // the prependListener() method. The goal is to eventually remove this hack.\n          if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n        }\n\n        function ReadableState(options, stream) {\n          Duplex = Duplex || require('./_stream_duplex');\n\n          options = options || {};\n\n          // Duplex streams are both readable and writable, but share\n          // the same options object.\n          // However, some cases require setting options to different\n          // values for the readable and the writable sides of the duplex stream.\n          // These options can be provided separately as readableXXX and writableXXX.\n          var isDuplex = stream instanceof Duplex;\n\n          // object stream flag. Used to make read(n) ignore n and to\n          // make all the buffer merging and length checks go away\n          this.objectMode = !!options.objectMode;\n\n          if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n          // the point at which it stops calling _read() to fill the buffer\n          // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n          var hwm = options.highWaterMark;\n          var readableHwm = options.readableHighWaterMark;\n          var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n          if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n          // cast to ints.\n          this.highWaterMark = Math.floor(this.highWaterMark);\n\n          // A linked list is used to store data chunks instead of an array because the\n          // linked list can remove elements from the beginning faster than\n          // array.shift()\n          this.buffer = new BufferList();\n          this.length = 0;\n          this.pipes = null;\n          this.pipesCount = 0;\n          this.flowing = null;\n          this.ended = false;\n          this.endEmitted = false;\n          this.reading = false;\n\n          // a flag to be able to tell if the event 'readable'/'data' is emitted\n          // immediately, or on a later tick.  We set this to true at first, because\n          // any actions that shouldn't happen until \"later\" should generally also\n          // not happen before the first read call.\n          this.sync = true;\n\n          // whenever we return null, then we set a flag to say\n          // that we're awaiting a 'readable' event emission.\n          this.needReadable = false;\n          this.emittedReadable = false;\n          this.readableListening = false;\n          this.resumeScheduled = false;\n\n          // has it been destroyed\n          this.destroyed = false;\n\n          // Crypto is kind of old and crusty.  Historically, its default string\n          // encoding is 'binary' so we have to make this configurable.\n          // Everything else in the universe uses 'utf8', though.\n          this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n          // the number of writers that are awaiting a drain event in .pipe()s\n          this.awaitDrain = 0;\n\n          // if true, a maybeReadMore has been scheduled\n          this.readingMore = false;\n\n          this.decoder = null;\n          this.encoding = null;\n          if (options.encoding) {\n            if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n            this.decoder = new StringDecoder(options.encoding);\n            this.encoding = options.encoding;\n          }\n        }\n\n        function Readable(options) {\n          Duplex = Duplex || require('./_stream_duplex');\n\n          if (!(this instanceof Readable)) return new Readable(options);\n\n          this._readableState = new ReadableState(options, this);\n\n          // legacy\n          this.readable = true;\n\n          if (options) {\n            if (typeof options.read === 'function') this._read = options.read;\n\n            if (typeof options.destroy === 'function') this._destroy = options.destroy;\n          }\n\n          Stream.call(this);\n        }\n\n        Object.defineProperty(Readable.prototype, 'destroyed', {\n          get: function get() {\n            if (this._readableState === undefined) {\n              return false;\n            }\n            return this._readableState.destroyed;\n          },\n          set: function set(value) {\n            // we ignore the value if the stream\n            // has not been initialized yet\n            if (!this._readableState) {\n              return;\n            }\n\n            // backward compatibility, the user is explicitly\n            // managing destroyed\n            this._readableState.destroyed = value;\n          } });\n\n\n        Readable.prototype.destroy = destroyImpl.destroy;\n        Readable.prototype._undestroy = destroyImpl.undestroy;\n        Readable.prototype._destroy = function (err, cb) {\n          this.push(null);\n          cb(err);\n        };\n\n        // Manually shove something into the read() buffer.\n        // This returns true if the highWaterMark has not been hit yet,\n        // similar to how Writable.write() returns true if you should\n        // write() some more.\n        Readable.prototype.push = function (chunk, encoding) {\n          var state = this._readableState;\n          var skipChunkCheck;\n\n          if (!state.objectMode) {\n            if (typeof chunk === 'string') {\n              encoding = encoding || state.defaultEncoding;\n              if (encoding !== state.encoding) {\n                chunk = Buffer.from(chunk, encoding);\n                encoding = '';\n              }\n              skipChunkCheck = true;\n            }\n          } else {\n            skipChunkCheck = true;\n          }\n\n          return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n        };\n\n        // Unshift should *always* be something directly out of read()\n        Readable.prototype.unshift = function (chunk) {\n          return readableAddChunk(this, chunk, null, true, false);\n        };\n\n        function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n          var state = stream._readableState;\n          if (chunk === null) {\n            state.reading = false;\n            onEofChunk(stream, state);\n          } else {\n            var er;\n            if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n            if (er) {\n              stream.emit('error', er);\n            } else if (state.objectMode || chunk && chunk.length > 0) {\n              if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n                chunk = _uint8ArrayToBuffer(chunk);\n              }\n\n              if (addToFront) {\n                if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n              } else if (state.ended) {\n                stream.emit('error', new Error('stream.push() after EOF'));\n              } else {\n                state.reading = false;\n                if (state.decoder && !encoding) {\n                  chunk = state.decoder.write(chunk);\n                  if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n                } else {\n                  addChunk(stream, state, chunk, false);\n                }\n              }\n            } else if (!addToFront) {\n              state.reading = false;\n            }\n          }\n\n          return needMoreData(state);\n        }\n\n        function addChunk(stream, state, chunk, addToFront) {\n          if (state.flowing && state.length === 0 && !state.sync) {\n            stream.emit('data', chunk);\n            stream.read(0);\n          } else {\n            // update the buffer info.\n            state.length += state.objectMode ? 1 : chunk.length;\n            if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n            if (state.needReadable) emitReadable(stream);\n          }\n          maybeReadMore(stream, state);\n        }\n\n        function chunkInvalid(state, chunk) {\n          var er;\n          if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n            er = new TypeError('Invalid non-string/buffer chunk');\n          }\n          return er;\n        }\n\n        // if it's past the high water mark, we can push in some more.\n        // Also, if we have no data yet, we can stand some\n        // more bytes.  This is to work around cases where hwm=0,\n        // such as the repl.  Also, if the push() triggered a\n        // readable event, and the user called read(largeNumber) such that\n        // needReadable was set, then we ought to push more, so that another\n        // 'readable' event will be triggered.\n        function needMoreData(state) {\n          return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n        }\n\n        Readable.prototype.isPaused = function () {\n          return this._readableState.flowing === false;\n        };\n\n        // backwards compatibility.\n        Readable.prototype.setEncoding = function (enc) {\n          if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n          this._readableState.decoder = new StringDecoder(enc);\n          this._readableState.encoding = enc;\n          return this;\n        };\n\n        // Don't raise the hwm > 8MB\n        var MAX_HWM = 0x800000;\n        function computeNewHighWaterMark(n) {\n          if (n >= MAX_HWM) {\n            n = MAX_HWM;\n          } else {\n            // Get the next highest power of 2 to prevent increasing hwm excessively in\n            // tiny amounts\n            n--;\n            n |= n >>> 1;\n            n |= n >>> 2;\n            n |= n >>> 4;\n            n |= n >>> 8;\n            n |= n >>> 16;\n            n++;\n          }\n          return n;\n        }\n\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function howMuchToRead(n, state) {\n          if (n <= 0 || state.length === 0 && state.ended) return 0;\n          if (state.objectMode) return 1;\n          if (n !== n) {\n            // Only flow one buffer at a time\n            if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n          }\n          // If we're asking for more than the current hwm, then raise the hwm.\n          if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n          if (n <= state.length) return n;\n          // Don't have enough\n          if (!state.ended) {\n            state.needReadable = true;\n            return 0;\n          }\n          return state.length;\n        }\n\n        // you can override either this method, or the async _read(n) below.\n        Readable.prototype.read = function (n) {\n          debug('read', n);\n          n = parseInt(n, 10);\n          var state = this._readableState;\n          var nOrig = n;\n\n          if (n !== 0) state.emittedReadable = false;\n\n          // if we're doing read(0) to trigger a readable event, but we\n          // already have a bunch of data in the buffer, then just trigger\n          // the 'readable' event and move on.\n          if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n            debug('read: emitReadable', state.length, state.ended);\n            if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n            return null;\n          }\n\n          n = howMuchToRead(n, state);\n\n          // if we've ended, and we're now clear, then finish it up.\n          if (n === 0 && state.ended) {\n            if (state.length === 0) endReadable(this);\n            return null;\n          }\n\n          // All the actual chunk generation logic needs to be\n          // *below* the call to _read.  The reason is that in certain\n          // synthetic stream cases, such as passthrough streams, _read\n          // may be a completely synchronous operation which may change\n          // the state of the read buffer, providing enough data when\n          // before there was *not* enough.\n          //\n          // So, the steps are:\n          // 1. Figure out what the state of things will be after we do\n          // a read from the buffer.\n          //\n          // 2. If that resulting state will trigger a _read, then call _read.\n          // Note that this may be asynchronous, or synchronous.  Yes, it is\n          // deeply ugly to write APIs this way, but that still doesn't mean\n          // that the Readable class should behave improperly, as streams are\n          // designed to be sync/async agnostic.\n          // Take note if the _read call is sync or async (ie, if the read call\n          // has returned yet), so that we know whether or not it's safe to emit\n          // 'readable' etc.\n          //\n          // 3. Actually pull the requested chunks out of the buffer and return.\n\n          // if we need a readable event, then we need to do some reading.\n          var doRead = state.needReadable;\n          debug('need readable', doRead);\n\n          // if we currently have less than the highWaterMark, then also read some\n          if (state.length === 0 || state.length - n < state.highWaterMark) {\n            doRead = true;\n            debug('length less than watermark', doRead);\n          }\n\n          // however, if we've ended, then there's no point, and if we're already\n          // reading, then it's unnecessary.\n          if (state.ended || state.reading) {\n            doRead = false;\n            debug('reading or ended', doRead);\n          } else if (doRead) {\n            debug('do read');\n            state.reading = true;\n            state.sync = true;\n            // if the length is currently zero, then we *need* a readable event.\n            if (state.length === 0) state.needReadable = true;\n            // call internal read method\n            this._read(state.highWaterMark);\n            state.sync = false;\n            // If _read pushed data synchronously, then `reading` will be false,\n            // and we need to re-evaluate how much data we can return to the user.\n            if (!state.reading) n = howMuchToRead(nOrig, state);\n          }\n\n          var ret;\n          if (n > 0) ret = fromList(n, state);else ret = null;\n\n          if (ret === null) {\n            state.needReadable = true;\n            n = 0;\n          } else {\n            state.length -= n;\n          }\n\n          if (state.length === 0) {\n            // If we have nothing in the buffer, then we want to know\n            // as soon as we *do* get something into the buffer.\n            if (!state.ended) state.needReadable = true;\n\n            // If we tried to read() past the EOF, then emit end on the next tick.\n            if (nOrig !== n && state.ended) endReadable(this);\n          }\n\n          if (ret !== null) this.emit('data', ret);\n\n          return ret;\n        };\n\n        function onEofChunk(stream, state) {\n          if (state.ended) return;\n          if (state.decoder) {\n            var chunk = state.decoder.end();\n            if (chunk && chunk.length) {\n              state.buffer.push(chunk);\n              state.length += state.objectMode ? 1 : chunk.length;\n            }\n          }\n          state.ended = true;\n\n          // emit 'readable' now to make sure it gets picked up.\n          emitReadable(stream);\n        }\n\n        // Don't emit readable right away in sync mode, because this can trigger\n        // another read() call => stack overflow.  This way, it might trigger\n        // a nextTick recursion warning, but that's not so bad.\n        function emitReadable(stream) {\n          var state = stream._readableState;\n          state.needReadable = false;\n          if (!state.emittedReadable) {\n            debug('emitReadable', state.flowing);\n            state.emittedReadable = true;\n            if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n          }\n        }\n\n        function emitReadable_(stream) {\n          debug('emit readable');\n          stream.emit('readable');\n          flow(stream);\n        }\n\n        // at this point, the user has presumably seen the 'readable' event,\n        // and called read() to consume some data.  that may have triggered\n        // in turn another _read(n) call, in which case reading = true if\n        // it's in progress.\n        // However, if we're not ended, or reading, and the length < hwm,\n        // then go ahead and try to read some more preemptively.\n        function maybeReadMore(stream, state) {\n          if (!state.readingMore) {\n            state.readingMore = true;\n            pna.nextTick(maybeReadMore_, stream, state);\n          }\n        }\n\n        function maybeReadMore_(stream, state) {\n          var len = state.length;\n          while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n            debug('maybeReadMore read 0');\n            stream.read(0);\n            if (len === state.length)\n              // didn't get any data, stop spinning.\n              break;else len = state.length;\n          }\n          state.readingMore = false;\n        }\n\n        // abstract method.  to be overridden in specific implementation classes.\n        // call cb(er, data) where data is <= n in length.\n        // for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n        // arbitrary, and perhaps not very meaningful.\n        Readable.prototype._read = function (n) {\n          this.emit('error', new Error('_read() is not implemented'));\n        };\n\n        Readable.prototype.pipe = function (dest, pipeOpts) {\n          var src = this;\n          var state = this._readableState;\n\n          switch (state.pipesCount) {\n            case 0:\n              state.pipes = dest;\n              break;\n            case 1:\n              state.pipes = [state.pipes, dest];\n              break;\n            default:\n              state.pipes.push(dest);\n              break;}\n\n          state.pipesCount += 1;\n          debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n          var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n          var endFn = doEnd ? onend : unpipe;\n          if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n          dest.on('unpipe', onunpipe);\n          function onunpipe(readable, unpipeInfo) {\n            debug('onunpipe');\n            if (readable === src) {\n              if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n                unpipeInfo.hasUnpiped = true;\n                cleanup();\n              }\n            }\n          }\n\n          function onend() {\n            debug('onend');\n            dest.end();\n          }\n\n          // when the dest drains, it reduces the awaitDrain counter\n          // on the source.  This would be more elegant with a .once()\n          // handler in flow(), but adding and removing repeatedly is\n          // too slow.\n          var ondrain = pipeOnDrain(src);\n          dest.on('drain', ondrain);\n\n          var cleanedUp = false;\n          function cleanup() {\n            debug('cleanup');\n            // cleanup event handlers once the pipe is broken\n            dest.removeListener('close', onclose);\n            dest.removeListener('finish', onfinish);\n            dest.removeListener('drain', ondrain);\n            dest.removeListener('error', onerror);\n            dest.removeListener('unpipe', onunpipe);\n            src.removeListener('end', onend);\n            src.removeListener('end', unpipe);\n            src.removeListener('data', ondata);\n\n            cleanedUp = true;\n\n            // if the reader is waiting for a drain event from this\n            // specific writer, then it would cause it to never start\n            // flowing again.\n            // So, if this is awaiting a drain, then we just call it now.\n            // If we don't know, then assume that we are waiting for one.\n            if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n          }\n\n          // If the user pushes more data while we're writing to dest then we'll end up\n          // in ondata again. However, we only want to increase awaitDrain once because\n          // dest will only emit one 'drain' event for the multiple writes.\n          // => Introduce a guard on increasing awaitDrain.\n          var increasedAwaitDrain = false;\n          src.on('data', ondata);\n          function ondata(chunk) {\n            debug('ondata');\n            increasedAwaitDrain = false;\n            var ret = dest.write(chunk);\n            if (false === ret && !increasedAwaitDrain) {\n              // If the user unpiped during `dest.write()`, it is possible\n              // to get stuck in a permanently paused state if that write\n              // also returned false.\n              // => Check whether `dest` is still a piping destination.\n              if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n                debug('false write response, pause', src._readableState.awaitDrain);\n                src._readableState.awaitDrain++;\n                increasedAwaitDrain = true;\n              }\n              src.pause();\n            }\n          }\n\n          // if the dest has an error, then stop piping into it.\n          // however, don't suppress the throwing behavior for this.\n          function onerror(er) {\n            debug('onerror', er);\n            unpipe();\n            dest.removeListener('error', onerror);\n            if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n          }\n\n          // Make sure our error handler is attached before userland ones.\n          prependListener(dest, 'error', onerror);\n\n          // Both close and finish should trigger unpipe, but only once.\n          function onclose() {\n            dest.removeListener('finish', onfinish);\n            unpipe();\n          }\n          dest.once('close', onclose);\n          function onfinish() {\n            debug('onfinish');\n            dest.removeListener('close', onclose);\n            unpipe();\n          }\n          dest.once('finish', onfinish);\n\n          function unpipe() {\n            debug('unpipe');\n            src.unpipe(dest);\n          }\n\n          // tell the dest that it's being piped to\n          dest.emit('pipe', src);\n\n          // start the flow if it hasn't been started already.\n          if (!state.flowing) {\n            debug('pipe resume');\n            src.resume();\n          }\n\n          return dest;\n        };\n\n        function pipeOnDrain(src) {\n          return function () {\n            var state = src._readableState;\n            debug('pipeOnDrain', state.awaitDrain);\n            if (state.awaitDrain) state.awaitDrain--;\n            if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n              state.flowing = true;\n              flow(src);\n            }\n          };\n        }\n\n        Readable.prototype.unpipe = function (dest) {\n          var state = this._readableState;\n          var unpipeInfo = { hasUnpiped: false };\n\n          // if we're not piping anywhere, then do nothing.\n          if (state.pipesCount === 0) return this;\n\n          // just one destination.  most common case.\n          if (state.pipesCount === 1) {\n            // passed in one, but it's not the right one.\n            if (dest && dest !== state.pipes) return this;\n\n            if (!dest) dest = state.pipes;\n\n            // got a match.\n            state.pipes = null;\n            state.pipesCount = 0;\n            state.flowing = false;\n            if (dest) dest.emit('unpipe', this, unpipeInfo);\n            return this;\n          }\n\n          // slow case. multiple pipe destinations.\n\n          if (!dest) {\n            // remove all.\n            var dests = state.pipes;\n            var len = state.pipesCount;\n            state.pipes = null;\n            state.pipesCount = 0;\n            state.flowing = false;\n\n            for (var i = 0; i < len; i++) {\n              dests[i].emit('unpipe', this, unpipeInfo);\n            }return this;\n          }\n\n          // try to find the right one.\n          var index = indexOf(state.pipes, dest);\n          if (index === -1) return this;\n\n          state.pipes.splice(index, 1);\n          state.pipesCount -= 1;\n          if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n          dest.emit('unpipe', this, unpipeInfo);\n\n          return this;\n        };\n\n        // set up data events if they are asked for\n        // Ensure readable listeners eventually get something\n        Readable.prototype.on = function (ev, fn) {\n          var res = Stream.prototype.on.call(this, ev, fn);\n\n          if (ev === 'data') {\n            // Start flowing on next tick if stream isn't explicitly paused\n            if (this._readableState.flowing !== false) this.resume();\n          } else if (ev === 'readable') {\n            var state = this._readableState;\n            if (!state.endEmitted && !state.readableListening) {\n              state.readableListening = state.needReadable = true;\n              state.emittedReadable = false;\n              if (!state.reading) {\n                pna.nextTick(nReadingNextTick, this);\n              } else if (state.length) {\n                emitReadable(this);\n              }\n            }\n          }\n\n          return res;\n        };\n        Readable.prototype.addListener = Readable.prototype.on;\n\n        function nReadingNextTick(self) {\n          debug('readable nexttick read 0');\n          self.read(0);\n        }\n\n        // pause() and resume() are remnants of the legacy readable stream API\n        // If the user uses them, then switch into old mode.\n        Readable.prototype.resume = function () {\n          var state = this._readableState;\n          if (!state.flowing) {\n            debug('resume');\n            state.flowing = true;\n            resume(this, state);\n          }\n          return this;\n        };\n\n        function resume(stream, state) {\n          if (!state.resumeScheduled) {\n            state.resumeScheduled = true;\n            pna.nextTick(resume_, stream, state);\n          }\n        }\n\n        function resume_(stream, state) {\n          if (!state.reading) {\n            debug('resume read 0');\n            stream.read(0);\n          }\n\n          state.resumeScheduled = false;\n          state.awaitDrain = 0;\n          stream.emit('resume');\n          flow(stream);\n          if (state.flowing && !state.reading) stream.read(0);\n        }\n\n        Readable.prototype.pause = function () {\n          debug('call pause flowing=%j', this._readableState.flowing);\n          if (false !== this._readableState.flowing) {\n            debug('pause');\n            this._readableState.flowing = false;\n            this.emit('pause');\n          }\n          return this;\n        };\n\n        function flow(stream) {\n          var state = stream._readableState;\n          debug('flow', state.flowing);\n          while (state.flowing && stream.read() !== null) {}\n        }\n\n        // wrap an old-style stream as the async data source.\n        // This is *not* part of the readable stream interface.\n        // It is an ugly unfortunate mess of history.\n        Readable.prototype.wrap = function (stream) {\n          var _this = this;\n\n          var state = this._readableState;\n          var paused = false;\n\n          stream.on('end', function () {\n            debug('wrapped end');\n            if (state.decoder && !state.ended) {\n              var chunk = state.decoder.end();\n              if (chunk && chunk.length) _this.push(chunk);\n            }\n\n            _this.push(null);\n          });\n\n          stream.on('data', function (chunk) {\n            debug('wrapped data');\n            if (state.decoder) chunk = state.decoder.write(chunk);\n\n            // don't skip over falsy values in objectMode\n            if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n            var ret = _this.push(chunk);\n            if (!ret) {\n              paused = true;\n              stream.pause();\n            }\n          });\n\n          // proxy all the other methods.\n          // important when wrapping filters and duplexes.\n          for (var i in stream) {\n            if (this[i] === undefined && typeof stream[i] === 'function') {\n              this[i] = function (method) {\n                return function () {\n                  return stream[method].apply(stream, arguments);\n                };\n              }(i);\n            }\n          }\n\n          // proxy certain important events.\n          for (var n = 0; n < kProxyEvents.length; n++) {\n            stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n          }\n\n          // when we try to consume some more bytes, simply unpause the\n          // underlying stream.\n          this._read = function (n) {\n            debug('wrapped _read', n);\n            if (paused) {\n              paused = false;\n              stream.resume();\n            }\n          };\n\n          return this;\n        };\n\n        Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n          // making it explicit this property is not enumerable\n          // because otherwise some prototype manipulation in\n          // userland will fail\n          enumerable: false,\n          get: function get() {\n            return this._readableState.highWaterMark;\n          } });\n\n\n        // exposed for testing purposes only.\n        Readable._fromList = fromList;\n\n        // Pluck off n bytes from an array of buffers.\n        // Length is the combined lengths of all the buffers in the list.\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function fromList(n, state) {\n          // nothing buffered\n          if (state.length === 0) return null;\n\n          var ret;\n          if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n            // read it all, truncate the list\n            if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n            state.buffer.clear();\n          } else {\n            // read part of list\n            ret = fromListPartial(n, state.buffer, state.decoder);\n          }\n\n          return ret;\n        }\n\n        // Extracts only enough buffered data to satisfy the amount requested.\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function fromListPartial(n, list, hasStrings) {\n          var ret;\n          if (n < list.head.data.length) {\n            // slice is the same for buffers and strings\n            ret = list.head.data.slice(0, n);\n            list.head.data = list.head.data.slice(n);\n          } else if (n === list.head.data.length) {\n            // first chunk is a perfect match\n            ret = list.shift();\n          } else {\n            // result spans more than one buffer\n            ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n          }\n          return ret;\n        }\n\n        // Copies a specified amount of characters from the list of buffered data\n        // chunks.\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function copyFromBufferString(n, list) {\n          var p = list.head;\n          var c = 1;\n          var ret = p.data;\n          n -= ret.length;\n          while (p = p.next) {\n            var str = p.data;\n            var nb = n > str.length ? str.length : n;\n            if (nb === str.length) ret += str;else ret += str.slice(0, n);\n            n -= nb;\n            if (n === 0) {\n              if (nb === str.length) {\n                ++c;\n                if (p.next) list.head = p.next;else list.head = list.tail = null;\n              } else {\n                list.head = p;\n                p.data = str.slice(nb);\n              }\n              break;\n            }\n            ++c;\n          }\n          list.length -= c;\n          return ret;\n        }\n\n        // Copies a specified amount of bytes from the list of buffered data chunks.\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function copyFromBuffer(n, list) {\n          var ret = Buffer.allocUnsafe(n);\n          var p = list.head;\n          var c = 1;\n          p.data.copy(ret);\n          n -= p.data.length;\n          while (p = p.next) {\n            var buf = p.data;\n            var nb = n > buf.length ? buf.length : n;\n            buf.copy(ret, ret.length - n, 0, nb);\n            n -= nb;\n            if (n === 0) {\n              if (nb === buf.length) {\n                ++c;\n                if (p.next) list.head = p.next;else list.head = list.tail = null;\n              } else {\n                list.head = p;\n                p.data = buf.slice(nb);\n              }\n              break;\n            }\n            ++c;\n          }\n          list.length -= c;\n          return ret;\n        }\n\n        function endReadable(stream) {\n          var state = stream._readableState;\n\n          // If we get here before consuming all the bytes, then that is a\n          // bug in node.  Should never happen.\n          if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n          if (!state.endEmitted) {\n            state.ended = true;\n            pna.nextTick(endReadableNT, state, stream);\n          }\n        }\n\n        function endReadableNT(state, stream) {\n          // Check that we didn't get one last unshift.\n          if (!state.endEmitted && state.length === 0) {\n            state.endEmitted = true;\n            stream.readable = false;\n            stream.emit('end');\n          }\n        }\n\n        function indexOf(xs, x) {\n          for (var i = 0, l = xs.length; i < l; i++) {\n            if (xs[i] === x) return i;\n          }\n          return -1;\n        }\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, { \"./_stream_duplex\": 98, \"./internal/streams/BufferList\": 103, \"./internal/streams/destroy\": 104, \"./internal/streams/stream\": 105, \"_process\": 92, \"core-util-is\": 14, \"events\": 13, \"inherits\": 80, \"isarray\": 106, \"process-nextick-args\": 91, \"safe-buffer\": 110, \"string_decoder/\": 107, \"util\": 11 }], 101: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      // a transform stream is a readable/writable stream where you do\n      // something with the data.  Sometimes it's called a \"filter\",\n      // but that's not a great name for it, since that implies a thing where\n      // some bits pass through, and others are simply ignored.  (That would\n      // be a valid example of a transform, of course.)\n      //\n      // While the output is causally related to the input, it's not a\n      // necessarily symmetric or synchronous transformation.  For example,\n      // a zlib stream might take multiple plain-text writes(), and then\n      // emit a single compressed chunk some time in the future.\n      //\n      // Here's how this works:\n      //\n      // The Transform stream has all the aspects of the readable and writable\n      // stream classes.  When you write(chunk), that calls _write(chunk,cb)\n      // internally, and returns false if there's a lot of pending writes\n      // buffered up.  When you call read(), that calls _read(n) until\n      // there's enough pending readable data buffered up.\n      //\n      // In a transform stream, the written data is placed in a buffer.  When\n      // _read(n) is called, it transforms the queued up data, calling the\n      // buffered _write cb's as it consumes chunks.  If consuming a single\n      // written chunk would result in multiple output chunks, then the first\n      // outputted bit calls the readcb, and subsequent chunks just go into\n      // the read buffer, and will cause it to emit 'readable' if necessary.\n      //\n      // This way, back-pressure is actually determined by the reading side,\n      // since _read has to be called to start processing a new chunk.  However,\n      // a pathological inflate type of transform can cause excessive buffering\n      // here.  For example, imagine a stream where every byte of input is\n      // interpreted as an integer from 0-255, and then results in that many\n      // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n      // 1kb of data being output.  In this case, you could write a very small\n      // amount of input, and end up with a very large amount of output.  In\n      // such a pathological inflating mechanism, there'd be no way to tell\n      // the system to stop doing the transform.  A single 4MB write could\n      // cause the system to run out of memory.\n      //\n      // However, even in such a pathological case, only a single written chunk\n      // would be consumed, and then the rest would wait (un-transformed) until\n      // the results of the previous transformed chunk were consumed.\n\n      'use strict';\n\n      module.exports = Transform;\n\n      var Duplex = require('./_stream_duplex');\n\n      /*<replacement>*/\n      var util = require('core-util-is');\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      util.inherits(Transform, Duplex);\n\n      function afterTransform(er, data) {\n        var ts = this._transformState;\n        ts.transforming = false;\n\n        var cb = ts.writecb;\n\n        if (!cb) {\n          return this.emit('error', new Error('write callback called multiple times'));\n        }\n\n        ts.writechunk = null;\n        ts.writecb = null;\n\n        if (data != null) // single equals check for both `null` and `undefined`\n          this.push(data);\n\n        cb(er);\n\n        var rs = this._readableState;\n        rs.reading = false;\n        if (rs.needReadable || rs.length < rs.highWaterMark) {\n          this._read(rs.highWaterMark);\n        }\n      }\n\n      function Transform(options) {\n        if (!(this instanceof Transform)) return new Transform(options);\n\n        Duplex.call(this, options);\n\n        this._transformState = {\n          afterTransform: afterTransform.bind(this),\n          needTransform: false,\n          transforming: false,\n          writecb: null,\n          writechunk: null,\n          writeencoding: null };\n\n\n        // start out asking for a readable event once data is transformed.\n        this._readableState.needReadable = true;\n\n        // we have implemented the _read method, and done the other things\n        // that Readable wants before the first _read call, so unset the\n        // sync guard flag.\n        this._readableState.sync = false;\n\n        if (options) {\n          if (typeof options.transform === 'function') this._transform = options.transform;\n\n          if (typeof options.flush === 'function') this._flush = options.flush;\n        }\n\n        // When the writable side finishes, then flush out anything remaining.\n        this.on('prefinish', prefinish);\n      }\n\n      function prefinish() {\n        var _this = this;\n\n        if (typeof this._flush === 'function') {\n          this._flush(function (er, data) {\n            done(_this, er, data);\n          });\n        } else {\n          done(this, null, null);\n        }\n      }\n\n      Transform.prototype.push = function (chunk, encoding) {\n        this._transformState.needTransform = false;\n        return Duplex.prototype.push.call(this, chunk, encoding);\n      };\n\n      // This is the part where you do stuff!\n      // override this function in implementation classes.\n      // 'chunk' is an input chunk.\n      //\n      // Call `push(newChunk)` to pass along transformed output\n      // to the readable side.  You may call 'push' zero or more times.\n      //\n      // Call `cb(err)` when you are done with this chunk.  If you pass\n      // an error, then that'll put the hurt on the whole operation.  If you\n      // never call cb(), then you'll never get another chunk.\n      Transform.prototype._transform = function (chunk, encoding, cb) {\n        throw new Error('_transform() is not implemented');\n      };\n\n      Transform.prototype._write = function (chunk, encoding, cb) {\n        var ts = this._transformState;\n        ts.writecb = cb;\n        ts.writechunk = chunk;\n        ts.writeencoding = encoding;\n        if (!ts.transforming) {\n          var rs = this._readableState;\n          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n        }\n      };\n\n      // Doesn't matter what the args are here.\n      // _transform does all the work.\n      // That we got here means that the readable side wants more data.\n      Transform.prototype._read = function (n) {\n        var ts = this._transformState;\n\n        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n          ts.transforming = true;\n          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n        } else {\n          // mark that we need a transform, so that any data that comes in\n          // will get processed, now that we've asked for it.\n          ts.needTransform = true;\n        }\n      };\n\n      Transform.prototype._destroy = function (err, cb) {\n        var _this2 = this;\n\n        Duplex.prototype._destroy.call(this, err, function (err2) {\n          cb(err2);\n          _this2.emit('close');\n        });\n      };\n\n      function done(stream, er, data) {\n        if (er) return stream.emit('error', er);\n\n        if (data != null) // single equals check for both `null` and `undefined`\n          stream.push(data);\n\n        // if there's nothing in the write buffer, then that means\n        // that nothing more will ever be provided\n        if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n        if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n        return stream.push(null);\n      }\n    }, { \"./_stream_duplex\": 98, \"core-util-is\": 14, \"inherits\": 80 }], 102: [function (require, module, exports) {\n      (function (process, global, setImmediate) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        // A bit simpler than readable streams.\n        // Implement an async ._write(chunk, encoding, cb), and it'll handle all\n        // the drain event emission and buffering.\n\n        'use strict';\n\n        /*<replacement>*/\n\n        var pna = require('process-nextick-args');\n        /*</replacement>*/\n\n        module.exports = Writable;\n\n        /* <replacement> */\n        function WriteReq(chunk, encoding, cb) {\n          this.chunk = chunk;\n          this.encoding = encoding;\n          this.callback = cb;\n          this.next = null;\n        }\n\n        // It seems a linked list but it is not\n        // there will be only 2 of these for each stream\n        function CorkedRequest(state) {\n          var _this = this;\n\n          this.next = null;\n          this.entry = null;\n          this.finish = function () {\n            onCorkedFinish(_this, state);\n          };\n        }\n        /* </replacement> */\n\n        /*<replacement>*/\n        var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var Duplex;\n        /*</replacement>*/\n\n        Writable.WritableState = WritableState;\n\n        /*<replacement>*/\n        var util = require('core-util-is');\n        util.inherits = require('inherits');\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var internalUtil = {\n          deprecate: require('util-deprecate') };\n\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var Stream = require('./internal/streams/stream');\n        /*</replacement>*/\n\n        /*<replacement>*/\n\n        var Buffer = require('safe-buffer').Buffer;\n        var OurUint8Array = global.Uint8Array || function () {};\n        function _uint8ArrayToBuffer(chunk) {\n          return Buffer.from(chunk);\n        }\n        function _isUint8Array(obj) {\n          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n        }\n\n        /*</replacement>*/\n\n        var destroyImpl = require('./internal/streams/destroy');\n\n        util.inherits(Writable, Stream);\n\n        function nop() {}\n\n        function WritableState(options, stream) {\n          Duplex = Duplex || require('./_stream_duplex');\n\n          options = options || {};\n\n          // Duplex streams are both readable and writable, but share\n          // the same options object.\n          // However, some cases require setting options to different\n          // values for the readable and the writable sides of the duplex stream.\n          // These options can be provided separately as readableXXX and writableXXX.\n          var isDuplex = stream instanceof Duplex;\n\n          // object stream flag to indicate whether or not this stream\n          // contains buffers or objects.\n          this.objectMode = !!options.objectMode;\n\n          if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n          // the point at which write() starts returning false\n          // Note: 0 is a valid value, means that we always return false if\n          // the entire buffer is not flushed immediately on write()\n          var hwm = options.highWaterMark;\n          var writableHwm = options.writableHighWaterMark;\n          var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n          if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n          // cast to ints.\n          this.highWaterMark = Math.floor(this.highWaterMark);\n\n          // if _final has been called\n          this.finalCalled = false;\n\n          // drain event flag.\n          this.needDrain = false;\n          // at the start of calling end()\n          this.ending = false;\n          // when end() has been called, and returned\n          this.ended = false;\n          // when 'finish' is emitted\n          this.finished = false;\n\n          // has it been destroyed\n          this.destroyed = false;\n\n          // should we decode strings into buffers before passing to _write?\n          // this is here so that some node-core streams can optimize string\n          // handling at a lower level.\n          var noDecode = options.decodeStrings === false;\n          this.decodeStrings = !noDecode;\n\n          // Crypto is kind of old and crusty.  Historically, its default string\n          // encoding is 'binary' so we have to make this configurable.\n          // Everything else in the universe uses 'utf8', though.\n          this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n          // not an actual buffer we keep track of, but a measurement\n          // of how much we're waiting to get pushed to some underlying\n          // socket or file.\n          this.length = 0;\n\n          // a flag to see when we're in the middle of a write.\n          this.writing = false;\n\n          // when true all writes will be buffered until .uncork() call\n          this.corked = 0;\n\n          // a flag to be able to tell if the onwrite cb is called immediately,\n          // or on a later tick.  We set this to true at first, because any\n          // actions that shouldn't happen until \"later\" should generally also\n          // not happen before the first write call.\n          this.sync = true;\n\n          // a flag to know if we're processing previously buffered items, which\n          // may call the _write() callback in the same tick, so that we don't\n          // end up in an overlapped onwrite situation.\n          this.bufferProcessing = false;\n\n          // the callback that's passed to _write(chunk,cb)\n          this.onwrite = function (er) {\n            onwrite(stream, er);\n          };\n\n          // the callback that the user supplies to write(chunk,encoding,cb)\n          this.writecb = null;\n\n          // the amount that is being written when _write is called.\n          this.writelen = 0;\n\n          this.bufferedRequest = null;\n          this.lastBufferedRequest = null;\n\n          // number of pending user-supplied write callbacks\n          // this must be 0 before 'finish' can be emitted\n          this.pendingcb = 0;\n\n          // emit prefinish if the only thing we're waiting for is _write cbs\n          // This is relevant for synchronous Transform streams\n          this.prefinished = false;\n\n          // True if the error was already emitted and should not be thrown again\n          this.errorEmitted = false;\n\n          // count buffered requests\n          this.bufferedRequestCount = 0;\n\n          // allocate the first CorkedRequest, there is always\n          // one allocated and free to use, and we maintain at most two\n          this.corkedRequestsFree = new CorkedRequest(this);\n        }\n\n        WritableState.prototype.getBuffer = function getBuffer() {\n          var current = this.bufferedRequest;\n          var out = [];\n          while (current) {\n            out.push(current);\n            current = current.next;\n          }\n          return out;\n        };\n\n        (function () {\n          try {\n            Object.defineProperty(WritableState.prototype, 'buffer', {\n              get: internalUtil.deprecate(function () {\n                return this.getBuffer();\n              }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003') });\n\n          } catch (_) {}\n        })();\n\n        // Test _writableState for inheritance to account for Duplex streams,\n        // whose prototype chain only points to Readable.\n        var realHasInstance;\n        if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n          realHasInstance = Function.prototype[Symbol.hasInstance];\n          Object.defineProperty(Writable, Symbol.hasInstance, {\n            value: function value(object) {\n              if (realHasInstance.call(this, object)) return true;\n              if (this !== Writable) return false;\n\n              return object && object._writableState instanceof WritableState;\n            } });\n\n        } else {\n          realHasInstance = function realHasInstance(object) {\n            return object instanceof this;\n          };\n        }\n\n        function Writable(options) {\n          Duplex = Duplex || require('./_stream_duplex');\n\n          // Writable ctor is applied to Duplexes, too.\n          // `realHasInstance` is necessary because using plain `instanceof`\n          // would return false, as no `_writableState` property is attached.\n\n          // Trying to use the custom `instanceof` for Writable here will also break the\n          // Node.js LazyTransform implementation, which has a non-trivial getter for\n          // `_writableState` that would lead to infinite recursion.\n          if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n            return new Writable(options);\n          }\n\n          this._writableState = new WritableState(options, this);\n\n          // legacy.\n          this.writable = true;\n\n          if (options) {\n            if (typeof options.write === 'function') this._write = options.write;\n\n            if (typeof options.writev === 'function') this._writev = options.writev;\n\n            if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n            if (typeof options.final === 'function') this._final = options.final;\n          }\n\n          Stream.call(this);\n        }\n\n        // Otherwise people can pipe Writable streams, which is just wrong.\n        Writable.prototype.pipe = function () {\n          this.emit('error', new Error('Cannot pipe, not readable'));\n        };\n\n        function writeAfterEnd(stream, cb) {\n          var er = new Error('write after end');\n          // TODO: defer error events consistently everywhere, not just the cb\n          stream.emit('error', er);\n          pna.nextTick(cb, er);\n        }\n\n        // Checks that a user-supplied chunk is valid, especially for the particular\n        // mode the stream is in. Currently this means that `null` is never accepted\n        // and undefined/non-string values are only allowed in object mode.\n        function validChunk(stream, state, chunk, cb) {\n          var valid = true;\n          var er = false;\n\n          if (chunk === null) {\n            er = new TypeError('May not write null values to stream');\n          } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n            er = new TypeError('Invalid non-string/buffer chunk');\n          }\n          if (er) {\n            stream.emit('error', er);\n            pna.nextTick(cb, er);\n            valid = false;\n          }\n          return valid;\n        }\n\n        Writable.prototype.write = function (chunk, encoding, cb) {\n          var state = this._writableState;\n          var ret = false;\n          var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n          if (isBuf && !Buffer.isBuffer(chunk)) {\n            chunk = _uint8ArrayToBuffer(chunk);\n          }\n\n          if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = null;\n          }\n\n          if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n          if (typeof cb !== 'function') cb = nop;\n\n          if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n            state.pendingcb++;\n            ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n          }\n\n          return ret;\n        };\n\n        Writable.prototype.cork = function () {\n          var state = this._writableState;\n\n          state.corked++;\n        };\n\n        Writable.prototype.uncork = function () {\n          var state = this._writableState;\n\n          if (state.corked) {\n            state.corked--;\n\n            if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n          }\n        };\n\n        Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n          // node::ParseEncoding() requires lower case.\n          if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n          if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n          this._writableState.defaultEncoding = encoding;\n          return this;\n        };\n\n        function decodeChunk(state, chunk, encoding) {\n          if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n          }\n          return chunk;\n        }\n\n        Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n          // making it explicit this property is not enumerable\n          // because otherwise some prototype manipulation in\n          // userland will fail\n          enumerable: false,\n          get: function get() {\n            return this._writableState.highWaterMark;\n          } });\n\n\n        // if we're already writing something, then just put this\n        // in the queue, and wait our turn.  Otherwise, call _write\n        // If we return false, then we need a drain event, so set that flag.\n        function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n          if (!isBuf) {\n            var newChunk = decodeChunk(state, chunk, encoding);\n            if (chunk !== newChunk) {\n              isBuf = true;\n              encoding = 'buffer';\n              chunk = newChunk;\n            }\n          }\n          var len = state.objectMode ? 1 : chunk.length;\n\n          state.length += len;\n\n          var ret = state.length < state.highWaterMark;\n          // we must ensure that previous needDrain will not be reset to false.\n          if (!ret) state.needDrain = true;\n\n          if (state.writing || state.corked) {\n            var last = state.lastBufferedRequest;\n            state.lastBufferedRequest = {\n              chunk: chunk,\n              encoding: encoding,\n              isBuf: isBuf,\n              callback: cb,\n              next: null };\n\n            if (last) {\n              last.next = state.lastBufferedRequest;\n            } else {\n              state.bufferedRequest = state.lastBufferedRequest;\n            }\n            state.bufferedRequestCount += 1;\n          } else {\n            doWrite(stream, state, false, len, chunk, encoding, cb);\n          }\n\n          return ret;\n        }\n\n        function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n          state.writelen = len;\n          state.writecb = cb;\n          state.writing = true;\n          state.sync = true;\n          if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n          state.sync = false;\n        }\n\n        function onwriteError(stream, state, sync, er, cb) {\n          --state.pendingcb;\n\n          if (sync) {\n            // defer the callback if we are being called synchronously\n            // to avoid piling up things on the stack\n            pna.nextTick(cb, er);\n            // this can emit finish, and it will always happen\n            // after error\n            pna.nextTick(finishMaybe, stream, state);\n            stream._writableState.errorEmitted = true;\n            stream.emit('error', er);\n          } else {\n            // the caller expect this to happen before if\n            // it is async\n            cb(er);\n            stream._writableState.errorEmitted = true;\n            stream.emit('error', er);\n            // this can emit finish, but finish must\n            // always follow error\n            finishMaybe(stream, state);\n          }\n        }\n\n        function onwriteStateUpdate(state) {\n          state.writing = false;\n          state.writecb = null;\n          state.length -= state.writelen;\n          state.writelen = 0;\n        }\n\n        function onwrite(stream, er) {\n          var state = stream._writableState;\n          var sync = state.sync;\n          var cb = state.writecb;\n\n          onwriteStateUpdate(state);\n\n          if (er) onwriteError(stream, state, sync, er, cb);else {\n            // Check if we're actually ready to finish, but don't emit yet\n            var finished = needFinish(state);\n\n            if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n              clearBuffer(stream, state);\n            }\n\n            if (sync) {\n              /*<replacement>*/\n              asyncWrite(afterWrite, stream, state, finished, cb);\n              /*</replacement>*/\n            } else {\n              afterWrite(stream, state, finished, cb);\n            }\n          }\n        }\n\n        function afterWrite(stream, state, finished, cb) {\n          if (!finished) onwriteDrain(stream, state);\n          state.pendingcb--;\n          cb();\n          finishMaybe(stream, state);\n        }\n\n        // Must force callback to be called on nextTick, so that we don't\n        // emit 'drain' before the write() consumer gets the 'false' return\n        // value, and has a chance to attach a 'drain' listener.\n        function onwriteDrain(stream, state) {\n          if (state.length === 0 && state.needDrain) {\n            state.needDrain = false;\n            stream.emit('drain');\n          }\n        }\n\n        // if there's something in the buffer waiting, then process it\n        function clearBuffer(stream, state) {\n          state.bufferProcessing = true;\n          var entry = state.bufferedRequest;\n\n          if (stream._writev && entry && entry.next) {\n            // Fast case, write everything using _writev()\n            var l = state.bufferedRequestCount;\n            var buffer = new Array(l);\n            var holder = state.corkedRequestsFree;\n            holder.entry = entry;\n\n            var count = 0;\n            var allBuffers = true;\n            while (entry) {\n              buffer[count] = entry;\n              if (!entry.isBuf) allBuffers = false;\n              entry = entry.next;\n              count += 1;\n            }\n            buffer.allBuffers = allBuffers;\n\n            doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n            // doWrite is almost always async, defer these to save a bit of time\n            // as the hot path ends with doWrite\n            state.pendingcb++;\n            state.lastBufferedRequest = null;\n            if (holder.next) {\n              state.corkedRequestsFree = holder.next;\n              holder.next = null;\n            } else {\n              state.corkedRequestsFree = new CorkedRequest(state);\n            }\n            state.bufferedRequestCount = 0;\n          } else {\n            // Slow case, write chunks one-by-one\n            while (entry) {\n              var chunk = entry.chunk;\n              var encoding = entry.encoding;\n              var cb = entry.callback;\n              var len = state.objectMode ? 1 : chunk.length;\n\n              doWrite(stream, state, false, len, chunk, encoding, cb);\n              entry = entry.next;\n              state.bufferedRequestCount--;\n              // if we didn't call the onwrite immediately, then\n              // it means that we need to wait until it does.\n              // also, that means that the chunk and cb are currently\n              // being processed, so move the buffer counter past them.\n              if (state.writing) {\n                break;\n              }\n            }\n\n            if (entry === null) state.lastBufferedRequest = null;\n          }\n\n          state.bufferedRequest = entry;\n          state.bufferProcessing = false;\n        }\n\n        Writable.prototype._write = function (chunk, encoding, cb) {\n          cb(new Error('_write() is not implemented'));\n        };\n\n        Writable.prototype._writev = null;\n\n        Writable.prototype.end = function (chunk, encoding, cb) {\n          var state = this._writableState;\n\n          if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = null;\n            encoding = null;\n          } else if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = null;\n          }\n\n          if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n          // .end() fully uncorks\n          if (state.corked) {\n            state.corked = 1;\n            this.uncork();\n          }\n\n          // ignore unnecessary end() calls.\n          if (!state.ending && !state.finished) endWritable(this, state, cb);\n        };\n\n        function needFinish(state) {\n          return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n        }\n        function callFinal(stream, state) {\n          stream._final(function (err) {\n            state.pendingcb--;\n            if (err) {\n              stream.emit('error', err);\n            }\n            state.prefinished = true;\n            stream.emit('prefinish');\n            finishMaybe(stream, state);\n          });\n        }\n        function prefinish(stream, state) {\n          if (!state.prefinished && !state.finalCalled) {\n            if (typeof stream._final === 'function') {\n              state.pendingcb++;\n              state.finalCalled = true;\n              pna.nextTick(callFinal, stream, state);\n            } else {\n              state.prefinished = true;\n              stream.emit('prefinish');\n            }\n          }\n        }\n\n        function finishMaybe(stream, state) {\n          var need = needFinish(state);\n          if (need) {\n            prefinish(stream, state);\n            if (state.pendingcb === 0) {\n              state.finished = true;\n              stream.emit('finish');\n            }\n          }\n          return need;\n        }\n\n        function endWritable(stream, state, cb) {\n          state.ending = true;\n          finishMaybe(stream, state);\n          if (cb) {\n            if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n          }\n          state.ended = true;\n          stream.writable = false;\n        }\n\n        function onCorkedFinish(corkReq, state, err) {\n          var entry = corkReq.entry;\n          corkReq.entry = null;\n          while (entry) {\n            var cb = entry.callback;\n            state.pendingcb--;\n            cb(err);\n            entry = entry.next;\n          }\n          if (state.corkedRequestsFree) {\n            state.corkedRequestsFree.next = corkReq;\n          } else {\n            state.corkedRequestsFree = corkReq;\n          }\n        }\n\n        Object.defineProperty(Writable.prototype, 'destroyed', {\n          get: function get() {\n            if (this._writableState === undefined) {\n              return false;\n            }\n            return this._writableState.destroyed;\n          },\n          set: function set(value) {\n            // we ignore the value if the stream\n            // has not been initialized yet\n            if (!this._writableState) {\n              return;\n            }\n\n            // backward compatibility, the user is explicitly\n            // managing destroyed\n            this._writableState.destroyed = value;\n          } });\n\n\n        Writable.prototype.destroy = destroyImpl.destroy;\n        Writable.prototype._undestroy = destroyImpl.undestroy;\n        Writable.prototype._destroy = function (err, cb) {\n          this.end();\n          cb(err);\n        };\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"timers\").setImmediate);\n    }, { \"./_stream_duplex\": 98, \"./internal/streams/destroy\": 104, \"./internal/streams/stream\": 105, \"_process\": 92, \"core-util-is\": 14, \"inherits\": 80, \"process-nextick-args\": 91, \"safe-buffer\": 110, \"timers\": 112, \"util-deprecate\": 115 }], 103: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n      var Buffer = require('safe-buffer').Buffer;\n      var util = require('util');\n\n      function copyBuffer(src, target, offset) {\n        src.copy(target, offset);\n      }\n\n      module.exports = function () {\n        function BufferList() {\n          _classCallCheck(this, BufferList);\n\n          this.head = null;\n          this.tail = null;\n          this.length = 0;\n        }\n\n        BufferList.prototype.push = function push(v) {\n          var entry = { data: v, next: null };\n          if (this.length > 0) this.tail.next = entry;else this.head = entry;\n          this.tail = entry;\n          ++this.length;\n        };\n\n        BufferList.prototype.unshift = function unshift(v) {\n          var entry = { data: v, next: this.head };\n          if (this.length === 0) this.tail = entry;\n          this.head = entry;\n          ++this.length;\n        };\n\n        BufferList.prototype.shift = function shift() {\n          if (this.length === 0) return;\n          var ret = this.head.data;\n          if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n          --this.length;\n          return ret;\n        };\n\n        BufferList.prototype.clear = function clear() {\n          this.head = this.tail = null;\n          this.length = 0;\n        };\n\n        BufferList.prototype.join = function join(s) {\n          if (this.length === 0) return '';\n          var p = this.head;\n          var ret = '' + p.data;\n          while (p = p.next) {\n            ret += s + p.data;\n          }return ret;\n        };\n\n        BufferList.prototype.concat = function concat(n) {\n          if (this.length === 0) return Buffer.alloc(0);\n          if (this.length === 1) return this.head.data;\n          var ret = Buffer.allocUnsafe(n >>> 0);\n          var p = this.head;\n          var i = 0;\n          while (p) {\n            copyBuffer(p.data, ret, i);\n            i += p.data.length;\n            p = p.next;\n          }\n          return ret;\n        };\n\n        return BufferList;\n      }();\n\n      if (util && util.inspect && util.inspect.custom) {\n        module.exports.prototype[util.inspect.custom] = function () {\n          var obj = util.inspect({ length: this.length });\n          return this.constructor.name + ' ' + obj;\n        };\n      }\n    }, { \"safe-buffer\": 110, \"util\": 11 }], 104: [function (require, module, exports) {\n      'use strict';\n\n      /*<replacement>*/\n\n      var pna = require('process-nextick-args');\n      /*</replacement>*/\n\n      // undocumented cb() API, needed for core, not for public API\n      function destroy(err, cb) {\n        var _this = this;\n\n        var readableDestroyed = this._readableState && this._readableState.destroyed;\n        var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n        if (readableDestroyed || writableDestroyed) {\n          if (cb) {\n            cb(err);\n          } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n            pna.nextTick(emitErrorNT, this, err);\n          }\n          return this;\n        }\n\n        // we set destroyed to true before firing error callbacks in order\n        // to make it re-entrance safe in case destroy() is called within callbacks\n\n        if (this._readableState) {\n          this._readableState.destroyed = true;\n        }\n\n        // if this is a duplex stream mark the writable part as destroyed as well\n        if (this._writableState) {\n          this._writableState.destroyed = true;\n        }\n\n        this._destroy(err || null, function (err) {\n          if (!cb && err) {\n            pna.nextTick(emitErrorNT, _this, err);\n            if (_this._writableState) {\n              _this._writableState.errorEmitted = true;\n            }\n          } else if (cb) {\n            cb(err);\n          }\n        });\n\n        return this;\n      }\n\n      function undestroy() {\n        if (this._readableState) {\n          this._readableState.destroyed = false;\n          this._readableState.reading = false;\n          this._readableState.ended = false;\n          this._readableState.endEmitted = false;\n        }\n\n        if (this._writableState) {\n          this._writableState.destroyed = false;\n          this._writableState.ended = false;\n          this._writableState.ending = false;\n          this._writableState.finished = false;\n          this._writableState.errorEmitted = false;\n        }\n      }\n\n      function emitErrorNT(self, err) {\n        self.emit('error', err);\n      }\n\n      module.exports = {\n        destroy: destroy,\n        undestroy: undestroy };\n\n    }, { \"process-nextick-args\": 91 }], 105: [function (require, module, exports) {\n      module.exports = require('events').EventEmitter;\n\n    }, { \"events\": 13 }], 106: [function (require, module, exports) {\n      var toString = {}.toString;\n\n      module.exports = Array.isArray || function (arr) {\n        return toString.call(arr) == '[object Array]';\n      };\n\n    }, {}], 107: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      'use strict';\n\n      /*<replacement>*/\n\n      var Buffer = require('safe-buffer').Buffer;\n      /*</replacement>*/\n\n      var isEncoding = Buffer.isEncoding || function (encoding) {\n        encoding = '' + encoding;\n        switch (encoding && encoding.toLowerCase()) {\n          case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n            return true;\n          default:\n            return false;}\n\n      };\n\n      function _normalizeEncoding(enc) {\n        if (!enc) return 'utf8';\n        var retried;\n        while (true) {\n          switch (enc) {\n            case 'utf8':\n            case 'utf-8':\n              return 'utf8';\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return 'utf16le';\n            case 'latin1':\n            case 'binary':\n              return 'latin1';\n            case 'base64':\n            case 'ascii':\n            case 'hex':\n              return enc;\n            default:\n              if (retried) return; // undefined\n              enc = ('' + enc).toLowerCase();\n              retried = true;}\n\n        }\n      };\n\n      // Do not cache `Buffer.isEncoding` when checking encoding names as some\n      // modules monkey-patch it to support additional encodings\n      function normalizeEncoding(enc) {\n        var nenc = _normalizeEncoding(enc);\n        if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n        return nenc || enc;\n      }\n\n      // StringDecoder provides an interface for efficiently splitting a series of\n      // buffers into a series of JS strings without breaking apart multi-byte\n      // characters.\n      exports.StringDecoder = StringDecoder;\n      function StringDecoder(encoding) {\n        this.encoding = normalizeEncoding(encoding);\n        var nb;\n        switch (this.encoding) {\n          case 'utf16le':\n            this.text = utf16Text;\n            this.end = utf16End;\n            nb = 4;\n            break;\n          case 'utf8':\n            this.fillLast = utf8FillLast;\n            nb = 4;\n            break;\n          case 'base64':\n            this.text = base64Text;\n            this.end = base64End;\n            nb = 3;\n            break;\n          default:\n            this.write = simpleWrite;\n            this.end = simpleEnd;\n            return;}\n\n        this.lastNeed = 0;\n        this.lastTotal = 0;\n        this.lastChar = Buffer.allocUnsafe(nb);\n      }\n\n      StringDecoder.prototype.write = function (buf) {\n        if (buf.length === 0) return '';\n        var r;\n        var i;\n        if (this.lastNeed) {\n          r = this.fillLast(buf);\n          if (r === undefined) return '';\n          i = this.lastNeed;\n          this.lastNeed = 0;\n        } else {\n          i = 0;\n        }\n        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n        return r || '';\n      };\n\n      StringDecoder.prototype.end = utf8End;\n\n      // Returns only complete characters in a Buffer\n      StringDecoder.prototype.text = utf8Text;\n\n      // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\n      StringDecoder.prototype.fillLast = function (buf) {\n        if (this.lastNeed <= buf.length) {\n          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n          return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n        }\n        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n        this.lastNeed -= buf.length;\n      };\n\n      // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n      // continuation byte. If an invalid byte is detected, -2 is returned.\n      function utf8CheckByte(_byte) {\n        if (_byte <= 0x7F) return 0;else if (_byte >> 5 === 0x06) return 2;else if (_byte >> 4 === 0x0E) return 3;else if (_byte >> 3 === 0x1E) return 4;\n        return _byte >> 6 === 0x02 ? -1 : -2;\n      }\n\n      // Checks at most 3 bytes at the end of a Buffer in order to detect an\n      // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n      // needed to complete the UTF-8 character (if applicable) are returned.\n      function utf8CheckIncomplete(self, buf, i) {\n        var j = buf.length - 1;\n        if (j < i) return 0;\n        var nb = utf8CheckByte(buf[j]);\n        if (nb >= 0) {\n          if (nb > 0) self.lastNeed = nb - 1;\n          return nb;\n        }\n        if (--j < i || nb === -2) return 0;\n        nb = utf8CheckByte(buf[j]);\n        if (nb >= 0) {\n          if (nb > 0) self.lastNeed = nb - 2;\n          return nb;\n        }\n        if (--j < i || nb === -2) return 0;\n        nb = utf8CheckByte(buf[j]);\n        if (nb >= 0) {\n          if (nb > 0) {\n            if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n          }\n          return nb;\n        }\n        return 0;\n      }\n\n      // Validates as many continuation bytes for a multi-byte UTF-8 character as\n      // needed or are available. If we see a non-continuation byte where we expect\n      // one, we \"replace\" the validated continuation bytes we've seen so far with\n      // a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n      // behavior. The continuation byte check is included three times in the case\n      // where all of the continuation bytes for a character exist in the same buffer.\n      // It is also done this way as a slight performance increase instead of using a\n      // loop.\n      function utf8CheckExtraBytes(self, buf, p) {\n        if ((buf[0] & 0xC0) !== 0x80) {\n          self.lastNeed = 0;\n          return \"\\uFFFD\";\n        }\n        if (self.lastNeed > 1 && buf.length > 1) {\n          if ((buf[1] & 0xC0) !== 0x80) {\n            self.lastNeed = 1;\n            return \"\\uFFFD\";\n          }\n          if (self.lastNeed > 2 && buf.length > 2) {\n            if ((buf[2] & 0xC0) !== 0x80) {\n              self.lastNeed = 2;\n              return \"\\uFFFD\";\n            }\n          }\n        }\n      }\n\n      // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\n      function utf8FillLast(buf) {\n        var p = this.lastTotal - this.lastNeed;\n        var r = utf8CheckExtraBytes(this, buf, p);\n        if (r !== undefined) return r;\n        if (this.lastNeed <= buf.length) {\n          buf.copy(this.lastChar, p, 0, this.lastNeed);\n          return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n        }\n        buf.copy(this.lastChar, p, 0, buf.length);\n        this.lastNeed -= buf.length;\n      }\n\n      // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n      // partial character, the character's bytes are buffered until the required\n      // number of bytes are available.\n      function utf8Text(buf, i) {\n        var total = utf8CheckIncomplete(this, buf, i);\n        if (!this.lastNeed) return buf.toString('utf8', i);\n        this.lastTotal = total;\n        var end = buf.length - (total - this.lastNeed);\n        buf.copy(this.lastChar, 0, end);\n        return buf.toString('utf8', i, end);\n      }\n\n      // For UTF-8, a replacement character is added when ending on a partial\n      // character.\n      function utf8End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) return r + \"\\uFFFD\";\n        return r;\n      }\n\n      // UTF-16LE typically needs two bytes per character, but even if we have an even\n      // number of bytes available, we need to check if we end on a leading/high\n      // surrogate. In that case, we need to wait for the next two bytes in order to\n      // decode the last character properly.\n      function utf16Text(buf, i) {\n        if ((buf.length - i) % 2 === 0) {\n          var r = buf.toString('utf16le', i);\n          if (r) {\n            var c = r.charCodeAt(r.length - 1);\n            if (c >= 0xD800 && c <= 0xDBFF) {\n              this.lastNeed = 2;\n              this.lastTotal = 4;\n              this.lastChar[0] = buf[buf.length - 2];\n              this.lastChar[1] = buf[buf.length - 1];\n              return r.slice(0, -1);\n            }\n          }\n          return r;\n        }\n        this.lastNeed = 1;\n        this.lastTotal = 2;\n        this.lastChar[0] = buf[buf.length - 1];\n        return buf.toString('utf16le', i, buf.length - 1);\n      }\n\n      // For UTF-16LE we do not explicitly append special replacement characters if we\n      // end on a partial character, we simply let v8 handle that.\n      function utf16End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) {\n          var end = this.lastTotal - this.lastNeed;\n          return r + this.lastChar.toString('utf16le', 0, end);\n        }\n        return r;\n      }\n\n      function base64Text(buf, i) {\n        var n = (buf.length - i) % 3;\n        if (n === 0) return buf.toString('base64', i);\n        this.lastNeed = 3 - n;\n        this.lastTotal = 3;\n        if (n === 1) {\n          this.lastChar[0] = buf[buf.length - 1];\n        } else {\n          this.lastChar[0] = buf[buf.length - 2];\n          this.lastChar[1] = buf[buf.length - 1];\n        }\n        return buf.toString('base64', i, buf.length - n);\n      }\n\n      function base64End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n        return r;\n      }\n\n      // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\n      function simpleWrite(buf) {\n        return buf.toString(this.encoding);\n      }\n\n      function simpleEnd(buf) {\n        return buf && buf.length ? this.write(buf) : '';\n      }\n    }, { \"safe-buffer\": 110 }], 108: [function (require, module, exports) {\n      exports = module.exports = require('./lib/_stream_readable.js');\n      exports.Stream = exports;\n      exports.Readable = exports;\n      exports.Writable = require('./lib/_stream_writable.js');\n      exports.Duplex = require('./lib/_stream_duplex.js');\n      exports.Transform = require('./lib/_stream_transform.js');\n      exports.PassThrough = require('./lib/_stream_passthrough.js');\n\n    }, { \"./lib/_stream_duplex.js\": 98, \"./lib/_stream_passthrough.js\": 99, \"./lib/_stream_readable.js\": 100, \"./lib/_stream_transform.js\": 101, \"./lib/_stream_writable.js\": 102 }], 109: [function (require, module, exports) {\n      'use strict';\n\n      function ReInterval(callback, interval, args) {\n        var self = this;\n\n        this._callback = callback;\n        this._args = args;\n\n        this._interval = setInterval(callback, interval, this._args);\n\n        this.reschedule = function (interval) {\n          // if no interval entered, use the interval passed in on creation\n          if (!interval)\n          interval = self._interval;\n\n          if (self._interval)\n          clearInterval(self._interval);\n          self._interval = setInterval(self._callback, interval, self._args);\n        };\n\n        this.clear = function () {\n          if (self._interval) {\n            clearInterval(self._interval);\n            self._interval = undefined;\n          }\n        };\n\n        this.destroy = function () {\n          if (self._interval) {\n            clearInterval(self._interval);\n          }\n          self._callback = undefined;\n          self._interval = undefined;\n          self._args = undefined;\n        };\n      }\n\n      function reInterval() {\n        if (typeof arguments[0] !== 'function')\n        throw new Error('callback needed');\n        if (typeof arguments[1] !== 'number')\n        throw new Error('interval needed');\n\n        var args;\n\n        if (arguments.length > 0) {\n          args = new Array(arguments.length - 2);\n\n          for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 2];\n          }\n        }\n\n        return new ReInterval(arguments[0], arguments[1], args);\n      }\n\n      module.exports = reInterval;\n\n    }, {}], 110: [function (require, module, exports) {\n      /* eslint-disable node/no-deprecated-api */\n      var buffer = require('buffer');\n      var Buffer = buffer.Buffer;\n\n      // alternative to using Object.keys for old browsers\n      function copyProps(src, dst) {\n        for (var key in src) {\n          dst[key] = src[key];\n        }\n      }\n      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n        module.exports = buffer;\n      } else {\n        // Copy properties from require('buffer')\n        copyProps(buffer, exports);\n        exports.Buffer = SafeBuffer;\n      }\n\n      function SafeBuffer(arg, encodingOrOffset, length) {\n        return Buffer(arg, encodingOrOffset, length);\n      }\n\n      // Copy static methods from Buffer\n      copyProps(Buffer, SafeBuffer);\n\n      SafeBuffer.from = function (arg, encodingOrOffset, length) {\n        if (typeof arg === 'number') {\n          throw new TypeError('Argument must not be a number');\n        }\n        return Buffer(arg, encodingOrOffset, length);\n      };\n\n      SafeBuffer.alloc = function (size, fill, encoding) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n        var buf = Buffer(size);\n        if (fill !== undefined) {\n          if (typeof encoding === 'string') {\n            buf.fill(fill, encoding);\n          } else {\n            buf.fill(fill);\n          }\n        } else {\n          buf.fill(0);\n        }\n        return buf;\n      };\n\n      SafeBuffer.allocUnsafe = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n        return Buffer(size);\n      };\n\n      SafeBuffer.allocUnsafeSlow = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n        return buffer.SlowBuffer(size);\n      };\n\n    }, { \"buffer\": 12 }], 111: [function (require, module, exports) {\n      module.exports = shift;\n\n      function shift(stream) {\n        var rs = stream._readableState;\n        if (!rs) return null;\n        return rs.objectMode ? stream.read() : stream.read(getStateLength(rs));\n      }\n\n      function getStateLength(state) {\n        if (state.buffer.length) {\n          // Since node 6.3.0 state.buffer is a BufferList not an array\n          if (state.buffer.head) {\n            return state.buffer.head.data.length;\n          }\n\n          return state.buffer[0].length;\n        }\n\n        return state.length;\n      }\n\n    }, {}], 112: [function (require, module, exports) {\n      (function (setImmediate, clearImmediate) {\n        var nextTick = require('process/browser.js').nextTick;\n        var apply = Function.prototype.apply;\n        var slice = Array.prototype.slice;\n        var immediateIds = {};\n        var nextImmediateId = 0;\n\n        // DOM APIs, for completeness\n\n        exports.setTimeout = function () {\n          return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n        };\n        exports.setInterval = function () {\n          return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n        };\n        exports.clearTimeout =\n        exports.clearInterval = function (timeout) {timeout.close();};\n\n        function Timeout(id, clearFn) {\n          this._id = id;\n          this._clearFn = clearFn;\n        }\n        Timeout.prototype.unref = Timeout.prototype.ref = function () {};\n        Timeout.prototype.close = function () {\n          this._clearFn.call(window, this._id);\n        };\n\n        // Does not start the time, just sets up the members needed.\n        exports.enroll = function (item, msecs) {\n          clearTimeout(item._idleTimeoutId);\n          item._idleTimeout = msecs;\n        };\n\n        exports.unenroll = function (item) {\n          clearTimeout(item._idleTimeoutId);\n          item._idleTimeout = -1;\n        };\n\n        exports._unrefActive = exports.active = function (item) {\n          clearTimeout(item._idleTimeoutId);\n\n          var msecs = item._idleTimeout;\n          if (msecs >= 0) {\n            item._idleTimeoutId = setTimeout(function onTimeout() {\n              if (item._onTimeout)\n              item._onTimeout();\n            }, msecs);\n          }\n        };\n\n        // That's not how node.js implements it but the exposed api is the same.\n        exports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function (fn) {\n          var id = nextImmediateId++;\n          var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n          immediateIds[id] = true;\n\n          nextTick(function onNextTick() {\n            if (immediateIds[id]) {\n              // fn.call() is faster so we optimize for the common use-case\n              // @see http://jsperf.com/call-apply-segu\n              if (args) {\n                fn.apply(null, args);\n              } else {\n                fn.call(null);\n              }\n              // Prevent ids from leaking\n              exports.clearImmediate(id);\n            }\n          });\n\n          return id;\n        };\n\n        exports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function (id) {\n          delete immediateIds[id];\n        };\n      }).call(this, require(\"timers\").setImmediate, require(\"timers\").clearImmediate);\n    }, { \"process/browser.js\": 92, \"timers\": 112 }], 113: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      'use strict';\n\n      var punycode = require('punycode');\n      var util = require('./util');\n\n      exports.parse = urlParse;\n      exports.resolve = urlResolve;\n      exports.resolveObject = urlResolveObject;\n      exports.format = urlFormat;\n\n      exports.Url = Url;\n\n      function Url() {\n        this.protocol = null;\n        this.slashes = null;\n        this.auth = null;\n        this.host = null;\n        this.port = null;\n        this.hostname = null;\n        this.hash = null;\n        this.search = null;\n        this.query = null;\n        this.pathname = null;\n        this.path = null;\n        this.href = null;\n      }\n\n      // Reference: RFC 3986, RFC 1808, RFC 2396\n\n      // define these here so at least they only have to be\n      // compiled once on the first module load.\n      var protocolPattern = /^([a-z0-9.+-]+:)/i,\n      portPattern = /:[0-9]*$/,\n\n      // Special case for a simple path URL\n      simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n      // RFC 2396: characters reserved for delimiting URLs.\n      // We actually just auto-escape these.\n      delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n      // RFC 2396: characters not allowed for various reasons.\n      unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n      // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n      autoEscape = ['\\''].concat(unwise),\n      // Characters that are never ever allowed in a hostname.\n      // Note that any invalid chars are also handled, but these\n      // are the ones that are *expected* to be seen, so we fast-path\n      // them.\n      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n      hostEndingChars = ['/', '?', '#'],\n      hostnameMaxLen = 255,\n      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n      // protocols that can allow \"unsafe\" and \"unwise\" chars.\n      unsafeProtocol = {\n        'javascript': true,\n        'javascript:': true },\n\n      // protocols that never have a hostname.\n      hostlessProtocol = {\n        'javascript': true,\n        'javascript:': true },\n\n      // protocols that always contain a // bit.\n      slashedProtocol = {\n        'http': true,\n        'https': true,\n        'ftp': true,\n        'gopher': true,\n        'file': true,\n        'http:': true,\n        'https:': true,\n        'ftp:': true,\n        'gopher:': true,\n        'file:': true },\n\n      querystring = require('querystring');\n\n      function urlParse(url, parseQueryString, slashesDenoteHost) {\n        if (url && util.isObject(url) && url instanceof Url) return url;\n\n        var u = new Url();\n        u.parse(url, parseQueryString, slashesDenoteHost);\n        return u;\n      }\n\n      Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n        if (!util.isString(url)) {\n          throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n        }\n\n        // Copy chrome, IE, opera backslash-handling behavior.\n        // Back slashes before the query string get converted to forward slashes\n        // See: https://code.google.com/p/chromium/issues/detail?id=25916\n        var queryIndex = url.indexOf('?'),\n        splitter =\n        queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n        uSplit = url.split(splitter),\n        slashRegex = /\\\\/g;\n        uSplit[0] = uSplit[0].replace(slashRegex, '/');\n        url = uSplit.join(splitter);\n\n        var rest = url;\n\n        // trim before proceeding.\n        // This is to support parse stuff like \"  http://foo.com  \\n\"\n        rest = rest.trim();\n\n        if (!slashesDenoteHost && url.split('#').length === 1) {\n          // Try fast path regexp\n          var simplePath = simplePathPattern.exec(rest);\n          if (simplePath) {\n            this.path = rest;\n            this.href = rest;\n            this.pathname = simplePath[1];\n            if (simplePath[2]) {\n              this.search = simplePath[2];\n              if (parseQueryString) {\n                this.query = querystring.parse(this.search.substr(1));\n              } else {\n                this.query = this.search.substr(1);\n              }\n            } else if (parseQueryString) {\n              this.search = '';\n              this.query = {};\n            }\n            return this;\n          }\n        }\n\n        var proto = protocolPattern.exec(rest);\n        if (proto) {\n          proto = proto[0];\n          var lowerProto = proto.toLowerCase();\n          this.protocol = lowerProto;\n          rest = rest.substr(proto.length);\n        }\n\n        // figure out if it's got a host\n        // user@server is *always* interpreted as a hostname, and url\n        // resolution will treat //foo/bar as host=foo,path=bar because that's\n        // how the browser resolves relative URLs.\n        if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n          var slashes = rest.substr(0, 2) === '//';\n          if (slashes && !(proto && hostlessProtocol[proto])) {\n            rest = rest.substr(2);\n            this.slashes = true;\n          }\n        }\n\n        if (!hostlessProtocol[proto] && (\n        slashes || proto && !slashedProtocol[proto])) {\n\n          // there's a hostname.\n          // the first instance of /, ?, ;, or # ends the host.\n          //\n          // If there is an @ in the hostname, then non-host chars *are* allowed\n          // to the left of the last @ sign, unless some host-ending character\n          // comes *before* the @-sign.\n          // URLs are obnoxious.\n          //\n          // ex:\n          // http://a@b@c/ => user:a@b host:c\n          // http://a@b?@c => user:a host:c path:/?@c\n\n          // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n          // Review our test case against browsers more comprehensively.\n\n          // find the first instance of any hostEndingChars\n          var hostEnd = -1;\n          for (var i = 0; i < hostEndingChars.length; i++) {\n            var hec = rest.indexOf(hostEndingChars[i]);\n            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n            hostEnd = hec;\n          }\n\n          // at this point, either we have an explicit point where the\n          // auth portion cannot go past, or the last @ char is the decider.\n          var auth, atSign;\n          if (hostEnd === -1) {\n            // atSign can be anywhere.\n            atSign = rest.lastIndexOf('@');\n          } else {\n            // atSign must be in auth portion.\n            // http://a@b/c@d => host:b auth:a path:/c@d\n            atSign = rest.lastIndexOf('@', hostEnd);\n          }\n\n          // Now we have a portion which is definitely the auth.\n          // Pull that off.\n          if (atSign !== -1) {\n            auth = rest.slice(0, atSign);\n            rest = rest.slice(atSign + 1);\n            this.auth = decodeURIComponent(auth);\n          }\n\n          // the host is the remaining to the left of the first non-host char\n          hostEnd = -1;\n          for (var i = 0; i < nonHostChars.length; i++) {\n            var hec = rest.indexOf(nonHostChars[i]);\n            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n            hostEnd = hec;\n          }\n          // if we still have not hit it, then the entire thing is a host.\n          if (hostEnd === -1)\n          hostEnd = rest.length;\n\n          this.host = rest.slice(0, hostEnd);\n          rest = rest.slice(hostEnd);\n\n          // pull out port.\n          this.parseHost();\n\n          // we've indicated that there is a hostname,\n          // so even if it's empty, it has to be present.\n          this.hostname = this.hostname || '';\n\n          // if hostname begins with [ and ends with ]\n          // assume that it's an IPv6 address.\n          var ipv6Hostname = this.hostname[0] === '[' &&\n          this.hostname[this.hostname.length - 1] === ']';\n\n          // validate a little.\n          if (!ipv6Hostname) {\n            var hostparts = this.hostname.split(/\\./);\n            for (var i = 0, l = hostparts.length; i < l; i++) {\n              var part = hostparts[i];\n              if (!part) continue;\n              if (!part.match(hostnamePartPattern)) {\n                var newpart = '';\n                for (var j = 0, k = part.length; j < k; j++) {\n                  if (part.charCodeAt(j) > 127) {\n                    // we replace non-ASCII char with a temporary placeholder\n                    // we need this to make sure size of hostname is not\n                    // broken by replacing non-ASCII by nothing\n                    newpart += 'x';\n                  } else {\n                    newpart += part[j];\n                  }\n                }\n                // we test again with ASCII char only\n                if (!newpart.match(hostnamePartPattern)) {\n                  var validParts = hostparts.slice(0, i);\n                  var notHost = hostparts.slice(i + 1);\n                  var bit = part.match(hostnamePartStart);\n                  if (bit) {\n                    validParts.push(bit[1]);\n                    notHost.unshift(bit[2]);\n                  }\n                  if (notHost.length) {\n                    rest = '/' + notHost.join('.') + rest;\n                  }\n                  this.hostname = validParts.join('.');\n                  break;\n                }\n              }\n            }\n          }\n\n          if (this.hostname.length > hostnameMaxLen) {\n            this.hostname = '';\n          } else {\n            // hostnames are always lower case.\n            this.hostname = this.hostname.toLowerCase();\n          }\n\n          if (!ipv6Hostname) {\n            // IDNA Support: Returns a punycoded representation of \"domain\".\n            // It only converts parts of the domain name that\n            // have non-ASCII characters, i.e. it doesn't matter if\n            // you call it with a domain that already is ASCII-only.\n            this.hostname = punycode.toASCII(this.hostname);\n          }\n\n          var p = this.port ? ':' + this.port : '';\n          var h = this.hostname || '';\n          this.host = h + p;\n          this.href += this.host;\n\n          // strip [ and ] from the hostname\n          // the host field still retains them, though\n          if (ipv6Hostname) {\n            this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n            if (rest[0] !== '/') {\n              rest = '/' + rest;\n            }\n          }\n        }\n\n        // now rest is set to the post-host stuff.\n        // chop off any delim chars.\n        if (!unsafeProtocol[lowerProto]) {\n\n          // First, make 100% sure that any \"autoEscape\" chars get\n          // escaped, even if encodeURIComponent doesn't think they\n          // need to be.\n          for (var i = 0, l = autoEscape.length; i < l; i++) {\n            var ae = autoEscape[i];\n            if (rest.indexOf(ae) === -1)\n            continue;\n            var esc = encodeURIComponent(ae);\n            if (esc === ae) {\n              esc = escape(ae);\n            }\n            rest = rest.split(ae).join(esc);\n          }\n        }\n\n\n        // chop off from the tail first.\n        var hash = rest.indexOf('#');\n        if (hash !== -1) {\n          // got a fragment string.\n          this.hash = rest.substr(hash);\n          rest = rest.slice(0, hash);\n        }\n        var qm = rest.indexOf('?');\n        if (qm !== -1) {\n          this.search = rest.substr(qm);\n          this.query = rest.substr(qm + 1);\n          if (parseQueryString) {\n            this.query = querystring.parse(this.query);\n          }\n          rest = rest.slice(0, qm);\n        } else if (parseQueryString) {\n          // no query string, but parseQueryString still requested\n          this.search = '';\n          this.query = {};\n        }\n        if (rest) this.pathname = rest;\n        if (slashedProtocol[lowerProto] &&\n        this.hostname && !this.pathname) {\n          this.pathname = '/';\n        }\n\n        //to support http.request\n        if (this.pathname || this.search) {\n          var p = this.pathname || '';\n          var s = this.search || '';\n          this.path = p + s;\n        }\n\n        // finally, reconstruct the href based on what has been validated.\n        this.href = this.format();\n        return this;\n      };\n\n      // format a parsed object into a url string\n      function urlFormat(obj) {\n        // ensure it's an object, and not a string url.\n        // If it's an obj, this is a no-op.\n        // this way, you can call url_format() on strings\n        // to clean up potentially wonky urls.\n        if (util.isString(obj)) obj = urlParse(obj);\n        if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n        return obj.format();\n      }\n\n      Url.prototype.format = function () {\n        var auth = this.auth || '';\n        if (auth) {\n          auth = encodeURIComponent(auth);\n          auth = auth.replace(/%3A/i, ':');\n          auth += '@';\n        }\n\n        var protocol = this.protocol || '',\n        pathname = this.pathname || '',\n        hash = this.hash || '',\n        host = false,\n        query = '';\n\n        if (this.host) {\n          host = auth + this.host;\n        } else if (this.hostname) {\n          host = auth + (this.hostname.indexOf(':') === -1 ?\n          this.hostname :\n          '[' + this.hostname + ']');\n          if (this.port) {\n            host += ':' + this.port;\n          }\n        }\n\n        if (this.query &&\n        util.isObject(this.query) &&\n        Object.keys(this.query).length) {\n          query = querystring.stringify(this.query);\n        }\n\n        var search = this.search || query && '?' + query || '';\n\n        if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n        // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n        // unless they had them to begin with.\n        if (this.slashes ||\n        (!protocol || slashedProtocol[protocol]) && host !== false) {\n          host = '//' + (host || '');\n          if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n        } else if (!host) {\n          host = '';\n        }\n\n        if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n        if (search && search.charAt(0) !== '?') search = '?' + search;\n\n        pathname = pathname.replace(/[?#]/g, function (match) {\n          return encodeURIComponent(match);\n        });\n        search = search.replace('#', '%23');\n\n        return protocol + host + pathname + search + hash;\n      };\n\n      function urlResolve(source, relative) {\n        return urlParse(source, false, true).resolve(relative);\n      }\n\n      Url.prototype.resolve = function (relative) {\n        return this.resolveObject(urlParse(relative, false, true)).format();\n      };\n\n      function urlResolveObject(source, relative) {\n        if (!source) return relative;\n        return urlParse(source, false, true).resolveObject(relative);\n      }\n\n      Url.prototype.resolveObject = function (relative) {\n        if (util.isString(relative)) {\n          var rel = new Url();\n          rel.parse(relative, false, true);\n          relative = rel;\n        }\n\n        var result = new Url();\n        var tkeys = Object.keys(this);\n        for (var tk = 0; tk < tkeys.length; tk++) {\n          var tkey = tkeys[tk];\n          result[tkey] = this[tkey];\n        }\n\n        // hash is always overridden, no matter what.\n        // even href=\"\" will remove it.\n        result.hash = relative.hash;\n\n        // if the relative url is empty, then there's nothing left to do here.\n        if (relative.href === '') {\n          result.href = result.format();\n          return result;\n        }\n\n        // hrefs like //foo/bar always cut to the protocol.\n        if (relative.slashes && !relative.protocol) {\n          // take everything except the protocol from relative\n          var rkeys = Object.keys(relative);\n          for (var rk = 0; rk < rkeys.length; rk++) {\n            var rkey = rkeys[rk];\n            if (rkey !== 'protocol')\n            result[rkey] = relative[rkey];\n          }\n\n          //urlParse appends trailing / to urls like http://www.example.com\n          if (slashedProtocol[result.protocol] &&\n          result.hostname && !result.pathname) {\n            result.path = result.pathname = '/';\n          }\n\n          result.href = result.format();\n          return result;\n        }\n\n        if (relative.protocol && relative.protocol !== result.protocol) {\n          // if it's a known url protocol, then changing\n          // the protocol does weird things\n          // first, if it's not file:, then we MUST have a host,\n          // and if there was a path\n          // to begin with, then we MUST have a path.\n          // if it is file:, then the host is dropped,\n          // because that's known to be hostless.\n          // anything else is assumed to be absolute.\n          if (!slashedProtocol[relative.protocol]) {\n            var keys = Object.keys(relative);\n            for (var v = 0; v < keys.length; v++) {\n              var k = keys[v];\n              result[k] = relative[k];\n            }\n            result.href = result.format();\n            return result;\n          }\n\n          result.protocol = relative.protocol;\n          if (!relative.host && !hostlessProtocol[relative.protocol]) {\n            var relPath = (relative.pathname || '').split('/');\n            while (relPath.length && !(relative.host = relPath.shift())) {;}\n            if (!relative.host) relative.host = '';\n            if (!relative.hostname) relative.hostname = '';\n            if (relPath[0] !== '') relPath.unshift('');\n            if (relPath.length < 2) relPath.unshift('');\n            result.pathname = relPath.join('/');\n          } else {\n            result.pathname = relative.pathname;\n          }\n          result.search = relative.search;\n          result.query = relative.query;\n          result.host = relative.host || '';\n          result.auth = relative.auth;\n          result.hostname = relative.hostname || relative.host;\n          result.port = relative.port;\n          // to support http.request\n          if (result.pathname || result.search) {\n            var p = result.pathname || '';\n            var s = result.search || '';\n            result.path = p + s;\n          }\n          result.slashes = result.slashes || relative.slashes;\n          result.href = result.format();\n          return result;\n        }\n\n        var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n        isRelAbs =\n        relative.host ||\n        relative.pathname && relative.pathname.charAt(0) === '/',\n\n        mustEndAbs = isRelAbs || isSourceAbs ||\n        result.host && relative.pathname,\n        removeAllDots = mustEndAbs,\n        srcPath = result.pathname && result.pathname.split('/') || [],\n        relPath = relative.pathname && relative.pathname.split('/') || [],\n        psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n        // if the url is a non-slashed url, then relative\n        // links like ../.. should be able\n        // to crawl up to the hostname, as well.  This is strange.\n        // result.protocol has already been set by now.\n        // Later on, put the first path part into the host field.\n        if (psychotic) {\n          result.hostname = '';\n          result.port = null;\n          if (result.host) {\n            if (srcPath[0] === '') srcPath[0] = result.host;else\n            srcPath.unshift(result.host);\n          }\n          result.host = '';\n          if (relative.protocol) {\n            relative.hostname = null;\n            relative.port = null;\n            if (relative.host) {\n              if (relPath[0] === '') relPath[0] = relative.host;else\n              relPath.unshift(relative.host);\n            }\n            relative.host = null;\n          }\n          mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n        }\n\n        if (isRelAbs) {\n          // it's absolute.\n          result.host = relative.host || relative.host === '' ?\n          relative.host : result.host;\n          result.hostname = relative.hostname || relative.hostname === '' ?\n          relative.hostname : result.hostname;\n          result.search = relative.search;\n          result.query = relative.query;\n          srcPath = relPath;\n          // fall through to the dot-handling below.\n        } else if (relPath.length) {\n          // it's relative\n          // throw away the existing file, and take the new path instead.\n          if (!srcPath) srcPath = [];\n          srcPath.pop();\n          srcPath = srcPath.concat(relPath);\n          result.search = relative.search;\n          result.query = relative.query;\n        } else if (!util.isNullOrUndefined(relative.search)) {\n          // just pull out the search.\n          // like href='?foo'.\n          // Put this after the other two cases because it simplifies the booleans\n          if (psychotic) {\n            result.hostname = result.host = srcPath.shift();\n            //occationaly the auth can get stuck only in host\n            //this especially happens in cases like\n            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n            var authInHost = result.host && result.host.indexOf('@') > 0 ?\n            result.host.split('@') : false;\n            if (authInHost) {\n              result.auth = authInHost.shift();\n              result.host = result.hostname = authInHost.shift();\n            }\n          }\n          result.search = relative.search;\n          result.query = relative.query;\n          //to support http.request\n          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n            result.path = (result.pathname ? result.pathname : '') + (\n            result.search ? result.search : '');\n          }\n          result.href = result.format();\n          return result;\n        }\n\n        if (!srcPath.length) {\n          // no path at all.  easy.\n          // we've already handled the other stuff above.\n          result.pathname = null;\n          //to support http.request\n          if (result.search) {\n            result.path = '/' + result.search;\n          } else {\n            result.path = null;\n          }\n          result.href = result.format();\n          return result;\n        }\n\n        // if a url ENDs in . or .., then it must get a trailing slash.\n        // however, if it ends in anything else non-slashy,\n        // then it must NOT get a trailing slash.\n        var last = srcPath.slice(-1)[0];\n        var hasTrailingSlash =\n        (result.host || relative.host || srcPath.length > 1) && (\n        last === '.' || last === '..') || last === '';\n\n        // strip single dots, resolve double dots to parent dir\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = srcPath.length; i >= 0; i--) {\n          last = srcPath[i];\n          if (last === '.') {\n            srcPath.splice(i, 1);\n          } else if (last === '..') {\n            srcPath.splice(i, 1);\n            up++;\n          } else if (up) {\n            srcPath.splice(i, 1);\n            up--;\n          }\n        }\n\n        // if the path is allowed to go above the root, restore leading ..s\n        if (!mustEndAbs && !removeAllDots) {\n          for (; up--; up) {\n            srcPath.unshift('..');\n          }\n        }\n\n        if (mustEndAbs && srcPath[0] !== '' && (\n        !srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n          srcPath.unshift('');\n        }\n\n        if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n          srcPath.push('');\n        }\n\n        var isAbsolute = srcPath[0] === '' ||\n        srcPath[0] && srcPath[0].charAt(0) === '/';\n\n        // put the host back\n        if (psychotic) {\n          result.hostname = result.host = isAbsolute ? '' :\n          srcPath.length ? srcPath.shift() : '';\n          //occationaly the auth can get stuck only in host\n          //this especially happens in cases like\n          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n          var authInHost = result.host && result.host.indexOf('@') > 0 ?\n          result.host.split('@') : false;\n          if (authInHost) {\n            result.auth = authInHost.shift();\n            result.host = result.hostname = authInHost.shift();\n          }\n        }\n\n        mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n        if (mustEndAbs && !isAbsolute) {\n          srcPath.unshift('');\n        }\n\n        if (!srcPath.length) {\n          result.pathname = null;\n          result.path = null;\n        } else {\n          result.pathname = srcPath.join('/');\n        }\n\n        //to support request.http\n        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n          result.path = (result.pathname ? result.pathname : '') + (\n          result.search ? result.search : '');\n        }\n        result.auth = relative.auth || result.auth;\n        result.slashes = result.slashes || relative.slashes;\n        result.href = result.format();\n        return result;\n      };\n\n      Url.prototype.parseHost = function () {\n        var host = this.host;\n        var port = portPattern.exec(host);\n        if (port) {\n          port = port[0];\n          if (port !== ':') {\n            this.port = port.substr(1);\n          }\n          host = host.substr(0, host.length - port.length);\n        }\n        if (host) this.hostname = host;\n      };\n\n    }, { \"./util\": 114, \"punycode\": 93, \"querystring\": 96 }], 114: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = {\n        isString: function isString(arg) {\n          return typeof arg === 'string';\n        },\n        isObject: function isObject(arg) {\n          return typeof arg === 'object' && arg !== null;\n        },\n        isNull: function isNull(arg) {\n          return arg === null;\n        },\n        isNullOrUndefined: function isNullOrUndefined(arg) {\n          return arg == null;\n        } };\n\n\n    }, {}], 115: [function (require, module, exports) {\n      (function (global) {\n\n        /**\n                           * Module exports.\n                           */\n\n        module.exports = deprecate;\n\n        /**\n                                     * Mark that a method should not be used.\n                                     * Returns a modified function which warns once by default.\n                                     *\n                                     * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n                                     *\n                                     * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n                                     * will throw an Error when invoked.\n                                     *\n                                     * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n                                     * will invoke `console.trace()` instead of `console.error()`.\n                                     *\n                                     * @param {Function} fn - the function to deprecate\n                                     * @param {String} msg - the string to print to the console when `fn` is invoked\n                                     * @returns {Function} a new \"deprecated\" version of `fn`\n                                     * @api public\n                                     */\n\n        function deprecate(fn, msg) {\n          if (config('noDeprecation')) {\n            return fn;\n          }\n\n          var warned = false;\n          function deprecated() {\n            if (!warned) {\n              if (config('throwDeprecation')) {\n                throw new Error(msg);\n              } else if (config('traceDeprecation')) {\n                console.trace(msg);\n              } else {\n                __f__(\"warn\", msg, \" at utils/mqtt.js:13761\");\n              }\n              warned = true;\n            }\n            return fn.apply(this, arguments);\n          }\n\n          return deprecated;\n        }\n\n        /**\n           * Checks `localStorage` for boolean values for the given `name`.\n           *\n           * @param {String} name\n           * @returns {Boolean}\n           * @api private\n           */\n\n        function config(name) {\n          // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n          try {\n            if (!global.localStorage) return false;\n          } catch (_) {\n            return false;\n          }\n          var val = global.localStorage[name];\n          if (null == val) return false;\n          return String(val).toLowerCase() === 'true';\n        }\n\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}], 116: [function (require, module, exports) {\n      module.exports = function isBuffer(arg) {\n        return arg && typeof arg === 'object' &&\n        typeof arg.copy === 'function' &&\n        typeof arg.fill === 'function' &&\n        typeof arg.readUInt8 === 'function';\n      };\n    }, {}], 117: [function (require, module, exports) {\n      (function (process, global) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        var formatRegExp = /%[sdj%]/g;\n        exports.format = function (f) {\n          if (!isString(f)) {\n            var objects = [];\n            for (var i = 0; i < arguments.length; i++) {\n              objects.push(inspect(arguments[i]));\n            }\n            return objects.join(' ');\n          }\n\n          var i = 1;\n          var args = arguments;\n          var len = args.length;\n          var str = String(f).replace(formatRegExp, function (x) {\n            if (x === '%%') return '%';\n            if (i >= len) return x;\n            switch (x) {\n              case '%s':return String(args[i++]);\n              case '%d':return Number(args[i++]);\n              case '%j':\n                try {\n                  return JSON.stringify(args[i++]);\n                } catch (_) {\n                  return '[Circular]';\n                }\n              default:\n                return x;}\n\n          });\n          for (var x = args[i]; i < len; x = args[++i]) {\n            if (isNull(x) || !isObject(x)) {\n              str += ' ' + x;\n            } else {\n              str += ' ' + inspect(x);\n            }\n          }\n          return str;\n        };\n\n\n        // Mark that a method should not be used.\n        // Returns a modified function which warns once by default.\n        // If --no-deprecation is set, then it is a no-op.\n        exports.deprecate = function (fn, msg) {\n          // Allow for deprecating things in the process of starting up.\n          if (isUndefined(global.process)) {\n            return function () {\n              return exports.deprecate(fn, msg).apply(this, arguments);\n            };\n          }\n\n          if (process.noDeprecation === true) {\n            return fn;\n          }\n\n          var warned = false;\n          function deprecated() {\n            if (!warned) {\n              if (process.throwDeprecation) {\n                throw new Error(msg);\n              } else if (process.traceDeprecation) {\n                console.trace(msg);\n              } else {\n                __f__(\"error\", msg, \" at utils/mqtt.js:13885\");\n              }\n              warned = true;\n            }\n            return fn.apply(this, arguments);\n          }\n\n          return deprecated;\n        };\n\n\n        var debugs = {};\n        var debugEnviron;\n        exports.debuglog = function (set) {\n          if (isUndefined(debugEnviron))\n          debugEnviron = process.env.NODE_DEBUG || '';\n          set = set.toUpperCase();\n          if (!debugs[set]) {\n            if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n              var pid = process.pid;\n              debugs[set] = function () {\n                var msg = exports.format.apply(exports, arguments);\n                __f__(\"error\", '%s %d: %s', set, pid, msg, \" at utils/mqtt.js:13907\");\n              };\n            } else {\n              debugs[set] = function () {};\n            }\n          }\n          return debugs[set];\n        };\n\n\n        /**\n            * Echos the value of a value. Trys to print the value out\n            * in the best way possible given the different types.\n            *\n            * @param {Object} obj The object to print out.\n            * @param {Object} opts Optional options object that alters the output.\n            */\n        /* legacy: obj, showHidden, depth, colors*/\n        function inspect(obj, opts) {\n          // default options\n          var ctx = {\n            seen: [],\n            stylize: stylizeNoColor };\n\n          // legacy...\n          if (arguments.length >= 3) ctx.depth = arguments[2];\n          if (arguments.length >= 4) ctx.colors = arguments[3];\n          if (isBoolean(opts)) {\n            // legacy...\n            ctx.showHidden = opts;\n          } else if (opts) {\n            // got an \"options\" object\n            exports._extend(ctx, opts);\n          }\n          // set default options\n          if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n          if (isUndefined(ctx.depth)) ctx.depth = 2;\n          if (isUndefined(ctx.colors)) ctx.colors = false;\n          if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n          if (ctx.colors) ctx.stylize = stylizeWithColor;\n          return formatValue(ctx, obj, ctx.depth);\n        }\n        exports.inspect = inspect;\n\n\n        // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n        inspect.colors = {\n          'bold': [1, 22],\n          'italic': [3, 23],\n          'underline': [4, 24],\n          'inverse': [7, 27],\n          'white': [37, 39],\n          'grey': [90, 39],\n          'black': [30, 39],\n          'blue': [34, 39],\n          'cyan': [36, 39],\n          'green': [32, 39],\n          'magenta': [35, 39],\n          'red': [31, 39],\n          'yellow': [33, 39] };\n\n\n        // Don't use 'blue' not visible on cmd.exe\n        inspect.styles = {\n          'special': 'cyan',\n          'number': 'yellow',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' };\n\n\n\n        function stylizeWithColor(str, styleType) {\n          var style = inspect.styles[styleType];\n\n          if (style) {\n            return \"\\x1B[\" + inspect.colors[style][0] + 'm' + str +\n            \"\\x1B[\" + inspect.colors[style][1] + 'm';\n          } else {\n            return str;\n          }\n        }\n\n\n        function stylizeNoColor(str, styleType) {\n          return str;\n        }\n\n\n        function arrayToHash(array) {\n          var hash = {};\n\n          array.forEach(function (val, idx) {\n            hash[val] = true;\n          });\n\n          return hash;\n        }\n\n\n        function formatValue(ctx, value, recurseTimes) {\n          // Provide a hook for user-specified inspect functions.\n          // Check that value is an object with an inspect function on it\n          if (ctx.customInspect &&\n          value &&\n          isFunction(value.inspect) &&\n          // Filter out the util module, it's inspect function is special\n          value.inspect !== exports.inspect &&\n          // Also filter out any prototype objects using the circular check.\n          !(value.constructor && value.constructor.prototype === value)) {\n            var ret = value.inspect(recurseTimes, ctx);\n            if (!isString(ret)) {\n              ret = formatValue(ctx, ret, recurseTimes);\n            }\n            return ret;\n          }\n\n          // Primitive types cannot have properties\n          var primitive = formatPrimitive(ctx, value);\n          if (primitive) {\n            return primitive;\n          }\n\n          // Look up the keys of the object.\n          var keys = Object.keys(value);\n          var visibleKeys = arrayToHash(keys);\n\n          if (ctx.showHidden) {\n            keys = Object.getOwnPropertyNames(value);\n          }\n\n          // IE doesn't make error fields non-enumerable\n          // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n          if (isError(value) && (\n          keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n            return formatError(value);\n          }\n\n          // Some type of object without properties can be shortcutted.\n          if (keys.length === 0) {\n            if (isFunction(value)) {\n              var name = value.name ? ': ' + value.name : '';\n              return ctx.stylize('[Function' + name + ']', 'special');\n            }\n            if (isRegExp(value)) {\n              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n            }\n            if (isDate(value)) {\n              return ctx.stylize(Date.prototype.toString.call(value), 'date');\n            }\n            if (isError(value)) {\n              return formatError(value);\n            }\n          }\n\n          var base = '',array = false,braces = ['{', '}'];\n\n          // Make Array say that they are Array\n          if (isArray(value)) {\n            array = true;\n            braces = ['[', ']'];\n          }\n\n          // Make functions say that they are functions\n          if (isFunction(value)) {\n            var n = value.name ? ': ' + value.name : '';\n            base = ' [Function' + n + ']';\n          }\n\n          // Make RegExps say that they are RegExps\n          if (isRegExp(value)) {\n            base = ' ' + RegExp.prototype.toString.call(value);\n          }\n\n          // Make dates with properties first say the date\n          if (isDate(value)) {\n            base = ' ' + Date.prototype.toUTCString.call(value);\n          }\n\n          // Make error with message first say the error\n          if (isError(value)) {\n            base = ' ' + formatError(value);\n          }\n\n          if (keys.length === 0 && (!array || value.length == 0)) {\n            return braces[0] + base + braces[1];\n          }\n\n          if (recurseTimes < 0) {\n            if (isRegExp(value)) {\n              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n            } else {\n              return ctx.stylize('[Object]', 'special');\n            }\n          }\n\n          ctx.seen.push(value);\n\n          var output;\n          if (array) {\n            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n          } else {\n            output = keys.map(function (key) {\n              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n            });\n          }\n\n          ctx.seen.pop();\n\n          return reduceToSingleString(output, base, braces);\n        }\n\n\n        function formatPrimitive(ctx, value) {\n          if (isUndefined(value))\n          return ctx.stylize('undefined', 'undefined');\n          if (isString(value)) {\n            var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '').\n            replace(/'/g, \"\\\\'\").\n            replace(/\\\\\"/g, '\"') + '\\'';\n            return ctx.stylize(simple, 'string');\n          }\n          if (isNumber(value))\n          return ctx.stylize('' + value, 'number');\n          if (isBoolean(value))\n          return ctx.stylize('' + value, 'boolean');\n          // For some reason typeof null is \"object\", so special case here.\n          if (isNull(value))\n          return ctx.stylize('null', 'null');\n        }\n\n\n        function formatError(value) {\n          return '[' + Error.prototype.toString.call(value) + ']';\n        }\n\n\n        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n          var output = [];\n          for (var i = 0, l = value.length; i < l; ++i) {\n            if (hasOwnProperty(value, String(i))) {\n              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n              String(i), true));\n            } else {\n              output.push('');\n            }\n          }\n          keys.forEach(function (key) {\n            if (!key.match(/^\\d+$/)) {\n              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n              key, true));\n            }\n          });\n          return output;\n        }\n\n\n        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n          var name, str, desc;\n          desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n          if (desc.get) {\n            if (desc.set) {\n              str = ctx.stylize('[Getter/Setter]', 'special');\n            } else {\n              str = ctx.stylize('[Getter]', 'special');\n            }\n          } else {\n            if (desc.set) {\n              str = ctx.stylize('[Setter]', 'special');\n            }\n          }\n          if (!hasOwnProperty(visibleKeys, key)) {\n            name = '[' + key + ']';\n          }\n          if (!str) {\n            if (ctx.seen.indexOf(desc.value) < 0) {\n              if (isNull(recurseTimes)) {\n                str = formatValue(ctx, desc.value, null);\n              } else {\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\n              }\n              if (str.indexOf('\\n') > -1) {\n                if (array) {\n                  str = str.split('\\n').map(function (line) {\n                    return '  ' + line;\n                  }).join('\\n').substr(2);\n                } else {\n                  str = '\\n' + str.split('\\n').map(function (line) {\n                    return '   ' + line;\n                  }).join('\\n');\n                }\n              }\n            } else {\n              str = ctx.stylize('[Circular]', 'special');\n            }\n          }\n          if (isUndefined(name)) {\n            if (array && key.match(/^\\d+$/)) {\n              return str;\n            }\n            name = JSON.stringify('' + key);\n            if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n              name = name.substr(1, name.length - 2);\n              name = ctx.stylize(name, 'name');\n            } else {\n              name = name.replace(/'/g, \"\\\\'\").\n              replace(/\\\\\"/g, '\"').\n              replace(/(^\"|\"$)/g, \"'\");\n              name = ctx.stylize(name, 'string');\n            }\n          }\n\n          return name + ': ' + str;\n        }\n\n\n        function reduceToSingleString(output, base, braces) {\n          var numLinesEst = 0;\n          var length = output.reduce(function (prev, cur) {\n            numLinesEst++;\n            if (cur.indexOf('\\n') >= 0) numLinesEst++;\n            return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n          }, 0);\n\n          if (length > 60) {\n            return braces[0] + (\n            base === '' ? '' : base + '\\n ') +\n            ' ' +\n            output.join(',\\n  ') +\n            ' ' +\n            braces[1];\n          }\n\n          return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n        }\n\n\n        // NOTE: These type checking functions intentionally don't use `instanceof`\n        // because it is fragile and can be easily faked with `Object.create()`.\n        function isArray(ar) {\n          return Array.isArray(ar);\n        }\n        exports.isArray = isArray;\n\n        function isBoolean(arg) {\n          return typeof arg === 'boolean';\n        }\n        exports.isBoolean = isBoolean;\n\n        function isNull(arg) {\n          return arg === null;\n        }\n        exports.isNull = isNull;\n\n        function isNullOrUndefined(arg) {\n          return arg == null;\n        }\n        exports.isNullOrUndefined = isNullOrUndefined;\n\n        function isNumber(arg) {\n          return typeof arg === 'number';\n        }\n        exports.isNumber = isNumber;\n\n        function isString(arg) {\n          return typeof arg === 'string';\n        }\n        exports.isString = isString;\n\n        function isSymbol(arg) {\n          return typeof arg === 'symbol';\n        }\n        exports.isSymbol = isSymbol;\n\n        function isUndefined(arg) {\n          return arg === void 0;\n        }\n        exports.isUndefined = isUndefined;\n\n        function isRegExp(re) {\n          return isObject(re) && objectToString(re) === '[object RegExp]';\n        }\n        exports.isRegExp = isRegExp;\n\n        function isObject(arg) {\n          return typeof arg === 'object' && arg !== null;\n        }\n        exports.isObject = isObject;\n\n        function isDate(d) {\n          return isObject(d) && objectToString(d) === '[object Date]';\n        }\n        exports.isDate = isDate;\n\n        function isError(e) {\n          return isObject(e) && (\n          objectToString(e) === '[object Error]' || e instanceof Error);\n        }\n        exports.isError = isError;\n\n        function isFunction(arg) {\n          return typeof arg === 'function';\n        }\n        exports.isFunction = isFunction;\n\n        function isPrimitive(arg) {\n          return arg === null ||\n          typeof arg === 'boolean' ||\n          typeof arg === 'number' ||\n          typeof arg === 'string' ||\n          typeof arg === 'symbol' || // ES6 symbol\n          typeof arg === 'undefined';\n        }\n        exports.isPrimitive = isPrimitive;\n\n        exports.isBuffer = require('./support/isBuffer');\n\n        function objectToString(o) {\n          return Object.prototype.toString.call(o);\n        }\n\n\n        function pad(n) {\n          return n < 10 ? '0' + n.toString(10) : n.toString(10);\n        }\n\n\n        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n        'Oct', 'Nov', 'Dec'];\n\n        // 26 Feb 16:19:34\n        function timestamp() {\n          var d = new Date();\n          var time = [pad(d.getHours()),\n          pad(d.getMinutes()),\n          pad(d.getSeconds())].join(':');\n          return [d.getDate(), months[d.getMonth()], time].join(' ');\n        }\n\n\n        // log is just a thin wrapper to console.log that prepends a timestamp\n        exports.log = function () {\n          __f__(\"log\", '%s - %s', timestamp(), exports.format.apply(exports, arguments), \" at utils/mqtt.js:14353\");\n        };\n\n\n        /**\n            * Inherit the prototype methods from one constructor into another.\n            *\n            * The Function.prototype.inherits from lang.js rewritten as a standalone\n            * function (not on Function.prototype). NOTE: If this file is to be loaded\n            * during bootstrapping this function needs to be rewritten using some native\n            * functions as prototype setup using normal JavaScript does not work as\n            * expected during bootstrapping (see mirror.js in r114903).\n            *\n            * @param {function} ctor Constructor function which needs to inherit the\n            *     prototype.\n            * @param {function} superCtor Constructor function to inherit prototype from.\n            */\n        exports.inherits = require('inherits');\n\n        exports._extend = function (origin, add) {\n          // Don't do anything if add isn't an object\n          if (!add || !isObject(add)) return origin;\n\n          var keys = Object.keys(add);\n          var i = keys.length;\n          while (i--) {\n            origin[keys[i]] = add[keys[i]];\n          }\n          return origin;\n        };\n\n        function hasOwnProperty(obj, prop) {\n          return Object.prototype.hasOwnProperty.call(obj, prop);\n        }\n\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, { \"./support/isBuffer\": 116, \"_process\": 92, \"inherits\": 80 }], 118: [function (require, module, exports) {\n      (function (process, global) {\n        'use strict';\n\n        var Transform = require('readable-stream').Transform;\n        var duplexify = require('duplexify');\n        var WS = require('ws');\n        var Buffer = require('safe-buffer').Buffer;\n\n        module.exports = WebSocketStream;\n\n        function buildProxy(options, socketWrite, socketEnd) {\n          var proxy = new Transform({\n            objectMode: options.objectMode });\n\n\n          proxy._write = socketWrite;\n          proxy._flush = socketEnd;\n\n          return proxy;\n        }\n\n        function WebSocketStream(target, protocols, options) {\n          var stream, socket;\n\n          var isBrowser = process.title === 'browser';\n          var isNative = !!global.WebSocket;\n          var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode;\n\n          if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n            // accept the \"options\" Object as the 2nd argument\n            options = protocols;\n            protocols = null;\n\n            if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {\n              protocols = options.protocol;\n            }\n          }\n\n          if (!options) options = {};\n\n          if (options.objectMode === undefined) {\n            options.objectMode = !(options.binary === true || options.binary === undefined);\n          }\n\n          var proxy = buildProxy(options, socketWrite, socketEnd);\n\n          if (!options.objectMode) {\n            proxy._writev = writev;\n          }\n\n          // browser only: sets the maximum socket buffer size before throttling\n          var bufferSize = options.browserBufferSize || 1024 * 512;\n\n          // browser only: how long to wait when throttling\n          var bufferTimeout = options.browserBufferTimeout || 1000;\n\n          // use existing WebSocket object that was passed in\n          if (typeof target === 'object') {\n            socket = target;\n            // otherwise make a new one\n          } else {\n            // special constructor treatment for native websockets in browsers, see\n            // https://github.com/maxogden/websocket-stream/issues/82\n            if (isNative && isBrowser) {\n              socket = new WS(target, protocols);\n            } else {\n              socket = new WS(target, protocols, options);\n            }\n\n            socket.binaryType = 'arraybuffer';\n          }\n\n          // was already open when passed in\n          if (socket.readyState === socket.OPEN) {\n            stream = proxy;\n          } else {\n            stream = duplexify.obj();\n            socket.onopen = onopen;\n          }\n\n          stream.socket = socket;\n\n          socket.onclose = onclose;\n          socket.onerror = onerror;\n          socket.onmessage = onmessage;\n\n          proxy.on('close', destroy);\n\n          var coerceToBuffer = !options.objectMode;\n\n          function socketWriteNode(chunk, enc, next) {\n            // avoid errors, this never happens unless\n            // destroy() is called\n            if (socket.readyState !== socket.OPEN) {\n              next();\n              return;\n            }\n\n            if (coerceToBuffer && typeof chunk === 'string') {\n              chunk = Buffer.from(chunk, 'utf8');\n            }\n            socket.send(chunk, next);\n          }\n\n          function socketWriteBrowser(chunk, enc, next) {\n            if (socket.bufferedAmount > bufferSize) {\n              setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);\n              return;\n            }\n\n            if (coerceToBuffer && typeof chunk === 'string') {\n              chunk = Buffer.from(chunk, 'utf8');\n            }\n\n            try {\n              socket.send(chunk);\n            } catch (err) {\n              return next(err);\n            }\n\n            next();\n          }\n\n          function socketEnd(done) {\n            socket.close();\n            done();\n          }\n\n          function onopen() {\n            stream.setReadable(proxy);\n            stream.setWritable(proxy);\n            stream.emit('connect');\n          }\n\n          function onclose() {\n            stream.end();\n            stream.destroy();\n          }\n\n          function onerror(err) {\n            stream.destroy(err);\n          }\n\n          function onmessage(event) {\n            var data = event.data;\n            if (data instanceof ArrayBuffer) data = Buffer.from(data);else\n            data = Buffer.from(data, 'utf8');\n            proxy.push(data);\n          }\n\n          function destroy() {\n            socket.close();\n          }\n\n          // this is to be enabled only if objectMode is false\n          function writev(chunks, cb) {\n            var buffers = new Array(chunks.length);\n            for (var i = 0; i < chunks.length; i++) {\n              if (typeof chunks[i].chunk === 'string') {\n                buffers[i] = Buffer.from(chunks[i], 'utf8');\n              } else {\n                buffers[i] = chunks[i].chunk;\n              }\n            }\n\n            this._write(Buffer.concat(buffers), 'binary', cb);\n          }\n\n          return stream;\n        }\n\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, { \"_process\": 92, \"duplexify\": 17, \"readable-stream\": 108, \"safe-buffer\": 110, \"ws\": 119 }], 119: [function (require, module, exports) {\n\n      var ws = null;\n\n      if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n      } else if (typeof MozWebSocket !== 'undefined') {\n        ws = MozWebSocket;\n      } else if (typeof window !== 'undefined') {\n        ws = window.WebSocket || window.MozWebSocket;\n      }\n\n      module.exports = ws;\n\n    }, {}], 120: [function (require, module, exports) {\n      // Returns a wrapper function that returns a wrapped callback\n      // The wrapper function should do some stuff, and return a\n      // presumably different callback function.\n      // This makes sure that own properties are retained, so that\n      // decorations and such are not lost along the way.\n      module.exports = wrappy;\n      function wrappy(fn, cb) {\n        if (fn && cb) return wrappy(fn)(cb);\n\n        if (typeof fn !== 'function')\n        throw new TypeError('need wrapper function');\n\n        Object.keys(fn).forEach(function (k) {\n          wrapper[k] = fn[k];\n        });\n\n        return wrapper;\n\n        function wrapper() {\n          var args = new Array(arguments.length);\n          for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i];\n          }\n          var ret = fn.apply(this, args);\n          var cb = args[args.length - 1];\n          if (typeof ret === 'function' && ret !== cb) {\n            Object.keys(cb).forEach(function (k) {\n              ret[k] = cb[k];\n            });\n          }\n          return ret;\n        }\n      }\n\n    }, {}], 121: [function (require, module, exports) {\n      module.exports = extend;\n\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n      function extend() {\n        var target = {};\n\n        for (var i = 0; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      }\n\n    }, {}] }, {}, [9])(9);\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../迅雷下载/HBuilderX.2.6.11.20200409.full/HBuilderX/plugins/uniapp-cli/node_modules/webpack/buildin/global.js */ 19), __webpack_require__(/*! @dcloudio/uni-mp-weixin/dist/mp.js */ 20)[\"default\"], __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/format-log.js */ 12)[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vdXRpbHMvbXF0dC5qcyJdLCJuYW1lcyI6WyJmIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmluZSIsInIiLCJlIiwibiIsInQiLCJvIiwiaSIsImMiLCJyZXF1aXJlIiwidSIsImEiLCJFcnJvciIsImNvZGUiLCJwIiwiY2FsbCIsImxlbmd0aCIsInByb2Nlc3MiLCJnbG9iYWwiLCJldmVudHMiLCJTdG9yZSIsIm1xdHRQYWNrZXQiLCJXcml0YWJsZSIsImluaGVyaXRzIiwicmVJbnRlcnZhbCIsInZhbGlkYXRpb25zIiwieHRlbmQiLCJzZXRJbW1lZGlhdGUiLCJjYWxsYmFjayIsIm5leHRUaWNrIiwiZGVmYXVsdENvbm5lY3RPcHRpb25zIiwia2VlcGFsaXZlIiwicmVzY2hlZHVsZVBpbmdzIiwicHJvdG9jb2xJZCIsInByb3RvY29sVmVyc2lvbiIsInJlY29ubmVjdFBlcmlvZCIsImNvbm5lY3RUaW1lb3V0IiwiY2xlYW4iLCJyZXN1YnNjcmliZSIsImVycm9ycyIsImRlZmF1bHRJZCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsInNlbmRQYWNrZXQiLCJjbGllbnQiLCJwYWNrZXQiLCJjYiIsImVtaXQiLCJyZXN1bHQiLCJ3cml0ZVRvU3RyZWFtIiwic3RyZWFtIiwib3B0aW9ucyIsIm9uY2UiLCJmbHVzaCIsInF1ZXVlIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJtZXNzYWdlSWQiLCJmbHVzaFZvbGF0aWxlIiwidm9sYXRpbGUiLCJzdG9yZUFuZFNlbmQiLCJjYlN0b3JlUHV0Iiwib3V0Z29pbmdTdG9yZSIsInB1dCIsInN0b3JlZFBhY2tldCIsImVyciIsIm5vcCIsIk1xdHRDbGllbnQiLCJzdHJlYW1CdWlsZGVyIiwiayIsInRoYXQiLCJjbGllbnRJZCIsImN1c3RvbUhhbmRsZUFja3MiLCJhcmd1bWVudHMiLCJpbmNvbWluZ1N0b3JlIiwicXVldWVRb1NaZXJvIiwidW5kZWZpbmVkIiwiX3Jlc3Vic2NyaWJlVG9waWNzIiwibWVzc2FnZUlkVG9Ub3BpYyIsInBpbmdUaW1lciIsImNvbm5lY3RlZCIsImRpc2Nvbm5lY3RpbmciLCJjb25uYWNrVGltZXIiLCJyZWNvbm5lY3RUaW1lciIsIl9zdG9yZVByb2Nlc3NpbmciLCJfcGFja2V0SWRzRHVyaW5nU3RvcmVQcm9jZXNzaW5nIiwibmV4dElkIiwibWF4IiwiZmxvb3IiLCJvdXRnb2luZyIsIl9maXJzdENvbm5lY3Rpb24iLCJvbiIsImNsZWFyVGltZW91dCIsImRlbGl2ZXIiLCJlbnRyeSIsInNoaWZ0IiwiX3NlbmRQYWNrZXQiLCJjbGVhciIsIl9zZXR1cFJlY29ubmVjdCIsIkV2ZW50RW1pdHRlciIsIl9zZXR1cFN0cmVhbSIsInByb3RvdHlwZSIsImNvbm5lY3RQYWNrZXQiLCJ3cml0YWJsZSIsInBhcnNlciIsImNvbXBsZXRlUGFyc2UiLCJwYWNrZXRzIiwiX2NsZWFyUmVjb25uZWN0IiwicHVzaCIsIm5leHRUaWNrV29yayIsIndvcmsiLCJkb25lIiwiX2hhbmRsZVBhY2tldCIsIl93cml0ZSIsImJ1ZiIsImVuYyIsInBhcnNlIiwicGlwZSIsImNyZWF0ZSIsImNtZCIsImJpbmQiLCJwcm9wZXJ0aWVzIiwiYXV0aGVudGljYXRpb25NZXRob2QiLCJhdXRoZW50aWNhdGlvbkRhdGEiLCJhdXRoUGFja2V0IiwicmVhc29uQ29kZSIsInNldE1heExpc3RlbmVycyIsInNldFRpbWVvdXQiLCJfY2xlYW5VcCIsIm1heGltdW1QYWNrZXRTaXplIiwiZW5kIiwicmVhc29uU3RyaW5nIiwiX2hhbmRsZVB1Ymxpc2giLCJfaGFuZGxlQWNrIiwiX2hhbmRsZVB1YnJlbCIsIl9oYW5kbGVDb25uYWNrIiwiX2hhbmRsZVBpbmdyZXNwIiwiX2hhbmRsZURpc2Nvbm5lY3QiLCJfY2hlY2tEaXNjb25uZWN0aW5nIiwicHVibGlzaCIsInRvcGljIiwibWVzc2FnZSIsIm9wdHMiLCJkZWZhdWx0T3B0cyIsInFvcyIsInJldGFpbiIsImR1cCIsInBheWxvYWQiLCJfbmV4dElkIiwidG9waWNBbGlhcyIsInRvcGljQWxpYXNNYXhpbXVtIiwiX3N0b3JlUGFja2V0Iiwic3Vic2NyaWJlIiwiYXJncyIsIkFycmF5Iiwic3VicyIsIm9iaiIsInBvcCIsImludmFsaWRUb3BpYyIsInZlcnNpb24iLCJ2YWxpZGF0ZVRvcGljcyIsIm5sIiwicmFwIiwicmgiLCJpc0FycmF5IiwiaGFzT3duUHJvcGVydHkiLCJjdXJyZW50T3B0cyIsInN1YnNjcmlwdGlvbnMiLCJ0b3BpY3MiLCJzdWIiLCJncmFudGVkIiwidW5zdWJzY3JpYmUiLCJ1bnN1YnNjcmlwdGlvbnMiLCJmb3JjZSIsImNsb3NlU3RvcmVzIiwiZGlzY29ubmVjdGVkIiwiY2xvc2UiLCJhcHBseSIsIl9kZWZlcnJlZFJlY29ubmVjdCIsImZpbmlzaCIsInJlbW92ZU91dGdvaW5nTWVzc2FnZSIsIm1pZCIsImRlbCIsInJlY29ubmVjdCIsIl9yZWNvbm5lY3QiLCJyZWNvbm5lY3RpbmciLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJmb3JjZWQiLCJkZXN0cm95IiwicmVtb3ZlTGlzdGVuZXIiLCJfc2hpZnRQaW5nSW50ZXJ2YWwiLCJfc2V0dXBQaW5nVGltZXIiLCJwaW5nUmVzcCIsIl9jaGVja1BpbmciLCJyZXNjaGVkdWxlIiwicmMiLCJyZXR1cm5Db2RlIiwic2VydmVyS2VlcEFsaXZlIiwiX29uQ29ubmVjdCIsInZhbGlkUmVhc29uQ29kZXMiLCJlcnJvciIsImluZGV4T2YiLCJoYW5kbGVNZXNzYWdlIiwidHlwZSIsInJlc3BvbnNlIiwicHViYWNrUkMiLCJwdWJyZWNSQyIsImdyYW50ZWRJIiwiY29tcCIsImdldCIsInB1YiIsImlkIiwiZ2V0TGFzdE1lc3NhZ2VJZCIsIl9yZXN1YnNjcmliZSIsImNvbm5hY2siLCJfcmVzdWJzY3JpYmVUb3BpY3NLZXlzIiwic2Vzc2lvblByZXNlbnQiLCJ0b3BpY0kiLCJyZXN1YnNjcmliZVRvcGljIiwic3RhcnRTdHJlYW1Qcm9jZXNzIiwib3V0U3RvcmUiLCJjcmVhdGVTdHJlYW0iLCJjbGVhclN0b3JlUHJvY2Vzc2luZyIsInJlbW92ZSIsInN0b3JlRGVsaXZlciIsInJlYWQiLCJzdGF0dXMiLCJhbGxQcm9jZXNzZWQiLCJzZWxmIiwid2luZG93IiwiQnVmZmVyIiwiVHJhbnNmb3JtIiwiZHVwbGV4aWZ5IiwiYmFzZTY0IiwibXkiLCJwcm94eSIsImlzSW5pdGlhbGl6ZWQiLCJidWlsZFByb3h5IiwiY2h1bmsiLCJlbmNvZGluZyIsIm5leHQiLCJzZW5kU29ja2V0TWVzc2FnZSIsImRhdGEiLCJidWZmZXIiLCJzdWNjZXNzIiwiZmFpbCIsIl9mbHVzaCIsInNvY2tldEVuZCIsImNsb3NlU29ja2V0Iiwic2V0RGVmYXVsdE9wdHMiLCJob3N0bmFtZSIsInBhdGgiLCJ3c09wdGlvbnMiLCJidWlsZFVybCIsInByb3RvY29sIiwidXJsIiwicG9ydCIsInRyYW5zZm9ybVdzVXJsIiwiYmluZEV2ZW50SGFuZGxlciIsIm9uU29ja2V0T3BlbiIsInNldFJlYWRhYmxlIiwic2V0V3JpdGFibGUiLCJvblNvY2tldE1lc3NhZ2UiLCJyZXMiLCJhcnJheSIsInRvQnl0ZUFycmF5IiwiZnJvbSIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiQXJyYXlCdWZmZXIiLCJyZWFkQXNBcnJheUJ1ZmZlciIsIm9uU29ja2V0Q2xvc2UiLCJvblNvY2tldEVycm9yIiwiYnVpbGRTdHJlYW0iLCJob3N0Iiwid2Vic29ja2V0U3ViUHJvdG9jb2wiLCJjb25uZWN0U29ja2V0IiwicHJvdG9jb2xzIiwibmV0IiwiYnVpbGRCdWlsZGVyIiwiY3JlYXRlQ29ubmVjdGlvbiIsInRscyIsIm1xdHRDbGllbnQiLCJjb25uZWN0aW9uIiwicmVqZWN0VW5hdXRob3JpemVkIiwiY29ubmVjdCIsImF1dGhvcml6ZWQiLCJoYW5kbGVUTFNlcnJvcnMiLCJ3ZWJzb2NrZXQiLCJ1cmxNb2R1bGUiLCJXU1NfT1BUSU9OUyIsIklTX0JST1dTRVIiLCJ0aXRsZSIsInByb3AiLCJjcmVhdGVXZWJTb2NrZXQiLCJidWlsZEJ1aWxkZXJCcm93c2VyIiwiZG9jdW1lbnQiLCJwYXJzZWQiLCJVUkwiLCJzb2NrZXRUYXNrIiwic2VuZCIsImVyck1zZyIsIm9uT3BlbiIsIm9uTWVzc2FnZSIsIm9uQ2xvc2UiLCJvbkVycm9yIiwid3giLCJfZGVzdHJveSIsImRlc3Ryb3lSZWYiLCJSZWFkYWJsZSIsInN0cmVhbXNPcHRzIiwib2JqZWN0TW9kZSIsImRlZmF1bHRTdG9yZU9wdGlvbnMiLCJNYXAiLCJfaW5mbGlnaHRzIiwic2V0IiwiZGVzdHJveWVkIiwidmFsdWVzIiwidmFsdWUiLCJrZXkiLCJfcmVhZCIsImRlbGV0ZSIsInZhbGlkYXRlVG9waWMiLCJwYXJ0cyIsInNwbGl0IiwibXF0dCIsInRjcCIsInNzbCIsIm1xdHRzIiwid3hzIiwiYWxpIiwiYWxpcyIsIndzIiwid3NzIiwicGFyc2VBdXRoT3B0aW9ucyIsIm1hdGNoZXMiLCJhdXRoIiwibWF0Y2giLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiYnJva2VyVXJsIiwiTnVtYmVyIiwicmVwbGFjZSIsInF1ZXJ5IiwiY2VydCIsImlzU2VjdXJlIiwiZmlsdGVyIiwiaW5kZXgiLCJkZWZhdWx0UHJvdG9jb2wiLCJ3cmFwcGVyIiwic2VydmVycyIsIl9yZWNvbm5lY3RDb3VudCIsImJ5dGVMZW5ndGgiLCJmcm9tQnl0ZUFycmF5IiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiVWludDhBcnJheSIsImxlbiIsImNoYXJDb2RlQXQiLCJnZXRMZW5zIiwiYjY0IiwidmFsaWRMZW4iLCJwbGFjZUhvbGRlcnNMZW4iLCJsZW5zIiwiX2J5dGVMZW5ndGgiLCJ0bXAiLCJhcnIiLCJjdXJCeXRlIiwidHJpcGxldFRvQmFzZTY0IiwibnVtIiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsInN0YXJ0Iiwib3V0cHV0Iiwiam9pbiIsImV4dHJhQnl0ZXMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiLCJpZWVlNzU0IiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiS19NQVhfTEVOR1RIIiwia01heExlbmd0aCIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJ0eXBlZEFycmF5U3VwcG9ydCIsImNvbnNvbGUiLCJfX3Byb3RvX18iLCJmb28iLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJpc0J1ZmZlciIsImJ5dGVPZmZzZXQiLCJjcmVhdGVCdWZmZXIiLCJSYW5nZUVycm9yIiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsIlR5cGVFcnJvciIsImFsbG9jVW5zYWZlIiwiU3ltYm9sIiwic3BlY2llcyIsImNvbmZpZ3VyYWJsZSIsInBvb2xTaXplIiwiZnJvbVN0cmluZyIsImlzVmlldyIsImZyb21BcnJheUxpa2UiLCJpc0luc3RhbmNlIiwiZnJvbUFycmF5QnVmZmVyIiwidmFsdWVPZiIsImIiLCJmcm9tT2JqZWN0IiwidG9QcmltaXRpdmUiLCJhc3NlcnRTaXplIiwic2l6ZSIsImFsbG9jIiwiZmlsbCIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJzdHJpbmciLCJpc0VuY29kaW5nIiwiYWN0dWFsIiwid3JpdGUiLCJzbGljZSIsImNvcHkiLCJudW1iZXJJc05hTiIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJvZmZzZXQiLCJ4IiwieSIsIm1pbiIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwiY29uY2F0IiwibGlzdCIsInBvcyIsIm11c3RNYXRjaCIsImxvd2VyZWRDYXNlIiwidXRmOFRvQnl0ZXMiLCJiYXNlNjRUb0J5dGVzIiwic2xvd1RvU3RyaW5nIiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJtIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwidG9Mb2NhbGVTdHJpbmciLCJlcXVhbHMiLCJpbnNwZWN0Iiwic3RyIiwidHJpbSIsInRhcmdldCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsInZhbCIsImRpciIsImFycmF5SW5kZXhPZiIsImxhc3RJbmRleE9mIiwiaW5kZXhTaXplIiwiYXJyTGVuZ3RoIiwidmFsTGVuZ3RoIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImZvdW5kIiwiaiIsImluY2x1ZGVzIiwiaGV4V3JpdGUiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZUludCIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJfYXJyIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsInJldCIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzdWJhcnJheSIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4Iiwid3JpdGVVSW50MTZMRSIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0IiwibGl0dGxlRW5kaWFuIiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiY29weVdpdGhpbiIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJ1bml0cyIsIkluZmluaXR5IiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJzcmMiLCJkc3QiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJvYmplY3RDcmVhdGUiLCJvYmplY3RDcmVhdGVQb2x5ZmlsbCIsIm9iamVjdEtleXMiLCJvYmplY3RLZXlzUG9seWZpbGwiLCJGdW5jdGlvbiIsImZ1bmN0aW9uQmluZFBvbHlmaWxsIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiaGFzRGVmaW5lUHJvcGVydHkiLCJpc05hTiIsIiRnZXRNYXhMaXN0ZW5lcnMiLCJnZXRNYXhMaXN0ZW5lcnMiLCJlbWl0Tm9uZSIsImhhbmRsZXIiLCJpc0ZuIiwibGlzdGVuZXJzIiwiYXJyYXlDbG9uZSIsImVtaXRPbmUiLCJhcmcxIiwiZW1pdFR3byIsImFyZzIiLCJlbWl0VGhyZWUiLCJhcmczIiwiZW1pdE1hbnkiLCJlciIsImRvRXJyb3IiLCJjb250ZXh0IiwiX2FkZExpc3RlbmVyIiwibGlzdGVuZXIiLCJwcmVwZW5kIiwiZXhpc3RpbmciLCJuZXdMaXN0ZW5lciIsInVuc2hpZnQiLCJ3YXJuZWQiLCJ3IiwiZW1pdHRlciIsImNvdW50Iiwid2FybiIsImFkZExpc3RlbmVyIiwicHJlcGVuZExpc3RlbmVyIiwib25jZVdyYXBwZXIiLCJmaXJlZCIsIndyYXBGbiIsIl9vbmNlV3JhcCIsInN0YXRlIiwid3JhcHBlZCIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJwb3NpdGlvbiIsIm9yaWdpbmFsTGlzdGVuZXIiLCJzcGxpY2VPbmUiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwidW53cmFwIiwiZXZsaXN0ZW5lciIsInVud3JhcExpc3RlbmVycyIsInJhd0xpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJldmVudE5hbWVzIiwiUmVmbGVjdCIsIm93bktleXMiLCJwcm90byIsIkYiLCJmbiIsIm9iamVjdFRvU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNOdWxsIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc051bWJlciIsImlzU3RyaW5nIiwiaXNTeW1ib2wiLCJpc1VuZGVmaW5lZCIsImlzUmVnRXhwIiwicmUiLCJpc09iamVjdCIsImlzRGF0ZSIsImQiLCJpc0Vycm9yIiwiaXNGdW5jdGlvbiIsImlzUHJpbWl0aXZlIiwibm9ybWFsaXplT3B0aW9ucyIsImVuc3VyZUNhbGxhYmxlIiwibWFwIiwiY2FsbGFibGUiLCJ2YWxpZFZhbHVlIiwiZGVzYyIsImRncyIsIm92ZXJ3cml0ZURlZmluaXRpb24iLCJyZXNvbHZlQ29udGV4dCIsInByb3BzIiwiYXNzaWduIiwibm9ybWFsaXplT3B0cyIsImlzQ2FsbGFibGUiLCJjb250YWlucyIsImRzY3IiLCJncyIsImVvcyIsIlNJR05BTF9GTFVTSCIsIm9udW5jb3JrIiwiX2NvcmtlZCIsImF1dG9EZXN0cm95IiwiX2F1dG9EZXN0cm95IiwiZGVzdHJveWVyIiwiX2VuZGVkIiwiX3dyaXRhYmxlU3RhdGUiLCJmaW5pc2hlZCIsInRvU3RyZWFtczIiLCJycyIsImhpZ2hXYXRlck1hcmsiLCJ3cmFwIiwiRHVwbGV4aWZ5IiwicmVhZGFibGUiLCJEdXBsZXgiLCJfd3JpdGFibGUiLCJfcmVhZGFibGUiLCJfcmVhZGFibGUyIiwiX2ZvcndhcmREZXN0cm95IiwiX2ZvcndhcmRFbmQiLCJfb25kcmFpbiIsIl9kcmFpbmVkIiwiX2ZvcndhcmRpbmciLCJfdW53cml0ZSIsIl91bnJlYWQiLCJjb3JrIiwidW5jb3JrIiwidW5lbmQiLCJvbmRyYWluIiwicmVzdW1lIiwib25yZWFkYWJsZSIsIl9mb3J3YXJkIiwib25lbmQiLCJfcmVhZGFibGVTdGF0ZSIsIl9maW5pc2giLCJwcmVmaW5pc2hlZCIsImVuZGluZyIsIm5vb3AiLCJpc1JlcXVlc3QiLCJzZXRIZWFkZXIiLCJhYm9ydCIsImlzQ2hpbGRQcm9jZXNzIiwic3RkaW8iLCJvbmxlZ2FjeWZpbmlzaCIsIm9uZmluaXNoIiwib25leGl0IiwiZXhpdENvZGUiLCJvbmVycm9yIiwib25jbG9zZSIsImVuZGVkIiwib25yZXF1ZXN0IiwicmVxIiwidG9Qb3NJbnQiLCJvYmpIYXNPd25Qcm9wZXJ0eSIsImFicyIsInNlYXJjaEVsZW1lbnQiLCJmcm9tSW5kZXgiLCJCb29sZWFuIiwiaXRlcmF0b3JTeW1ib2wiLCJpdGVyYXRvciIsImlzQXJndW1lbnRzIiwiaXNWYWx1ZSIsImFycmF5TGlrZSIsIm1hcEZuIiwidGhpc0FyZyIsIkNvbnRleHQiLCJnZXRJdGVyYXRvciIsIm9ialRvU3RyaW5nIiwic2lnbiIsIk5hTiIsInRvSW50ZWdlciIsIm9ialByb3BlcnR5SXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJtZXRob2QiLCJkZWZWYWwiLCJjb21wYXJlRm4iLCJzb3J0IiwiYmFyIiwidHJ6eSIsImRlc3QiLCJhRnJvbSIsInByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eU5hbWUiLCJlbnN1cmUiLCJzaGltIiwibnVsbE9iamVjdCIsInBvbHlQcm9wcyIsImxldmVsIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImRlZmluZVByb3BlcnRpZXMiLCJmdW5jdGlvbiIsIm9iamVjdCIsIl91bmRlZmluZWQiLCJ0YXJnZXRPYmoiLCJvcHRzMSIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJwbGFpbk9iamVjdCIsImN1c3RvbUNyZWF0ZSIsIm9iaklzUHJvdG90eXBlT2YiLCJpc1Byb3RvdHlwZU9mIiwibnVsbERlc2MiLCJ2YWxpZGF0ZSIsImlzTnVsbEJhc2UiLCJudWxsUG9seWZpbGwiLCJ0bXBPYmoxIiwidG1wT2JqMiIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlnbm9yZSIsInNlYXJjaFN0cmluZyIsIkl0ZXJhdG9yIiwiQXJyYXlJdGVyYXRvciIsImtpbmQiLCJfcmVzb2x2ZSIsIl9fa2luZF9fIiwiX19saXN0X18iLCJ0b1N0cmluZ1RhZyIsInNvbWUiLCJpdGVyYWJsZSIsIm1vZGUiLCJkb0JyZWFrIiwiYnJva2VuIiwiY2hhciIsIlN0cmluZ0l0ZXJhdG9yIiwiYXV0b0JpbmQiLCJfX2NvbnRleHRfXyIsIl9fbmV4dEluZGV4X18iLCJfb25BZGQiLCJfb25EZWxldGUiLCJfb25DbGVhciIsIl9uZXh0IiwiX19yZWRvX18iLCJfdW5CaW5kIiwiX2NyZWF0ZVJlc3VsdCIsIm9mZiIsInJlZG8iLCJzcGxpY2UiLCJfX2xlbmd0aF9fIiwiaXNJdGVyYWJsZSIsImVudHJpZXMiLCJoYXMiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsImtpbmRzIiwidW5CaW5kIiwiTWFwSXRlcmF0b3IiLCJfX21hcEtleXNEYXRhX18iLCJfX3ZhbHVlc19fIiwiX19tYXBWYWx1ZXNEYXRhX18iLCJlSW5kZXhPZiIsImVlIiwiZm9yT2YiLCJpc05hdGl2ZSIsIk1hcFBvbHkiLCJ2YWxpZFR5cGVzIiwic3ltYm9sIiwidmFsaWRhdGVTeW1ib2wiLCJvYmpQcm90b3R5cGUiLCJOYXRpdmVTeW1ib2wiLCJTeW1ib2xQb2x5ZmlsbCIsIkhpZGRlblN5bWJvbCIsImdsb2JhbFN5bWJvbHMiLCJpc05hdGl2ZVNhZmUiLCJnZW5lcmF0ZU5hbWUiLCJjcmVhdGVkIiwicG9zdGZpeCIsImllMTFCdWdXb3JrYXJvdW5kIiwiZGVzY3JpcHRpb24iLCJfX2Rlc2NyaXB0aW9uX18iLCJfX25hbWVfXyIsImZvciIsImtleUZvciIsInMiLCJoYXNJbnN0YW5jZSIsImlzQ29uY2F0U3ByZWFkYWJsZSIsInNlYXJjaCIsInVuc2NvcGFibGVzIiwiZGVzY3JpcHRvciIsIm1ldGhvZHMiLCJkZXNjcmlwdG9ycyIsImJhc2UiLCJfX2VlX18iLCJfX2VlT25jZUxpc3RlbmVyX18iLCJjYW5kaWRhdGUiLCJsIiwiaXNMRSIsIm1MZW4iLCJuQnl0ZXMiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwibkJpdHMiLCJydCIsImxvZyIsIkxOMiIsImN0b3IiLCJzdXBlckN0b3IiLCJzdXBlcl8iLCJUZW1wQ3RvciIsImlzU2xvd0J1ZmZlciIsInR5cGVzIiwiY29kZXMiLCJ2IiwiQ01EX1NISUZUIiwiQ01EX01BU0siLCJEVVBfTUFTSyIsIlFPU19NQVNLIiwiUU9TX1NISUZUIiwiUkVUQUlOX01BU0siLCJMRU5HVEhfTUFTSyIsIkxFTkdUSF9GSU5fTUFTSyIsIlNFU1NJT05QUkVTRU5UX01BU0siLCJTRVNTSU9OUFJFU0VOVF9IRUFERVIiLCJDT05OQUNLX0hFQURFUiIsIlVTRVJOQU1FX01BU0siLCJQQVNTV09SRF9NQVNLIiwiV0lMTF9SRVRBSU5fTUFTSyIsIldJTExfUU9TX01BU0siLCJXSUxMX1FPU19TSElGVCIsIldJTExfRkxBR19NQVNLIiwiQ0xFQU5fU0VTU0lPTl9NQVNLIiwiQ09OTkVDVF9IRUFERVIiLCJzZXNzaW9uRXhwaXJ5SW50ZXJ2YWwiLCJ3aWxsRGVsYXlJbnRlcnZhbCIsInJlY2VpdmVNYXhpbXVtIiwicmVxdWVzdFJlc3BvbnNlSW5mb3JtYXRpb24iLCJyZXF1ZXN0UHJvYmxlbUluZm9ybWF0aW9uIiwidXNlclByb3BlcnRpZXMiLCJwYXlsb2FkRm9ybWF0SW5kaWNhdG9yIiwibWVzc2FnZUV4cGlyeUludGVydmFsIiwiY29udGVudFR5cGUiLCJyZXNwb25zZVRvcGljIiwiY29ycmVsYXRpb25EYXRhIiwibWF4aW11bVFvUyIsInJldGFpbkF2YWlsYWJsZSIsImFzc2lnbmVkQ2xpZW50SWRlbnRpZmllciIsIndpbGRjYXJkU3Vic2NyaXB0aW9uQXZhaWxhYmxlIiwic3Vic2NyaXB0aW9uSWRlbnRpZmllcnNBdmFpbGFibGUiLCJzaGFyZWRTdWJzY3JpcHRpb25BdmFpbGFibGUiLCJyZXNwb25zZUluZm9ybWF0aW9uIiwic2VydmVyUmVmZXJlbmNlIiwic3Vic2NyaXB0aW9uSWRlbnRpZmllciIsInByb3BlcnRpZXNDb2RlcyIsInByb3BlcnRpZXNUeXBlcyIsImdlbkhlYWRlciIsIlBVQkxJU0hfSEVBREVSIiwiU1VCU0NSSUJFX0hFQURFUiIsIlNVQlNDUklCRV9PUFRJT05TX1FPU19NQVNLIiwiU1VCU0NSSUJFX09QVElPTlNfTkxfTUFTSyIsIlNVQlNDUklCRV9PUFRJT05TX05MX1NISUZUIiwiU1VCU0NSSUJFX09QVElPTlNfUkFQX01BU0siLCJTVUJTQ1JJQkVfT1BUSU9OU19SQVBfU0hJRlQiLCJTVUJTQ1JJQkVfT1BUSU9OU19SSF9NQVNLIiwiU1VCU0NSSUJFX09QVElPTlNfUkhfU0hJRlQiLCJTVUJTQ1JJQkVfT1BUSU9OU19SSCIsIlNVQlNDUklCRV9PUFRJT05TX05MIiwiU1VCU0NSSUJFX09QVElPTlNfUkFQIiwiU1VCU0NSSUJFX09QVElPTlNfUU9TIiwiVU5TVUJTQ1JJQkVfSEVBREVSIiwiQUNLUyIsInVuc3ViYWNrIiwicHViYWNrIiwicHViY29tcCIsInB1YnJlbCIsInB1YnJlYyIsIlNVQkFDS19IRUFERVIiLCJWRVJTSU9OMyIsIlZFUlNJT040IiwiVkVSU0lPTjUiLCJRT1MiLCJFTVBUWSIsInBpbmdyZXEiLCJwaW5ncmVzcCIsImRpc2Nvbm5lY3QiLCJFRSIsImdlbmVyYXRlIiwiQWNjdW11bGF0b3IiLCJfYXJyYXkiLCJfaSIsImxlbmd0aHMiLCJEdXBsZXhTdHJlYW0iLCJ1dGlsIiwiQnVmZmVyTGlzdCIsIl9idWZzIiwiX2NhbGxiYWNrIiwicGlwZXIiLCJvblBpcGUiLCJvblVucGlwZSIsImFwcGVuZCIsIl9vZmZzZXQiLCJ0b3QiLCJfdCIsIl9hcHBlbmRCdWZmZXIiLCJhcHBlbmRCdWZmZXIiLCJjb25zdW1lIiwiZHN0U3RhcnQiLCJzcmNTdGFydCIsInNyY0VuZCIsImJ1Zm9mZiIsInNoYWxsb3dTbGljZSIsInN0YXJ0T2Zmc2V0IiwiZW5kT2Zmc2V0IiwiYnVmZmVycyIsImR1cGxpY2F0ZSIsImNhY2hlIiwiZ2VuZXJhdGVCdWZmZXIiLCJnZW5lcmF0ZUNhY2hlIiwiY2FsY1ZhcmlhYmxlQnl0ZUludExlbmd0aCIsImdlbkJ1ZlZhcmlhYmxlQnl0ZUludCIsImRpZ2l0IiwiZ2VuZXJhdGU0Qnl0ZUJ1ZmZlciIsImdlbmVyYXRlTnVtYmVyIiwiUGFja2V0IiwiYmwiLCJjb25zdGFudHMiLCJQYXJzZXIiLCJvcHQiLCJzZXR0aW5ncyIsIl9zdGF0ZXMiLCJfcmVzZXRTdGF0ZSIsIl9saXN0IiwiX3N0YXRlQ291bnRlciIsIl9wYXJzZUhlYWRlciIsInplcm8iLCJfcGFyc2VMZW5ndGgiLCJfcGFyc2VWYXJCeXRlTnVtIiwiX3BhcnNlUGF5bG9hZCIsIl9wb3MiLCJfcGFyc2VDb25uZWN0IiwiX3BhcnNlQ29ubmFjayIsIl9wYXJzZVB1Ymxpc2giLCJfcGFyc2VDb25maXJtYXRpb24iLCJfcGFyc2VTdWJzY3JpYmUiLCJfcGFyc2VTdWJhY2siLCJfcGFyc2VVbnN1YnNjcmliZSIsIl9wYXJzZVVuc3ViYWNrIiwiX3BhcnNlRGlzY29ubmVjdCIsIl9wYXJzZUF1dGgiLCJfZW1pdEVycm9yIiwiZmxhZ3MiLCJfcGFyc2VTdHJpbmciLCJ3aWxsIiwiX3BhcnNlTnVtIiwiX3BhcnNlUHJvcGVydGllcyIsIndpbGxQcm9wZXJ0aWVzIiwiX3BhcnNlQnVmZmVyIiwiX3BhcnNlTWVzc2FnZUlkIiwic3Vic2NyaXB0aW9uIiwiX3BhcnNlQnl0ZSIsIm1heWJlQnVmZmVyIiwiX3BhcnNlU3RyaW5nUGFpciIsIl9wYXJzZTRCeXRlTnVtIiwiZnVsbEluZm9GbGFnIiwiY3VycmVudCIsInBhZGRpbmciLCJfcGFyc2VCeVR5cGUiLCJjdXJyZW50VXNlclByb3BlcnR5IiwiX25ld1BhY2tldCIsImVtcHR5IiwiemVyb0J1ZiIsIm51bWJlcnMiLCJudW1DYWNoZSIsIndyaXRlTnVtYmVyIiwid3JpdGVOdW1iZXJDYWNoZWQiLCJ0b0dlbmVyYXRlIiwiY29uZmlybWF0aW9uIiwic3ViYWNrIiwiZW1wdHlQYWNrZXQiLCJ3cml0ZU51bWJlckdlbmVyYXRlZCIsInByb3BlcnRpZXNEYXRhIiwiZ2V0UHJvcGVydGllcyIsInByb3ZpZGVkVXNlcm5hbWUiLCJpc1N0cmluZ09yQnVmZmVyIiwid3JpdGVWYXJCeXRlSW50Iiwid3JpdGVTdHJpbmdPckJ1ZmZlciIsIndyaXRlU3RyaW5nIiwiZ2V0UHJvcGVydGllc0J5TWF4aW11bVBhY2tldFNpemUiLCJpdG9waWMiLCJpcW9zIiwianRvcGljIiwianFvcyIsImpubCIsImpyYXAiLCJqcmgiLCJqb3B0aW9ucyIsInVuc3VicyIsInZhckJ5dGVJbnRDYWNoZSIsInN0cmxlbiIsIndyaXRlU3RyaW5nUGFpciIsIm51bWJlciIsIndyaXRlNEJ5dGVOdW1iZXIiLCJ0b1dyaXRlIiwid3JpdGVQcm9wZXJ0aWVzIiwicHJvcGVydGllc0xlbmd0aCIsImdldExlbmd0aFByb3BlcnR5IiwicmVkdWNlIiwicHJvcE5hbWUiLCJwcm9wTGVuZ3RoIiwicHJvcGVydGllc0xlbmd0aExlbmd0aCIsIm1heUVtcHR5UHJvcHMiLCJjdXJyZW50TWF5RW1wdHlQcm9wIiwiYnVmT3JTdHJpbmciLCJmaWVsZCIsIndyYXBweSIsInN0cmljdCIsIm9uY2VTdHJpY3QiLCJjYWxsZWQiLCJvbmNlRXJyb3IiLCJhZnRlclRpY2tPbmUiLCJhZnRlclRpY2tUd28iLCJhZnRlclRpY2tUaHJlZSIsImFmdGVyVGljayIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwidGltZW91dCIsInJ1biIsIkl0ZW0iLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb25zIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJyb290IiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJmcmVlR2xvYmFsIiwicHVueWNvZGUiLCJtYXhJbnQiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiYmFzZU1pbnVzVE1pbiIsInN0cmluZ0Zyb21DaGFyQ29kZSIsIm1hcERvbWFpbiIsImxhYmVscyIsImVuY29kZWQiLCJ1Y3MyZGVjb2RlIiwiY291bnRlciIsImV4dHJhIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImRpZ2l0VG9CYXNpYyIsImZsYWciLCJhZGFwdCIsImRlbHRhIiwibnVtUG9pbnRzIiwiZmlyc3RUaW1lIiwiZGVjb2RlIiwiaW5wdXQiLCJpbnB1dExlbmd0aCIsImJpYXMiLCJiYXNpYyIsIm9sZGkiLCJiYXNlTWludXNUIiwiZW5jb2RlIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsInEiLCJjdXJyZW50VmFsdWUiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJxTWludXNUIiwidG9Vbmljb2RlIiwidGVzdCIsInRvQVNDSUkiLCJhbWQiLCJxcyIsInNlcCIsImVxIiwicmVnZXhwIiwibWF4S2V5cyIsImlkeCIsImtzdHIiLCJ2c3RyIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwieHMiLCJzdHJpbmdpZnlQcmltaXRpdmUiLCJrcyIsImVuY29kZVVSSUNvbXBvbmVudCIsInN0cmluZ2lmeSIsInBuYSIsImFsbG93SGFsZk9wZW4iLCJvbkVuZE5UIiwiUGFzc1Rocm91Z2giLCJfdHJhbnNmb3JtIiwiUmVhZGFibGVTdGF0ZSIsIkVFbGlzdGVuZXJDb3VudCIsIlN0cmVhbSIsIk91clVpbnQ4QXJyYXkiLCJfdWludDhBcnJheVRvQnVmZmVyIiwiX2lzVWludDhBcnJheSIsImRlYnVnVXRpbCIsImRlYnVnIiwiZGVidWdsb2ciLCJkZXN0cm95SW1wbCIsIlN0cmluZ0RlY29kZXIiLCJrUHJveHlFdmVudHMiLCJldmVudCIsImlzRHVwbGV4IiwicmVhZGFibGVPYmplY3RNb2RlIiwiaHdtIiwicmVhZGFibGVId20iLCJyZWFkYWJsZUhpZ2hXYXRlck1hcmsiLCJkZWZhdWx0SHdtIiwicGlwZXMiLCJwaXBlc0NvdW50IiwiZmxvd2luZyIsImVuZEVtaXR0ZWQiLCJyZWFkaW5nIiwic3luYyIsIm5lZWRSZWFkYWJsZSIsImVtaXR0ZWRSZWFkYWJsZSIsInJlYWRhYmxlTGlzdGVuaW5nIiwicmVzdW1lU2NoZWR1bGVkIiwiZGVmYXVsdEVuY29kaW5nIiwiYXdhaXREcmFpbiIsInJlYWRpbmdNb3JlIiwiZGVjb2RlciIsIl91bmRlc3Ryb3kiLCJ1bmRlc3Ryb3kiLCJza2lwQ2h1bmtDaGVjayIsInJlYWRhYmxlQWRkQ2h1bmsiLCJhZGRUb0Zyb250Iiwib25Fb2ZDaHVuayIsImNodW5rSW52YWxpZCIsImFkZENodW5rIiwibWF5YmVSZWFkTW9yZSIsIm5lZWRNb3JlRGF0YSIsImVtaXRSZWFkYWJsZSIsImlzUGF1c2VkIiwic2V0RW5jb2RpbmciLCJNQVhfSFdNIiwiY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsiLCJob3dNdWNoVG9SZWFkIiwiaGVhZCIsIm5PcmlnIiwiZW5kUmVhZGFibGUiLCJkb1JlYWQiLCJmcm9tTGlzdCIsImVtaXRSZWFkYWJsZV8iLCJmbG93IiwibWF5YmVSZWFkTW9yZV8iLCJwaXBlT3B0cyIsImRvRW5kIiwic3Rkb3V0Iiwic3RkZXJyIiwiZW5kRm4iLCJ1bnBpcGUiLCJvbnVucGlwZSIsInVucGlwZUluZm8iLCJoYXNVbnBpcGVkIiwiY2xlYW51cCIsInBpcGVPbkRyYWluIiwiY2xlYW5lZFVwIiwib25kYXRhIiwibmVlZERyYWluIiwiaW5jcmVhc2VkQXdhaXREcmFpbiIsInBhdXNlIiwiZGVzdHMiLCJldiIsIm5SZWFkaW5nTmV4dFRpY2siLCJyZXN1bWVfIiwiX3RoaXMiLCJwYXVzZWQiLCJfZnJvbUxpc3QiLCJmcm9tTGlzdFBhcnRpYWwiLCJoYXNTdHJpbmdzIiwiY29weUZyb21CdWZmZXJTdHJpbmciLCJjb3B5RnJvbUJ1ZmZlciIsIm5iIiwidGFpbCIsImVuZFJlYWRhYmxlTlQiLCJhZnRlclRyYW5zZm9ybSIsInRzIiwiX3RyYW5zZm9ybVN0YXRlIiwidHJhbnNmb3JtaW5nIiwid3JpdGVjYiIsIndyaXRlY2h1bmsiLCJuZWVkVHJhbnNmb3JtIiwid3JpdGVlbmNvZGluZyIsInRyYW5zZm9ybSIsInByZWZpbmlzaCIsIl90aGlzMiIsImVycjIiLCJXcml0ZVJlcSIsIkNvcmtlZFJlcXVlc3QiLCJvbkNvcmtlZEZpbmlzaCIsImFzeW5jV3JpdGUiLCJXcml0YWJsZVN0YXRlIiwiaW50ZXJuYWxVdGlsIiwiZGVwcmVjYXRlIiwid3JpdGFibGVPYmplY3RNb2RlIiwid3JpdGFibGVId20iLCJ3cml0YWJsZUhpZ2hXYXRlck1hcmsiLCJmaW5hbENhbGxlZCIsIm5vRGVjb2RlIiwiZGVjb2RlU3RyaW5ncyIsIndyaXRpbmciLCJjb3JrZWQiLCJidWZmZXJQcm9jZXNzaW5nIiwib253cml0ZSIsIndyaXRlbGVuIiwiYnVmZmVyZWRSZXF1ZXN0IiwibGFzdEJ1ZmZlcmVkUmVxdWVzdCIsInBlbmRpbmdjYiIsImVycm9yRW1pdHRlZCIsImJ1ZmZlcmVkUmVxdWVzdENvdW50IiwiY29ya2VkUmVxdWVzdHNGcmVlIiwiZ2V0QnVmZmVyIiwiXyIsInJlYWxIYXNJbnN0YW5jZSIsIndyaXRldiIsIl93cml0ZXYiLCJmaW5hbCIsIl9maW5hbCIsIndyaXRlQWZ0ZXJFbmQiLCJ2YWxpZENodW5rIiwidmFsaWQiLCJpc0J1ZiIsIndyaXRlT3JCdWZmZXIiLCJjbGVhckJ1ZmZlciIsInNldERlZmF1bHRFbmNvZGluZyIsImRlY29kZUNodW5rIiwibmV3Q2h1bmsiLCJsYXN0IiwiZG9Xcml0ZSIsIm9ud3JpdGVFcnJvciIsImZpbmlzaE1heWJlIiwib253cml0ZVN0YXRlVXBkYXRlIiwibmVlZEZpbmlzaCIsImFmdGVyV3JpdGUiLCJvbndyaXRlRHJhaW4iLCJob2xkZXIiLCJhbGxCdWZmZXJzIiwiZW5kV3JpdGFibGUiLCJjYWxsRmluYWwiLCJuZWVkIiwiY29ya1JlcSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJjb3B5QnVmZmVyIiwiY3VzdG9tIiwicmVhZGFibGVEZXN0cm95ZWQiLCJ3cml0YWJsZURlc3Ryb3llZCIsImVtaXRFcnJvck5UIiwiX25vcm1hbGl6ZUVuY29kaW5nIiwicmV0cmllZCIsIm5vcm1hbGl6ZUVuY29kaW5nIiwibmVuYyIsInRleHQiLCJ1dGYxNlRleHQiLCJ1dGYxNkVuZCIsImZpbGxMYXN0IiwidXRmOEZpbGxMYXN0IiwiYmFzZTY0VGV4dCIsImJhc2U2NEVuZCIsInNpbXBsZVdyaXRlIiwic2ltcGxlRW5kIiwibGFzdE5lZWQiLCJsYXN0VG90YWwiLCJsYXN0Q2hhciIsInV0ZjhFbmQiLCJ1dGY4VGV4dCIsInV0ZjhDaGVja0J5dGUiLCJieXRlIiwidXRmOENoZWNrSW5jb21wbGV0ZSIsInV0ZjhDaGVja0V4dHJhQnl0ZXMiLCJ0b3RhbCIsIlJlSW50ZXJ2YWwiLCJpbnRlcnZhbCIsIl9hcmdzIiwiX2ludGVydmFsIiwiY29weVByb3BzIiwiU2FmZUJ1ZmZlciIsImdldFN0YXRlTGVuZ3RoIiwiY2xlYXJJbW1lZGlhdGUiLCJpbW1lZGlhdGVJZHMiLCJuZXh0SW1tZWRpYXRlSWQiLCJUaW1lb3V0IiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJyZWYiLCJlbnJvbGwiLCJpdGVtIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwiYWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsIm9uTmV4dFRpY2siLCJ1cmxQYXJzZSIsInJlc29sdmUiLCJ1cmxSZXNvbHZlIiwicmVzb2x2ZU9iamVjdCIsInVybFJlc29sdmVPYmplY3QiLCJmb3JtYXQiLCJ1cmxGb3JtYXQiLCJVcmwiLCJzbGFzaGVzIiwiaGFzaCIsInBhdGhuYW1lIiwiaHJlZiIsInByb3RvY29sUGF0dGVybiIsInBvcnRQYXR0ZXJuIiwic2ltcGxlUGF0aFBhdHRlcm4iLCJkZWxpbXMiLCJ1bndpc2UiLCJhdXRvRXNjYXBlIiwibm9uSG9zdENoYXJzIiwiaG9zdEVuZGluZ0NoYXJzIiwiaG9zdG5hbWVNYXhMZW4iLCJob3N0bmFtZVBhcnRQYXR0ZXJuIiwiaG9zdG5hbWVQYXJ0U3RhcnQiLCJ1bnNhZmVQcm90b2NvbCIsImhvc3RsZXNzUHJvdG9jb2wiLCJzbGFzaGVkUHJvdG9jb2wiLCJxdWVyeXN0cmluZyIsInBhcnNlUXVlcnlTdHJpbmciLCJzbGFzaGVzRGVub3RlSG9zdCIsInF1ZXJ5SW5kZXgiLCJzcGxpdHRlciIsInVTcGxpdCIsInNsYXNoUmVnZXgiLCJyZXN0Iiwic2ltcGxlUGF0aCIsImV4ZWMiLCJsb3dlclByb3RvIiwiaG9zdEVuZCIsImhlYyIsImF0U2lnbiIsInBhcnNlSG9zdCIsImlwdjZIb3N0bmFtZSIsImhvc3RwYXJ0cyIsInBhcnQiLCJuZXdwYXJ0IiwidmFsaWRQYXJ0cyIsIm5vdEhvc3QiLCJiaXQiLCJoIiwiYWUiLCJlc2MiLCJlc2NhcGUiLCJxbSIsImNoYXJBdCIsInNvdXJjZSIsInJlbGF0aXZlIiwicmVsIiwidGtleXMiLCJ0ayIsInRrZXkiLCJya2V5cyIsInJrIiwicmtleSIsInJlbFBhdGgiLCJpc1NvdXJjZUFicyIsImlzUmVsQWJzIiwibXVzdEVuZEFicyIsInJlbW92ZUFsbERvdHMiLCJzcmNQYXRoIiwicHN5Y2hvdGljIiwiYXV0aEluSG9zdCIsImhhc1RyYWlsaW5nU2xhc2giLCJ1cCIsImlzQWJzb2x1dGUiLCJtc2ciLCJjb25maWciLCJkZXByZWNhdGVkIiwidHJhY2UiLCJsb2NhbFN0b3JhZ2UiLCJmb3JtYXRSZWdFeHAiLCJvYmplY3RzIiwiSlNPTiIsIm5vRGVwcmVjYXRpb24iLCJ0aHJvd0RlcHJlY2F0aW9uIiwidHJhY2VEZXByZWNhdGlvbiIsImRlYnVncyIsImRlYnVnRW52aXJvbiIsIk5PREVfREVCVUciLCJ0b1VwcGVyQ2FzZSIsIlJlZ0V4cCIsInBpZCIsImN0eCIsInNlZW4iLCJzdHlsaXplIiwic3R5bGl6ZU5vQ29sb3IiLCJkZXB0aCIsImNvbG9ycyIsInNob3dIaWRkZW4iLCJfZXh0ZW5kIiwiY3VzdG9tSW5zcGVjdCIsInN0eWxpemVXaXRoQ29sb3IiLCJmb3JtYXRWYWx1ZSIsInN0eWxlcyIsInN0eWxlVHlwZSIsInN0eWxlIiwiYXJyYXlUb0hhc2giLCJyZWN1cnNlVGltZXMiLCJwcmltaXRpdmUiLCJmb3JtYXRQcmltaXRpdmUiLCJ2aXNpYmxlS2V5cyIsImZvcm1hdEVycm9yIiwiRGF0ZSIsImJyYWNlcyIsInRvVVRDU3RyaW5nIiwiZm9ybWF0QXJyYXkiLCJmb3JtYXRQcm9wZXJ0eSIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwic2ltcGxlIiwibGluZSIsIm51bUxpbmVzRXN0IiwicHJldiIsImN1ciIsImFyIiwicGFkIiwibW9udGhzIiwidGltZXN0YW1wIiwidGltZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJvcmlnaW4iLCJhZGQiLCJXUyIsIldlYlNvY2tldFN0cmVhbSIsInNvY2tldFdyaXRlIiwic29ja2V0IiwiaXNCcm93c2VyIiwiV2ViU29ja2V0Iiwic29ja2V0V3JpdGVCcm93c2VyIiwic29ja2V0V3JpdGVOb2RlIiwiYmluYXJ5IiwiYnVmZmVyU2l6ZSIsImJyb3dzZXJCdWZmZXJTaXplIiwiYnVmZmVyVGltZW91dCIsImJyb3dzZXJCdWZmZXJUaW1lb3V0IiwiYmluYXJ5VHlwZSIsInJlYWR5U3RhdGUiLCJPUEVOIiwib25vcGVuIiwib25tZXNzYWdlIiwiY29lcmNlVG9CdWZmZXIiLCJidWZmZXJlZEFtb3VudCIsImNodW5rcyIsIk1veldlYlNvY2tldCIsImV4dGVuZCJdLCJtYXBwaW5ncyI6IkFBQUEsa0ZBQUMsVUFBU0EsQ0FBVCxFQUFXLENBQUMsSUFBRyxJQUFILEVBQTBELENBQUNDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFlRixDQUFDLEVBQWhCLENBQW1CLENBQTlFLE1BQW1GLFVBQThOLENBQTlULEVBQWdVLFlBQVUsQ0FBQyxJQUFJRyxNQUFKLEVBQVdGLE1BQVgsRUFBa0JDLE9BQWxCLENBQTBCLE9BQVEsWUFBVSxDQUFDLFNBQVNFLENBQVQsQ0FBV0MsQ0FBWCxFQUFhQyxDQUFiLEVBQWVDLENBQWYsRUFBaUIsQ0FBQyxTQUFTQyxDQUFULENBQVdDLENBQVgsRUFBYVQsQ0FBYixFQUFlLENBQUMsSUFBRyxDQUFDTSxDQUFDLENBQUNHLENBQUQsQ0FBTCxFQUFTLENBQUMsSUFBRyxDQUFDSixDQUFDLENBQUNJLENBQUQsQ0FBTCxFQUFTLENBQUMsSUFBSUMsQ0FBQyxHQUFDLGNBQVksT0FBT0MsT0FBbkIsSUFBNEJBLE9BQWxDLENBQTBDLElBQUcsQ0FBQ1gsQ0FBRCxJQUFJVSxDQUFQLEVBQVMsT0FBT0EsT0FBQyxDQUFDRCxDQUFELEVBQUcsQ0FBQyxDQUFKLENBQVIsQ0FBZSxJQUFHRyxDQUFILEVBQUssT0FBT0EsQ0FBQyxDQUFDSCxDQUFELEVBQUcsQ0FBQyxDQUFKLENBQVIsQ0FBZSxJQUFJSSxDQUFDLEdBQUMsSUFBSUMsS0FBSixDQUFVLHlCQUF1QkwsQ0FBdkIsR0FBeUIsR0FBbkMsQ0FBTixDQUE4QyxNQUFNSSxDQUFDLENBQUNFLElBQUYsR0FBTyxrQkFBUCxFQUEwQkYsQ0FBaEMsQ0FBa0MsS0FBSUcsQ0FBQyxHQUFDVixDQUFDLENBQUNHLENBQUQsQ0FBRCxHQUFLLEVBQUNQLE9B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QUQsQ0FBWDtBQUNELGFBRkQ7QUFHRDtBQUNELGlCQUFPa2IsR0FBUDtBQUNEO0FBQ0Y7O0FBRUEsS0FuQ1MsRUFtQ1IsRUFuQ1EsQ0EvdWM4eUIsRUFreGNsekIsS0FBSSxDQUFDLFVBQVNqZixPQUFULEVBQWlCVixNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDM0NELFlBQU0sQ0FBQ0MsT0FBUCxHQUFpQndnRCxNQUFqQjs7QUFFQSxVQUFJaDJDLGNBQWMsR0FBRy9HLE1BQU0sQ0FBQytDLFNBQVAsQ0FBaUJnRSxjQUF0Qzs7QUFFQSxlQUFTZzJDLE1BQVQsR0FBa0I7QUFDZCxZQUFJMWpDLE1BQU0sR0FBRyxFQUFiOztBQUVBLGFBQUssSUFBSXZjLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxRSxTQUFTLENBQUM1RCxNQUE5QixFQUFzQ1QsQ0FBQyxFQUF2QyxFQUEyQztBQUN2QyxjQUFJMjVDLE1BQU0sR0FBR3QxQyxTQUFTLENBQUNyRSxDQUFELENBQXRCOztBQUVBLGVBQUssSUFBSTZULEdBQVQsSUFBZ0I4bEMsTUFBaEIsRUFBd0I7QUFDcEIsZ0JBQUkxdkMsY0FBYyxDQUFDekosSUFBZixDQUFvQm01QyxNQUFwQixFQUE0QjlsQyxHQUE1QixDQUFKLEVBQXNDO0FBQ2xDMEksb0JBQU0sQ0FBQzFJLEdBQUQsQ0FBTixHQUFjOGxDLE1BQU0sQ0FBQzlsQyxHQUFELENBQXBCO0FBQ0g7QUFDSjtBQUNKOztBQUVELGVBQU8wSSxNQUFQO0FBQ0g7O0FBRUEsS0FyQlMsRUFxQlIsRUFyQlEsQ0FseGM4eUIsRUFBNWMsRUF1eWNyVyxFQXZ5Y3FXLEVBdXljbFcsQ0FBQyxDQUFELENBdnlja1csRUF1eWM3VixDQXZ5YzZWLENBQVA7QUF3eWNwVyxDQXh5Y0QsRSIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLm1xdHQgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJylcbnZhciBTdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUnKVxudmFyIG1xdHRQYWNrZXQgPSByZXF1aXJlKCdtcXR0LXBhY2tldCcpXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5Xcml0YWJsZVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHJlSW50ZXJ2YWwgPSByZXF1aXJlKCdyZWludGVydmFsJylcbnZhciB2YWxpZGF0aW9ucyA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbnMnKVxudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIHNldEltbWVkaWF0ZSA9IGdsb2JhbC5zZXRJbW1lZGlhdGUgfHwgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIC8vIHdvcmtzIGluIG5vZGUgdjAuOFxuICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKVxufVxudmFyIGRlZmF1bHRDb25uZWN0T3B0aW9ucyA9IHtcbiAga2VlcGFsaXZlOiA2MCxcbiAgcmVzY2hlZHVsZVBpbmdzOiB0cnVlLFxuICBwcm90b2NvbElkOiAnTVFUVCcsXG4gIHByb3RvY29sVmVyc2lvbjogNCxcbiAgcmVjb25uZWN0UGVyaW9kOiAxMDAwLFxuICBjb25uZWN0VGltZW91dDogMzAgKiAxMDAwLFxuICBjbGVhbjogdHJ1ZSxcbiAgcmVzdWJzY3JpYmU6IHRydWVcbn1cbnZhciBlcnJvcnMgPSB7XG4gIDA6ICcnLFxuICAxOiAnVW5hY2NlcHRhYmxlIHByb3RvY29sIHZlcnNpb24nLFxuICAyOiAnSWRlbnRpZmllciByZWplY3RlZCcsXG4gIDM6ICdTZXJ2ZXIgdW5hdmFpbGFibGUnLFxuICA0OiAnQmFkIHVzZXJuYW1lIG9yIHBhc3N3b3JkJyxcbiAgNTogJ05vdCBhdXRob3JpemVkJyxcbiAgMTY6ICdObyBtYXRjaGluZyBzdWJzY3JpYmVycycsXG4gIDE3OiAnTm8gc3Vic2NyaXB0aW9uIGV4aXN0ZWQnLFxuICAxMjg6ICdVbnNwZWNpZmllZCBlcnJvcicsXG4gIDEyOTogJ01hbGZvcm1lZCBQYWNrZXQnLFxuICAxMzA6ICdQcm90b2NvbCBFcnJvcicsXG4gIDEzMTogJ0ltcGxlbWVudGF0aW9uIHNwZWNpZmljIGVycm9yJyxcbiAgMTMyOiAnVW5zdXBwb3J0ZWQgUHJvdG9jb2wgVmVyc2lvbicsXG4gIDEzMzogJ0NsaWVudCBJZGVudGlmaWVyIG5vdCB2YWxpZCcsXG4gIDEzNDogJ0JhZCBVc2VyIE5hbWUgb3IgUGFzc3dvcmQnLFxuICAxMzU6ICdOb3QgYXV0aG9yaXplZCcsXG4gIDEzNjogJ1NlcnZlciB1bmF2YWlsYWJsZScsXG4gIDEzNzogJ1NlcnZlciBidXN5JyxcbiAgMTM4OiAnQmFubmVkJyxcbiAgMTM5OiAnU2VydmVyIHNodXR0aW5nIGRvd24nLFxuICAxNDA6ICdCYWQgYXV0aGVudGljYXRpb24gbWV0aG9kJyxcbiAgMTQxOiAnS2VlcCBBbGl2ZSB0aW1lb3V0JyxcbiAgMTQyOiAnU2Vzc2lvbiB0YWtlbiBvdmVyJyxcbiAgMTQzOiAnVG9waWMgRmlsdGVyIGludmFsaWQnLFxuICAxNDQ6ICdUb3BpYyBOYW1lIGludmFsaWQnLFxuICAxNDU6ICdQYWNrZXQgaWRlbnRpZmllciBpbiB1c2UnLFxuICAxNDY6ICdQYWNrZXQgSWRlbnRpZmllciBub3QgZm91bmQnLFxuICAxNDc6ICdSZWNlaXZlIE1heGltdW0gZXhjZWVkZWQnLFxuICAxNDg6ICdUb3BpYyBBbGlhcyBpbnZhbGlkJyxcbiAgMTQ5OiAnUGFja2V0IHRvbyBsYXJnZScsXG4gIDE1MDogJ01lc3NhZ2UgcmF0ZSB0b28gaGlnaCcsXG4gIDE1MTogJ1F1b3RhIGV4Y2VlZGVkJyxcbiAgMTUyOiAnQWRtaW5pc3RyYXRpdmUgYWN0aW9uJyxcbiAgMTUzOiAnUGF5bG9hZCBmb3JtYXQgaW52YWxpZCcsXG4gIDE1NDogJ1JldGFpbiBub3Qgc3VwcG9ydGVkJyxcbiAgMTU1OiAnUW9TIG5vdCBzdXBwb3J0ZWQnLFxuICAxNTY6ICdVc2UgYW5vdGhlciBzZXJ2ZXInLFxuICAxNTc6ICdTZXJ2ZXIgbW92ZWQnLFxuICAxNTg6ICdTaGFyZWQgU3Vic2NyaXB0aW9ucyBub3Qgc3VwcG9ydGVkJyxcbiAgMTU5OiAnQ29ubmVjdGlvbiByYXRlIGV4Y2VlZGVkJyxcbiAgMTYwOiAnTWF4aW11bSBjb25uZWN0IHRpbWUnLFxuICAxNjE6ICdTdWJzY3JpcHRpb24gSWRlbnRpZmllcnMgbm90IHN1cHBvcnRlZCcsXG4gIDE2MjogJ1dpbGRjYXJkIFN1YnNjcmlwdGlvbnMgbm90IHN1cHBvcnRlZCdcbn1cblxuZnVuY3Rpb24gZGVmYXVsdElkICgpIHtcbiAgcmV0dXJuICdtcXR0anNfJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnN1YnN0cigyLCA4KVxufVxuXG5mdW5jdGlvbiBzZW5kUGFja2V0IChjbGllbnQsIHBhY2tldCwgY2IpIHtcbiAgY2xpZW50LmVtaXQoJ3BhY2tldHNlbmQnLCBwYWNrZXQpXG5cbiAgdmFyIHJlc3VsdCA9IG1xdHRQYWNrZXQud3JpdGVUb1N0cmVhbShwYWNrZXQsIGNsaWVudC5zdHJlYW0sIGNsaWVudC5vcHRpb25zKVxuXG4gIGlmICghcmVzdWx0ICYmIGNiKSB7XG4gICAgY2xpZW50LnN0cmVhbS5vbmNlKCdkcmFpbicsIGNiKVxuICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgY2IoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoIChxdWV1ZSkge1xuICBpZiAocXVldWUpIHtcbiAgICBPYmplY3Qua2V5cyhxdWV1ZSkuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZUlkKSB7XG4gICAgICBpZiAodHlwZW9mIHF1ZXVlW21lc3NhZ2VJZF0uY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcXVldWVbbWVzc2FnZUlkXS5jYihuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gY2xvc2VkJykpXG4gICAgICAgIGRlbGV0ZSBxdWV1ZVttZXNzYWdlSWRdXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFZvbGF0aWxlIChxdWV1ZSkge1xuICBpZiAocXVldWUpIHtcbiAgICBPYmplY3Qua2V5cyhxdWV1ZSkuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZUlkKSB7XG4gICAgICBpZiAocXVldWVbbWVzc2FnZUlkXS52b2xhdGlsZSAmJiB0eXBlb2YgcXVldWVbbWVzc2FnZUlkXS5jYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBxdWV1ZVttZXNzYWdlSWRdLmNiKG5ldyBFcnJvcignQ29ubmVjdGlvbiBjbG9zZWQnKSlcbiAgICAgICAgZGVsZXRlIHF1ZXVlW21lc3NhZ2VJZF1cbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlQW5kU2VuZCAoY2xpZW50LCBwYWNrZXQsIGNiLCBjYlN0b3JlUHV0KSB7XG4gIGNsaWVudC5vdXRnb2luZ1N0b3JlLnB1dChwYWNrZXQsIGZ1bmN0aW9uIHN0b3JlZFBhY2tldCAoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiICYmIGNiKGVycilcbiAgICB9XG4gICAgY2JTdG9yZVB1dCgpXG4gICAgc2VuZFBhY2tldChjbGllbnQsIHBhY2tldCwgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5vcCAoKSB7fVxuXG4vKipcbiAqIE1xdHRDbGllbnQgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIC0gc3RyZWFtXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiAoc2VlIENvbm5lY3Rpb24jY29ubmVjdClcbiAqL1xuZnVuY3Rpb24gTXF0dENsaWVudCAoc3RyZWFtQnVpbGRlciwgb3B0aW9ucykge1xuICB2YXIga1xuICB2YXIgdGhhdCA9IHRoaXNcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTXF0dENsaWVudCkpIHtcbiAgICByZXR1cm4gbmV3IE1xdHRDbGllbnQoc3RyZWFtQnVpbGRlciwgb3B0aW9ucylcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAvLyBEZWZhdWx0c1xuICBmb3IgKGsgaW4gZGVmYXVsdENvbm5lY3RPcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnNba10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLm9wdGlvbnNba10gPSBkZWZhdWx0Q29ubmVjdE9wdGlvbnNba11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zW2tdID0gb3B0aW9uc1trXVxuICAgIH1cbiAgfVxuXG4gIHRoaXMub3B0aW9ucy5jbGllbnRJZCA9ICh0eXBlb2Ygb3B0aW9ucy5jbGllbnRJZCA9PT0gJ3N0cmluZycpID8gb3B0aW9ucy5jbGllbnRJZCA6IGRlZmF1bHRJZCgpXG5cbiAgdGhpcy5vcHRpb25zLmN1c3RvbUhhbmRsZUFja3MgPSAob3B0aW9ucy5wcm90b2NvbFZlcnNpb24gPT09IDUgJiYgb3B0aW9ucy5jdXN0b21IYW5kbGVBY2tzKSA/IG9wdGlvbnMuY3VzdG9tSGFuZGxlQWNrcyA6IGZ1bmN0aW9uICgpIHsgYXJndW1lbnRzWzNdKDApIH1cblxuICB0aGlzLnN0cmVhbUJ1aWxkZXIgPSBzdHJlYW1CdWlsZGVyXG5cbiAgLy8gSW5mbGlnaHQgbWVzc2FnZSBzdG9yYWdlc1xuICB0aGlzLm91dGdvaW5nU3RvcmUgPSBvcHRpb25zLm91dGdvaW5nU3RvcmUgfHwgbmV3IFN0b3JlKClcbiAgdGhpcy5pbmNvbWluZ1N0b3JlID0gb3B0aW9ucy5pbmNvbWluZ1N0b3JlIHx8IG5ldyBTdG9yZSgpXG5cbiAgLy8gU2hvdWxkIFFvUyB6ZXJvIG1lc3NhZ2VzIGJlIHF1ZXVlZCB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGJyb2tlbj9cbiAgdGhpcy5xdWV1ZVFvU1plcm8gPSBvcHRpb25zLnF1ZXVlUW9TWmVybyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMucXVldWVRb1NaZXJvXG5cbiAgLy8gbWFwIG9mIHN1YnNjcmliZWQgdG9waWNzIHRvIHN1cHBvcnQgcmVjb25uZWN0aW9uXG4gIHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzID0ge31cblxuICAvLyBtYXAgb2YgYSBzdWJzY3JpYmUgbWVzc2FnZUlkIGFuZCBhIHRvcGljXG4gIHRoaXMubWVzc2FnZUlkVG9Ub3BpYyA9IHt9XG5cbiAgLy8gUGluZyB0aW1lciwgc2V0dXAgaW4gX3NldHVwUGluZ1RpbWVyXG4gIHRoaXMucGluZ1RpbWVyID0gbnVsbFxuICAvLyBJcyB0aGUgY2xpZW50IGNvbm5lY3RlZD9cbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZVxuICAvLyBBcmUgd2UgZGlzY29ubmVjdGluZz9cbiAgdGhpcy5kaXNjb25uZWN0aW5nID0gZmFsc2VcbiAgLy8gUGFja2V0IHF1ZXVlXG4gIHRoaXMucXVldWUgPSBbXVxuICAvLyBjb25uYWNrIHRpbWVyXG4gIHRoaXMuY29ubmFja1RpbWVyID0gbnVsbFxuICAvLyBSZWNvbm5lY3QgdGltZXJcbiAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGxcbiAgLy8gSXMgcHJvY2Vzc2luZyBzdG9yZT9cbiAgdGhpcy5fc3RvcmVQcm9jZXNzaW5nID0gZmFsc2VcbiAgLy8gUGFja2V0IElkcyBhcmUgcHV0IGludG8gdGhlIHN0b3JlIGR1cmluZyBzdG9yZSBwcm9jZXNzaW5nXG4gIHRoaXMuX3BhY2tldElkc0R1cmluZ1N0b3JlUHJvY2Vzc2luZyA9IHt9XG4gIC8qKlxuICAgKiBNZXNzYWdlSURzIHN0YXJ0aW5nIHdpdGggMVxuICAgKiBlbnN1cmUgdGhhdCBuZXh0SWQgaXMgbWluLiAxLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21xdHRqcy9NUVRULmpzL2lzc3Vlcy84MTBcbiAgICovXG4gIHRoaXMubmV4dElkID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNjU1MzUpKVxuXG4gIC8vIEluZmxpZ2h0IGNhbGxiYWNrc1xuICB0aGlzLm91dGdvaW5nID0ge31cblxuICAvLyBUcnVlIGlmIGNvbm5lY3Rpb24gaXMgZmlyc3QgdGltZS5cbiAgdGhpcy5fZmlyc3RDb25uZWN0aW9uID0gdHJ1ZVxuXG4gIC8vIE1hcmsgZGlzY29ubmVjdGVkIG9uIHN0cmVhbSBjbG9zZVxuICB0aGlzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmFja1RpbWVyKVxuICB9KVxuXG4gIC8vIFNlbmQgcXVldWVkIHBhY2tldHNcbiAgdGhpcy5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlXG5cbiAgICBmdW5jdGlvbiBkZWxpdmVyICgpIHtcbiAgICAgIHZhciBlbnRyeSA9IHF1ZXVlLnNoaWZ0KClcbiAgICAgIHZhciBwYWNrZXQgPSBudWxsXG5cbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHBhY2tldCA9IGVudHJ5LnBhY2tldFxuXG4gICAgICB0aGF0Ll9zZW5kUGFja2V0KFxuICAgICAgICBwYWNrZXQsXG4gICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoZW50cnkuY2IpIHtcbiAgICAgICAgICAgIGVudHJ5LmNiKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsaXZlcigpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBkZWxpdmVyKClcbiAgfSlcblxuICAvLyBDbGVhciBwaW5nIHRpbWVyXG4gIHRoaXMub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGF0LnBpbmdUaW1lciAhPT0gbnVsbCkge1xuICAgICAgdGhhdC5waW5nVGltZXIuY2xlYXIoKVxuICAgICAgdGhhdC5waW5nVGltZXIgPSBudWxsXG4gICAgfVxuICB9KVxuXG4gIC8vIFNldHVwIHJlY29ubmVjdCB0aW1lciBvbiBkaXNjb25uZWN0XG4gIHRoaXMub24oJ2Nsb3NlJywgdGhpcy5fc2V0dXBSZWNvbm5lY3QpXG5cbiAgZXZlbnRzLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpXG5cbiAgdGhpcy5fc2V0dXBTdHJlYW0oKVxufVxuaW5oZXJpdHMoTXF0dENsaWVudCwgZXZlbnRzLkV2ZW50RW1pdHRlcilcblxuLyoqXG4gKiBzZXR1cCB0aGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhlIGlubmVyIHN0cmVhbS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3NldHVwU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29ubmVjdFBhY2tldFxuICB2YXIgdGhhdCA9IHRoaXNcbiAgdmFyIHdyaXRhYmxlID0gbmV3IFdyaXRhYmxlKClcbiAgdmFyIHBhcnNlciA9IG1xdHRQYWNrZXQucGFyc2VyKHRoaXMub3B0aW9ucylcbiAgdmFyIGNvbXBsZXRlUGFyc2UgPSBudWxsXG4gIHZhciBwYWNrZXRzID0gW11cblxuICB0aGlzLl9jbGVhclJlY29ubmVjdCgpXG5cbiAgdGhpcy5zdHJlYW0gPSB0aGlzLnN0cmVhbUJ1aWxkZXIodGhpcylcblxuICBwYXJzZXIub24oJ3BhY2tldCcsIGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICBwYWNrZXRzLnB1c2gocGFja2V0KVxuICB9KVxuXG4gIGZ1bmN0aW9uIG5leHRUaWNrV29yayAoKSB7XG4gICAgaWYgKHBhY2tldHMubGVuZ3RoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKHdvcmspXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkb25lID0gY29tcGxldGVQYXJzZVxuICAgICAgY29tcGxldGVQYXJzZSA9IG51bGxcbiAgICAgIGRvbmUoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmsgKCkge1xuICAgIHZhciBwYWNrZXQgPSBwYWNrZXRzLnNoaWZ0KClcblxuICAgIGlmIChwYWNrZXQpIHtcbiAgICAgIHRoYXQuX2hhbmRsZVBhY2tldChwYWNrZXQsIG5leHRUaWNrV29yaylcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRvbmUgPSBjb21wbGV0ZVBhcnNlXG4gICAgICBjb21wbGV0ZVBhcnNlID0gbnVsbFxuICAgICAgaWYgKGRvbmUpIGRvbmUoKVxuICAgIH1cbiAgfVxuXG4gIHdyaXRhYmxlLl93cml0ZSA9IGZ1bmN0aW9uIChidWYsIGVuYywgZG9uZSkge1xuICAgIGNvbXBsZXRlUGFyc2UgPSBkb25lXG4gICAgcGFyc2VyLnBhcnNlKGJ1ZilcbiAgICB3b3JrKClcbiAgfVxuXG4gIHRoaXMuc3RyZWFtLnBpcGUod3JpdGFibGUpXG5cbiAgLy8gU3VwcHJlc3MgY29ubmVjdGlvbiBlcnJvcnNcbiAgdGhpcy5zdHJlYW0ub24oJ2Vycm9yJywgbm9wKVxuXG4gIC8vIEVjaG8gc3RyZWFtIGNsb3NlXG4gIHRoaXMuc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBmbHVzaFZvbGF0aWxlKHRoYXQub3V0Z29pbmcpXG4gICAgdGhhdC5lbWl0KCdjbG9zZScpXG4gIH0pXG5cbiAgLy8gU2VuZCBhIGNvbm5lY3QgcGFja2V0XG4gIGNvbm5lY3RQYWNrZXQgPSBPYmplY3QuY3JlYXRlKHRoaXMub3B0aW9ucylcbiAgY29ubmVjdFBhY2tldC5jbWQgPSAnY29ubmVjdCdcbiAgLy8gYXZvaWQgbWVzc2FnZSBxdWV1ZVxuICBzZW5kUGFja2V0KHRoaXMsIGNvbm5lY3RQYWNrZXQpXG5cbiAgLy8gRWNobyBjb25uZWN0aW9uIGVycm9yc1xuICBwYXJzZXIub24oJ2Vycm9yJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJykpXG5cbiAgLy8gYXV0aFxuICBpZiAodGhpcy5vcHRpb25zLnByb3BlcnRpZXMpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5wcm9wZXJ0aWVzLmF1dGhlbnRpY2F0aW9uTWV0aG9kICYmIHRoaXMub3B0aW9ucy5wcm9wZXJ0aWVzLmF1dGhlbnRpY2F0aW9uRGF0YSkge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignUGFja2V0IGhhcyBubyBBdXRoZW50aWNhdGlvbiBNZXRob2QnKSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJvcGVydGllcy5hdXRoZW50aWNhdGlvbk1ldGhvZCAmJiB0aGlzLm9wdGlvbnMuYXV0aFBhY2tldCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmF1dGhQYWNrZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYXV0aFBhY2tldCA9IHh0ZW5kKHtjbWQ6ICdhdXRoJywgcmVhc29uQ29kZTogMH0sIHRoaXMub3B0aW9ucy5hdXRoUGFja2V0KVxuICAgICAgc2VuZFBhY2tldCh0aGlzLCBhdXRoUGFja2V0KVxuICAgIH1cbiAgfVxuXG4gIC8vIG1hbnkgZHJhaW4gbGlzdGVuZXJzIGFyZSBuZWVkZWQgZm9yIHFvcyAxIGNhbGxiYWNrcyBpZiB0aGUgY29ubmVjdGlvbiBpcyBpbnRlcm1pdHRlbnRcbiAgdGhpcy5zdHJlYW0uc2V0TWF4TGlzdGVuZXJzKDEwMDApXG5cbiAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmFja1RpbWVyKVxuICB0aGlzLmNvbm5hY2tUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHRoYXQuX2NsZWFuVXAodHJ1ZSlcbiAgfSwgdGhpcy5vcHRpb25zLmNvbm5lY3RUaW1lb3V0KVxufVxuXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgZG9uZSkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIGlmIChvcHRpb25zLnByb3RvY29sVmVyc2lvbiA9PT0gNSAmJiBvcHRpb25zLnByb3BlcnRpZXMgJiYgb3B0aW9ucy5wcm9wZXJ0aWVzLm1heGltdW1QYWNrZXRTaXplICYmIG9wdGlvbnMucHJvcGVydGllcy5tYXhpbXVtUGFja2V0U2l6ZSA8IHBhY2tldC5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdleGNlZWRpbmcgcGFja2V0cyBzaXplICcgKyBwYWNrZXQuY21kKSlcbiAgICB0aGlzLmVuZCh7cmVhc29uQ29kZTogMTQ5LCBwcm9wZXJ0aWVzOiB7IHJlYXNvblN0cmluZzogJ01heGltdW0gcGFja2V0IHNpemUgd2FzIGV4Y2VlZGVkJyB9fSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdGhpcy5lbWl0KCdwYWNrZXRyZWNlaXZlJywgcGFja2V0KVxuXG4gIHN3aXRjaCAocGFja2V0LmNtZCkge1xuICAgIGNhc2UgJ3B1Ymxpc2gnOlxuICAgICAgdGhpcy5faGFuZGxlUHVibGlzaChwYWNrZXQsIGRvbmUpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3B1YmFjayc6XG4gICAgY2FzZSAncHVicmVjJzpcbiAgICBjYXNlICdwdWJjb21wJzpcbiAgICBjYXNlICdzdWJhY2snOlxuICAgIGNhc2UgJ3Vuc3ViYWNrJzpcbiAgICAgIHRoaXMuX2hhbmRsZUFjayhwYWNrZXQpXG4gICAgICBkb25lKClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncHVicmVsJzpcbiAgICAgIHRoaXMuX2hhbmRsZVB1YnJlbChwYWNrZXQsIGRvbmUpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Nvbm5hY2snOlxuICAgICAgdGhpcy5faGFuZGxlQ29ubmFjayhwYWNrZXQpXG4gICAgICBkb25lKClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncGluZ3Jlc3AnOlxuICAgICAgdGhpcy5faGFuZGxlUGluZ3Jlc3AocGFja2V0KVxuICAgICAgZG9uZSgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdChwYWNrZXQpXG4gICAgICBkb25lKClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIC8vIG1heWJlIHdlIHNob3VsZCBkbyBhbiBlcnJvciBoYW5kbGluZ1xuICAgICAgLy8gb3IganVzdCBsb2cgaXRcbiAgICAgIGJyZWFrXG4gIH1cbn1cblxuTXF0dENsaWVudC5wcm90b3R5cGUuX2NoZWNrRGlzY29ubmVjdGluZyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBpZiAodGhpcy5kaXNjb25uZWN0aW5nKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ2NsaWVudCBkaXNjb25uZWN0aW5nJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2NsaWVudCBkaXNjb25uZWN0aW5nJykpXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLmRpc2Nvbm5lY3Rpbmdcbn1cblxuLyoqXG4gKiBwdWJsaXNoIC0gcHVibGlzaCA8bWVzc2FnZT4gdG8gPHRvcGljPlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b3BpYyAtIHRvcGljIHRvIHB1Ymxpc2ggdG9cbiAqIEBwYXJhbSB7U3RyaW5nLCBCdWZmZXJ9IG1lc3NhZ2UgLSBtZXNzYWdlIHRvIHB1Ymxpc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBwdWJsaXNoIG9wdGlvbnMsIGluY2x1ZGVzOlxuICogICAge051bWJlcn0gcW9zIC0gcW9zIGxldmVsIHRvIHB1Ymxpc2ggb25cbiAqICAgIHtCb29sZWFufSByZXRhaW4gLSB3aGV0aGVyIG9yIG5vdCB0byByZXRhaW4gdGhlIG1lc3NhZ2VcbiAqICAgIHtCb29sZWFufSBkdXAgLSB3aGV0aGVyIG9yIG5vdCBtYXJrIGEgbWVzc2FnZSBhcyBkdXBsaWNhdGVcbiAqICAgIHtGdW5jdGlvbn0gY2JTdG9yZVB1dCAtIGZ1bmN0aW9uKCl7fSBjYWxsZWQgd2hlbiBtZXNzYWdlIGlzIHB1dCBpbnRvIGBvdXRnb2luZ1N0b3JlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIGZ1bmN0aW9uKGVycil7fVxuICogICAgY2FsbGVkIHdoZW4gcHVibGlzaCBzdWNjZWVkcyBvciBmYWlsc1xuICogQHJldHVybnMge01xdHRDbGllbnR9IHRoaXMgLSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKlxuICogQGV4YW1wbGUgY2xpZW50LnB1Ymxpc2goJ3RvcGljJywgJ21lc3NhZ2UnKTtcbiAqIEBleGFtcGxlXG4gKiAgICAgY2xpZW50LnB1Ymxpc2goJ3RvcGljJywgJ21lc3NhZ2UnLCB7cW9zOiAxLCByZXRhaW46IHRydWUsIGR1cDogdHJ1ZX0pO1xuICogQGV4YW1wbGUgY2xpZW50LnB1Ymxpc2goJ3RvcGljJywgJ21lc3NhZ2UnLCBjb25zb2xlLmxvZyk7XG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAodG9waWMsIG1lc3NhZ2UsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIHZhciBwYWNrZXRcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyAucHVibGlzaCh0b3BpYywgcGF5bG9hZCwgY2IpO1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHNcbiAgICBvcHRzID0gbnVsbFxuICB9XG5cbiAgLy8gZGVmYXVsdCBvcHRzXG4gIHZhciBkZWZhdWx0T3B0cyA9IHtxb3M6IDAsIHJldGFpbjogZmFsc2UsIGR1cDogZmFsc2V9XG4gIG9wdHMgPSB4dGVuZChkZWZhdWx0T3B0cywgb3B0cylcblxuICBpZiAodGhpcy5fY2hlY2tEaXNjb25uZWN0aW5nKGNhbGxiYWNrKSkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwYWNrZXQgPSB7XG4gICAgY21kOiAncHVibGlzaCcsXG4gICAgdG9waWM6IHRvcGljLFxuICAgIHBheWxvYWQ6IG1lc3NhZ2UsXG4gICAgcW9zOiBvcHRzLnFvcyxcbiAgICByZXRhaW46IG9wdHMucmV0YWluLFxuICAgIG1lc3NhZ2VJZDogdGhpcy5fbmV4dElkKCksXG4gICAgZHVwOiBvcHRzLmR1cFxuICB9XG5cbiAgaWYgKG9wdGlvbnMucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgcGFja2V0LnByb3BlcnRpZXMgPSBvcHRzLnByb3BlcnRpZXNcbiAgICBpZiAoKCFvcHRpb25zLnByb3BlcnRpZXMgJiYgcGFja2V0LnByb3BlcnRpZXMgJiYgcGFja2V0LnByb3BlcnRpZXMudG9waWNBbGlhcykgfHwgKChvcHRzLnByb3BlcnRpZXMgJiYgb3B0aW9ucy5wcm9wZXJ0aWVzKSAmJlxuICAgICAgKChvcHRzLnByb3BlcnRpZXMudG9waWNBbGlhcyAmJiBvcHRpb25zLnByb3BlcnRpZXMudG9waWNBbGlhc01heGltdW0gJiYgb3B0cy5wcm9wZXJ0aWVzLnRvcGljQWxpYXMgPiBvcHRpb25zLnByb3BlcnRpZXMudG9waWNBbGlhc01heGltdW0pIHx8XG4gICAgICAgICghb3B0aW9ucy5wcm9wZXJ0aWVzLnRvcGljQWxpYXNNYXhpbXVtICYmIG9wdHMucHJvcGVydGllcy50b3BpY0FsaWFzKSkpKSB7XG4gICAgICAvKlxuICAgICAgaWYgd2UgYXJlIGRvbmB0IHNldHVwIHRvcGljIGFsaWFzIG9yXG4gICAgICB0b3BpYyBhbGlhcyBtYXhpbXVtIGxlc3MgdGhhbiB0b3BpYyBhbGlhcyBvclxuICAgICAgc2VydmVyIGRvbmB0IGdpdmUgdG9waWMgYWxpYXMgbWF4aW11bSxcbiAgICAgIHdlIGFyZSByZW1vdmluZyB0b3BpYyBhbGlhcyBmcm9tIHBhY2tldFxuICAgICAgKi9cbiAgICAgIGRlbGV0ZSBwYWNrZXQucHJvcGVydGllcy50b3BpY0FsaWFzXG4gICAgfVxuICB9XG5cbiAgc3dpdGNoIChvcHRzLnFvcykge1xuICAgIGNhc2UgMTpcbiAgICBjYXNlIDI6XG4gICAgICAvLyBBZGQgdG8gY2FsbGJhY2tzXG4gICAgICB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID0ge1xuICAgICAgICB2b2xhdGlsZTogZmFsc2UsXG4gICAgICAgIGNiOiBjYWxsYmFjayB8fCBub3BcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zdG9yZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgdGhpcy5fcGFja2V0SWRzRHVyaW5nU3RvcmVQcm9jZXNzaW5nW3BhY2tldC5tZXNzYWdlSWRdID0gZmFsc2VcbiAgICAgICAgdGhpcy5fc3RvcmVQYWNrZXQocGFja2V0LCB1bmRlZmluZWQsIG9wdHMuY2JTdG9yZVB1dClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbmRQYWNrZXQocGFja2V0LCB1bmRlZmluZWQsIG9wdHMuY2JTdG9yZVB1dClcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0aGlzLl9zdG9yZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgdGhpcy5fc3RvcmVQYWNrZXQocGFja2V0LCBjYWxsYmFjaywgb3B0cy5jYlN0b3JlUHV0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VuZFBhY2tldChwYWNrZXQsIGNhbGxiYWNrLCBvcHRzLmNiU3RvcmVQdXQpXG4gICAgICB9XG4gICAgICBicmVha1xuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBzdWJzY3JpYmUgLSBzdWJzY3JpYmUgdG8gPHRvcGljPlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nLCBBcnJheSwgT2JqZWN0fSB0b3BpYyAtIHRvcGljKHMpIHRvIHN1YnNjcmliZSB0bywgc3VwcG9ydHMgb2JqZWN0cyBpbiB0aGUgZm9ybSB7J3RvcGljJzogcW9zfVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbmFsIHN1YnNjcmlwdGlvbiBvcHRpb25zLCBpbmNsdWRlczpcbiAqICAgIHtOdW1iZXJ9IHFvcyAtIHN1YnNjcmliZSBxb3MgbGV2ZWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBmdW5jdGlvbihlcnIsIGdyYW50ZWQpe30gd2hlcmU6XG4gKiAgICB7RXJyb3J9IGVyciAtIHN1YnNjcmlwdGlvbiBlcnJvciAobm9uZSBhdCB0aGUgbW9tZW50ISlcbiAqICAgIHtBcnJheX0gZ3JhbnRlZCAtIGFycmF5IG9mIHt0b3BpYzogJ3QnLCBxb3M6IDB9XG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqIEBleGFtcGxlIGNsaWVudC5zdWJzY3JpYmUoJ3RvcGljJyk7XG4gKiBAZXhhbXBsZSBjbGllbnQuc3Vic2NyaWJlKCd0b3BpYycsIHtxb3M6IDF9KTtcbiAqIEBleGFtcGxlIGNsaWVudC5zdWJzY3JpYmUoeyd0b3BpYyc6IHtxb3M6IDB9LCAndG9waWMyJzoge3FvczogMX19LCBjb25zb2xlLmxvZyk7XG4gKiBAZXhhbXBsZSBjbGllbnQuc3Vic2NyaWJlKCd0b3BpYycsIGNvbnNvbGUubG9nKTtcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICB9XG4gIHZhciBzdWJzID0gW11cbiAgdmFyIG9iaiA9IGFyZ3Muc2hpZnQoKVxuICB2YXIgcmVzdWJzY3JpYmUgPSBvYmoucmVzdWJzY3JpYmVcbiAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKSB8fCBub3BcbiAgdmFyIG9wdHMgPSBhcmdzLnBvcCgpXG4gIHZhciBpbnZhbGlkVG9waWNcbiAgdmFyIHRoYXQgPSB0aGlzXG4gIHZhciB2ZXJzaW9uID0gdGhpcy5vcHRpb25zLnByb3RvY29sVmVyc2lvblxuXG4gIGRlbGV0ZSBvYmoucmVzdWJzY3JpYmVcblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICBvYmogPSBbb2JqXVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMgPSBjYWxsYmFja1xuICAgIGNhbGxiYWNrID0gbm9wXG4gIH1cblxuICBpbnZhbGlkVG9waWMgPSB2YWxpZGF0aW9ucy52YWxpZGF0ZVRvcGljcyhvYmopXG4gIGlmIChpbnZhbGlkVG9waWMgIT09IG51bGwpIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2ssIG5ldyBFcnJvcignSW52YWxpZCB0b3BpYyAnICsgaW52YWxpZFRvcGljKSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaWYgKHRoaXMuX2NoZWNrRGlzY29ubmVjdGluZyhjYWxsYmFjaykpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIGRlZmF1bHRPcHRzID0ge1xuICAgIHFvczogMFxuICB9XG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgZGVmYXVsdE9wdHMubmwgPSBmYWxzZVxuICAgIGRlZmF1bHRPcHRzLnJhcCA9IGZhbHNlXG4gICAgZGVmYXVsdE9wdHMucmggPSAwXG4gIH1cbiAgb3B0cyA9IHh0ZW5kKGRlZmF1bHRPcHRzLCBvcHRzKVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAodG9waWMpIHtcbiAgICAgIGlmICghdGhhdC5fcmVzdWJzY3JpYmVUb3BpY3MuaGFzT3duUHJvcGVydHkodG9waWMpIHx8XG4gICAgICAgIHRoYXQuX3Jlc3Vic2NyaWJlVG9waWNzW3RvcGljXS5xb3MgPCBvcHRzLnFvcyB8fFxuICAgICAgICAgIHJlc3Vic2NyaWJlKSB7XG4gICAgICAgIHZhciBjdXJyZW50T3B0cyA9IHtcbiAgICAgICAgICB0b3BpYzogdG9waWMsXG4gICAgICAgICAgcW9zOiBvcHRzLnFvc1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgICAgICAgY3VycmVudE9wdHMubmwgPSBvcHRzLm5sXG4gICAgICAgICAgY3VycmVudE9wdHMucmFwID0gb3B0cy5yYXBcbiAgICAgICAgICBjdXJyZW50T3B0cy5yaCA9IG9wdHMucmhcbiAgICAgICAgICBjdXJyZW50T3B0cy5wcm9wZXJ0aWVzID0gb3B0cy5wcm9wZXJ0aWVzXG4gICAgICAgIH1cbiAgICAgICAgc3Vicy5wdXNoKGN1cnJlbnRPcHRzKVxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0XG4gICAgICAua2V5cyhvYmopXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoIXRoYXQuX3Jlc3Vic2NyaWJlVG9waWNzLmhhc093blByb3BlcnR5KGspIHx8XG4gICAgICAgICAgdGhhdC5fcmVzdWJzY3JpYmVUb3BpY3Nba10ucW9zIDwgb2JqW2tdLnFvcyB8fFxuICAgICAgICAgICAgcmVzdWJzY3JpYmUpIHtcbiAgICAgICAgICB2YXIgY3VycmVudE9wdHMgPSB7XG4gICAgICAgICAgICB0b3BpYzogayxcbiAgICAgICAgICAgIHFvczogb2JqW2tdLnFvc1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgICAgICAgICAgY3VycmVudE9wdHMubmwgPSBvYmpba10ubmxcbiAgICAgICAgICAgIGN1cnJlbnRPcHRzLnJhcCA9IG9ialtrXS5yYXBcbiAgICAgICAgICAgIGN1cnJlbnRPcHRzLnJoID0gb2JqW2tdLnJoXG4gICAgICAgICAgICBjdXJyZW50T3B0cy5wcm9wZXJ0aWVzID0gb3B0cy5wcm9wZXJ0aWVzXG4gICAgICAgICAgfVxuICAgICAgICAgIHN1YnMucHVzaChjdXJyZW50T3B0cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIHBhY2tldCA9IHtcbiAgICBjbWQ6ICdzdWJzY3JpYmUnLFxuICAgIHN1YnNjcmlwdGlvbnM6IHN1YnMsXG4gICAgcW9zOiAxLFxuICAgIHJldGFpbjogZmFsc2UsXG4gICAgZHVwOiBmYWxzZSxcbiAgICBtZXNzYWdlSWQ6IHRoaXMuX25leHRJZCgpXG4gIH1cblxuICBpZiAob3B0cy5wcm9wZXJ0aWVzKSB7XG4gICAgcGFja2V0LnByb3BlcnRpZXMgPSBvcHRzLnByb3BlcnRpZXNcbiAgfVxuXG4gIGlmICghc3Vicy5sZW5ndGgpIHtcbiAgICBjYWxsYmFjayhudWxsLCBbXSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIHN1YnNjcmlwdGlvbnMgdG8gcmVzdWJzY3JpYmUgdG8gaW4gY2FzZSBvZiBkaXNjb25uZWN0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVzdWJzY3JpYmUpIHtcbiAgICB2YXIgdG9waWNzID0gW11cbiAgICBzdWJzLmZvckVhY2goZnVuY3Rpb24gKHN1Yikge1xuICAgICAgaWYgKHRoYXQub3B0aW9ucy5yZWNvbm5lY3RQZXJpb2QgPiAwKSB7XG4gICAgICAgIHZhciB0b3BpYyA9IHsgcW9zOiBzdWIucW9zIH1cbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICAgICAgICB0b3BpYy5ubCA9IHN1Yi5ubCB8fCBmYWxzZVxuICAgICAgICAgIHRvcGljLnJhcCA9IHN1Yi5yYXAgfHwgZmFsc2VcbiAgICAgICAgICB0b3BpYy5yaCA9IHN1Yi5yaCB8fCAwXG4gICAgICAgICAgdG9waWMucHJvcGVydGllcyA9IHN1Yi5wcm9wZXJ0aWVzXG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fcmVzdWJzY3JpYmVUb3BpY3Nbc3ViLnRvcGljXSA9IHRvcGljXG4gICAgICAgIHRvcGljcy5wdXNoKHN1Yi50b3BpYylcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoYXQubWVzc2FnZUlkVG9Ub3BpY1twYWNrZXQubWVzc2FnZUlkXSA9IHRvcGljc1xuICB9XG5cbiAgdGhpcy5vdXRnb2luZ1twYWNrZXQubWVzc2FnZUlkXSA9IHtcbiAgICB2b2xhdGlsZTogdHJ1ZSxcbiAgICBjYjogZnVuY3Rpb24gKGVyciwgcGFja2V0KSB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICB2YXIgZ3JhbnRlZCA9IHBhY2tldC5ncmFudGVkXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhbnRlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHN1YnNbaV0ucW9zID0gZ3JhbnRlZFtpXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKGVyciwgc3VicylcbiAgICB9XG4gIH1cblxuICB0aGlzLl9zZW5kUGFja2V0KHBhY2tldClcblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIHVuc3Vic2NyaWJlIC0gdW5zdWJzY3JpYmUgZnJvbSB0b3BpYyhzKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nLCBBcnJheX0gdG9waWMgLSB0b3BpY3MgdG8gdW5zdWJzY3JpYmUgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbmFsIHN1YnNjcmlwdGlvbiBvcHRpb25zLCBpbmNsdWRlczpcbiAqICAgIHtPYmplY3R9IHByb3BlcnRpZXMgLSBwcm9wZXJ0aWVzIG9mIHVuc3Vic2NyaWJlIHBhY2tldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIGNhbGxiYWNrIGZpcmVkIG9uIHVuc3ViYWNrXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqIEBleGFtcGxlIGNsaWVudC51bnN1YnNjcmliZSgndG9waWMnKTtcbiAqIEBleGFtcGxlIGNsaWVudC51bnN1YnNjcmliZSgndG9waWMnLCBjb25zb2xlLmxvZyk7XG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0ge1xuICAgIGNtZDogJ3Vuc3Vic2NyaWJlJyxcbiAgICBxb3M6IDEsXG4gICAgbWVzc2FnZUlkOiB0aGlzLl9uZXh0SWQoKVxuICB9XG4gIHZhciB0aGF0ID0gdGhpc1xuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgfVxuICB2YXIgdG9waWMgPSBhcmdzLnNoaWZ0KClcbiAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKSB8fCBub3BcbiAgdmFyIG9wdHMgPSBhcmdzLnBvcCgpXG5cbiAgaWYgKHR5cGVvZiB0b3BpYyA9PT0gJ3N0cmluZycpIHtcbiAgICB0b3BpYyA9IFt0b3BpY11cbiAgfVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0gY2FsbGJhY2tcbiAgICBjYWxsYmFjayA9IG5vcFxuICB9XG5cbiAgaWYgKHRoaXMuX2NoZWNrRGlzY29ubmVjdGluZyhjYWxsYmFjaykpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3BpYyA9PT0gJ3N0cmluZycpIHtcbiAgICBwYWNrZXQudW5zdWJzY3JpcHRpb25zID0gW3RvcGljXVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0b3BpYyA9PT0gJ29iamVjdCcgJiYgdG9waWMubGVuZ3RoKSB7XG4gICAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucyA9IHRvcGljXG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnJlc3Vic2NyaWJlKSB7XG4gICAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgZGVsZXRlIHRoYXQuX3Jlc3Vic2NyaWJlVG9waWNzW3RvcGljXVxuICAgIH0pXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmIG9wdHMucHJvcGVydGllcykge1xuICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gb3B0cy5wcm9wZXJ0aWVzXG4gIH1cblxuICB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID0ge1xuICAgIHZvbGF0aWxlOiB0cnVlLFxuICAgIGNiOiBjYWxsYmFja1xuICB9XG5cbiAgdGhpcy5fc2VuZFBhY2tldChwYWNrZXQpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBlbmQgLSBjbG9zZSBjb25uZWN0aW9uXG4gKlxuICogQHJldHVybnMge01xdHRDbGllbnR9IHRoaXMgLSBmb3IgY2hhaW5pbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgLSBkbyBub3Qgd2FpdCBmb3IgYWxsIGluLWZsaWdodCBtZXNzYWdlcyB0byBiZSBhY2tlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsZWQgd2hlbiB0aGUgY2xpZW50IGhhcyBiZWVuIGNsb3NlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgdmFyIGZvcmNlID0gYXJndW1lbnRzWzBdXG4gIHZhciBvcHRzID0gYXJndW1lbnRzWzFdXG4gIHZhciBjYiA9IGFyZ3VtZW50c1syXVxuXG4gIGlmIChmb3JjZSA9PSBudWxsIHx8IHR5cGVvZiBmb3JjZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgY2IgPSBvcHRzIHx8IG5vcFxuICAgIG9wdHMgPSBmb3JjZVxuICAgIGZvcmNlID0gZmFsc2VcbiAgICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICBjYiA9IG9wdHNcbiAgICAgIG9wdHMgPSBudWxsXG4gICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gbm9wXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgIGNiID0gb3B0c1xuICAgIG9wdHMgPSBudWxsXG4gIH1cblxuICBjYiA9IGNiIHx8IG5vcFxuXG4gIGZ1bmN0aW9uIGNsb3NlU3RvcmVzICgpIHtcbiAgICB0aGF0LmRpc2Nvbm5lY3RlZCA9IHRydWVcbiAgICB0aGF0LmluY29taW5nU3RvcmUuY2xvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5vdXRnb2luZ1N0b3JlLmNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICAgIHRoYXQuZW1pdCgnZW5kJylcbiAgICAgIH0pXG4gICAgfSlcbiAgICBpZiAodGhhdC5fZGVmZXJyZWRSZWNvbm5lY3QpIHtcbiAgICAgIHRoYXQuX2RlZmVycmVkUmVjb25uZWN0KClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICAgIC8vIGRlZmVyIGNsb3Nlc1N0b3JlcyBvZiBhbiBJL08gY3ljbGUsXG4gICAgLy8ganVzdCB0byBtYWtlIHN1cmUgdGhpbmdzIGFyZVxuICAgIC8vIG9rIGZvciB3ZWJzb2NrZXRzXG4gICAgdGhhdC5fY2xlYW5VcChmb3JjZSwgc2V0SW1tZWRpYXRlLmJpbmQobnVsbCwgY2xvc2VTdG9yZXMpLCBvcHRzKVxuICB9XG5cbiAgaWYgKHRoaXMuZGlzY29ubmVjdGluZykge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0aGlzLl9jbGVhclJlY29ubmVjdCgpXG5cbiAgdGhpcy5kaXNjb25uZWN0aW5nID0gdHJ1ZVxuXG4gIGlmICghZm9yY2UgJiYgT2JqZWN0LmtleXModGhpcy5vdXRnb2luZykubGVuZ3RoID4gMCkge1xuICAgIC8vIHdhaXQgMTBtcywganVzdCB0byBiZSBzdXJlIHdlIHJlY2VpdmVkIGFsbCBvZiBpdFxuICAgIHRoaXMub25jZSgnb3V0Z29pbmdFbXB0eScsIHNldFRpbWVvdXQuYmluZChudWxsLCBmaW5pc2gsIDEwKSlcbiAgfSBlbHNlIHtcbiAgICBmaW5pc2goKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiByZW1vdmVPdXRnb2luZ01lc3NhZ2UgLSByZW1vdmUgYSBtZXNzYWdlIGluIG91dGdvaW5nIHN0b3JlXG4gKiB0aGUgb3V0Z29pbmcgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aGUgRXJyb3IoJ01lc3NhZ2UgcmVtb3ZlZCcpIGlmIHRoZSBtZXNzYWdlIGlzIHJlbW92ZWRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWlkIC0gbWVzc2FnZUlkIHRvIHJlbW92ZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZSBjbGllbnQucmVtb3ZlT3V0Z29pbmdNZXNzYWdlKGNsaWVudC5nZXRMYXN0TWVzc2FnZUlkKCkpO1xuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5yZW1vdmVPdXRnb2luZ01lc3NhZ2UgPSBmdW5jdGlvbiAobWlkKSB7XG4gIHZhciBjYiA9IHRoaXMub3V0Z29pbmdbbWlkXSA/IHRoaXMub3V0Z29pbmdbbWlkXS5jYiA6IG51bGxcbiAgZGVsZXRlIHRoaXMub3V0Z29pbmdbbWlkXVxuICB0aGlzLm91dGdvaW5nU3RvcmUuZGVsKHttZXNzYWdlSWQ6IG1pZH0sIGZ1bmN0aW9uICgpIHtcbiAgICBjYihuZXcgRXJyb3IoJ01lc3NhZ2UgcmVtb3ZlZCcpKVxuICB9KVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIHJlY29ubmVjdCAtIGNvbm5lY3QgYWdhaW4gdXNpbmcgdGhlIHNhbWUgb3B0aW9ucyBhcyBjb25uZWN0KClcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gb3B0aW9uYWwgcmVjb25uZWN0IG9wdGlvbnMsIGluY2x1ZGVzOlxuICogICAge1N0b3JlfSBpbmNvbWluZ1N0b3JlIC0gYSBzdG9yZSBmb3IgdGhlIGluY29taW5nIHBhY2tldHNcbiAqICAgIHtTdG9yZX0gb3V0Z29pbmdTdG9yZSAtIGEgc3RvcmUgZm9yIHRoZSBvdXRnb2luZyBwYWNrZXRzXG4gKiAgICBpZiBvcHRzIGlzIG5vdCBnaXZlbiwgY3VycmVudCBzdG9yZXMgYXJlIHVzZWRcbiAqIEByZXR1cm5zIHtNcXR0Q2xpZW50fSB0aGlzIC0gZm9yIGNoYWluaW5nXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHRoYXQgPSB0aGlzXG4gIHZhciBmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcHRzKSB7XG4gICAgICB0aGF0Lm9wdGlvbnMuaW5jb21pbmdTdG9yZSA9IG9wdHMuaW5jb21pbmdTdG9yZVxuICAgICAgdGhhdC5vcHRpb25zLm91dGdvaW5nU3RvcmUgPSBvcHRzLm91dGdvaW5nU3RvcmVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5vcHRpb25zLmluY29taW5nU3RvcmUgPSBudWxsXG4gICAgICB0aGF0Lm9wdGlvbnMub3V0Z29pbmdTdG9yZSA9IG51bGxcbiAgICB9XG4gICAgdGhhdC5pbmNvbWluZ1N0b3JlID0gdGhhdC5vcHRpb25zLmluY29taW5nU3RvcmUgfHwgbmV3IFN0b3JlKClcbiAgICB0aGF0Lm91dGdvaW5nU3RvcmUgPSB0aGF0Lm9wdGlvbnMub3V0Z29pbmdTdG9yZSB8fCBuZXcgU3RvcmUoKVxuICAgIHRoYXQuZGlzY29ubmVjdGluZyA9IGZhbHNlXG4gICAgdGhhdC5kaXNjb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoYXQuX2RlZmVycmVkUmVjb25uZWN0ID0gbnVsbFxuICAgIHRoYXQuX3JlY29ubmVjdCgpXG4gIH1cblxuICBpZiAodGhpcy5kaXNjb25uZWN0aW5nICYmICF0aGlzLmRpc2Nvbm5lY3RlZCkge1xuICAgIHRoaXMuX2RlZmVycmVkUmVjb25uZWN0ID0gZlxuICB9IGVsc2Uge1xuICAgIGYoKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogX3JlY29ubmVjdCAtIGltcGxlbWVudCByZWNvbm5lY3Rpb25cbiAqIEBhcGkgcHJpdmF0ZWlzaFxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fcmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ3JlY29ubmVjdCcpXG4gIHRoaXMuX3NldHVwU3RyZWFtKClcbn1cblxuLyoqXG4gKiBfc2V0dXBSZWNvbm5lY3QgLSBzZXR1cCByZWNvbm5lY3QgdGltZXJcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3NldHVwUmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IHRoaXNcblxuICBpZiAoIXRoYXQuZGlzY29ubmVjdGluZyAmJiAhdGhhdC5yZWNvbm5lY3RUaW1lciAmJiAodGhhdC5vcHRpb25zLnJlY29ubmVjdFBlcmlvZCA+IDApKSB7XG4gICAgaWYgKCF0aGlzLnJlY29ubmVjdGluZykge1xuICAgICAgdGhpcy5lbWl0KCdvZmZsaW5lJylcbiAgICAgIHRoaXMucmVjb25uZWN0aW5nID0gdHJ1ZVxuICAgIH1cbiAgICB0aGF0LnJlY29ubmVjdFRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5fcmVjb25uZWN0KClcbiAgICB9LCB0aGF0Lm9wdGlvbnMucmVjb25uZWN0UGVyaW9kKVxuICB9XG59XG5cbi8qKlxuICogX2NsZWFyUmVjb25uZWN0IC0gY2xlYXIgdGhlIHJlY29ubmVjdCB0aW1lclxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fY2xlYXJSZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnJlY29ubmVjdFRpbWVyKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlY29ubmVjdFRpbWVyKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBfY2xlYW5VcCAtIGNsZWFuIHVwIG9uIGNvbm5lY3Rpb24gZW5kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX2NsZWFuVXAgPSBmdW5jdGlvbiAoZm9yY2VkLCBkb25lKSB7XG4gIHZhciBvcHRzID0gYXJndW1lbnRzWzJdXG4gIGlmIChkb25lKSB7XG4gICAgdGhpcy5zdHJlYW0ub24oJ2Nsb3NlJywgZG9uZSlcbiAgfVxuXG4gIGlmIChmb3JjZWQpIHtcbiAgICBpZiAoKHRoaXMub3B0aW9ucy5yZWNvbm5lY3RQZXJpb2QgPT09IDApICYmIHRoaXMub3B0aW9ucy5jbGVhbikge1xuICAgICAgZmx1c2godGhpcy5vdXRnb2luZylcbiAgICB9XG4gICAgdGhpcy5zdHJlYW0uZGVzdHJveSgpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhY2tldCA9IHh0ZW5kKHsgY21kOiAnZGlzY29ubmVjdCcgfSwgb3B0cylcbiAgICB0aGlzLl9zZW5kUGFja2V0KFxuICAgICAgcGFja2V0LFxuICAgICAgc2V0SW1tZWRpYXRlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRoaXMuc3RyZWFtLmVuZC5iaW5kKHRoaXMuc3RyZWFtKVxuICAgICAgKVxuICAgIClcbiAgfVxuXG4gIGlmICghdGhpcy5kaXNjb25uZWN0aW5nKSB7XG4gICAgdGhpcy5fY2xlYXJSZWNvbm5lY3QoKVxuICAgIHRoaXMuX3NldHVwUmVjb25uZWN0KClcbiAgfVxuXG4gIGlmICh0aGlzLnBpbmdUaW1lciAhPT0gbnVsbCkge1xuICAgIHRoaXMucGluZ1RpbWVyLmNsZWFyKClcbiAgICB0aGlzLnBpbmdUaW1lciA9IG51bGxcbiAgfVxuXG4gIGlmIChkb25lICYmICF0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMuc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGRvbmUpXG4gICAgZG9uZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBfc2VuZFBhY2tldCAtIHNlbmQgb3IgcXVldWUgYSBwYWNrZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gcGFja2V0IHR5cGUgKHNlZSBgcHJvdG9jb2xgKVxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHBhY2tldCBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrIHdoZW4gdGhlIHBhY2tldCBpcyBzZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlN0b3JlUHV0IC0gY2FsbGVkIHdoZW4gbWVzc2FnZSBpcyBwdXQgaW50byBvdXRnb2luZ1N0b3JlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3NlbmRQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBjYiwgY2JTdG9yZVB1dCkge1xuICBjYlN0b3JlUHV0ID0gY2JTdG9yZVB1dCB8fCBub3BcblxuICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5fc3RvcmVQYWNrZXQocGFja2V0LCBjYiwgY2JTdG9yZVB1dClcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIFdoZW4gc2VuZGluZyBhIHBhY2tldCwgcmVzY2hlZHVsZSB0aGUgcGluZyB0aW1lclxuICB0aGlzLl9zaGlmdFBpbmdJbnRlcnZhbCgpXG5cbiAgc3dpdGNoIChwYWNrZXQuY21kKSB7XG4gICAgY2FzZSAncHVibGlzaCc6XG4gICAgICBicmVha1xuICAgIGNhc2UgJ3B1YnJlbCc6XG4gICAgICBzdG9yZUFuZFNlbmQodGhpcywgcGFja2V0LCBjYiwgY2JTdG9yZVB1dClcbiAgICAgIHJldHVyblxuICAgIGRlZmF1bHQ6XG4gICAgICBzZW5kUGFja2V0KHRoaXMsIHBhY2tldCwgY2IpXG4gICAgICByZXR1cm5cbiAgfVxuXG4gIHN3aXRjaCAocGFja2V0LnFvcykge1xuICAgIGNhc2UgMjpcbiAgICBjYXNlIDE6XG4gICAgICBzdG9yZUFuZFNlbmQodGhpcywgcGFja2V0LCBjYiwgY2JTdG9yZVB1dClcbiAgICAgIGJyZWFrXG4gICAgLyoqXG4gICAgICogbm8gbmVlZCBvZiBjYXNlIGhlcmUgc2luY2UgaXQgd2lsbCBiZSBjYXVnaHQgYnkgZGVmYXVsdFxuICAgICAqIGFuZCBqc2hpbnQgY29tcGx5IHRoYXQgYmVmb3JlIGRlZmF1bHQgaXQgbXVzdCBiZSBhIGJyZWFrXG4gICAgICogYW55d2F5IGl0IHdpbGwgcmVzdWx0IGluIC0xIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBjYXNlIDA6XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHNlbmRQYWNrZXQodGhpcywgcGFja2V0LCBjYilcbiAgICAgIGJyZWFrXG4gIH1cbn1cblxuLyoqXG4gKiBfc3RvcmVQYWNrZXQgLSBxdWV1ZSBhIHBhY2tldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBwYWNrZXQgdHlwZSAoc2VlIGBwcm90b2NvbGApXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gcGFja2V0IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2sgd2hlbiB0aGUgcGFja2V0IGlzIHNlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiU3RvcmVQdXQgLSBjYWxsZWQgd2hlbiBtZXNzYWdlIGlzIHB1dCBpbnRvIG91dGdvaW5nU3RvcmVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fc3RvcmVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBjYiwgY2JTdG9yZVB1dCkge1xuICBjYlN0b3JlUHV0ID0gY2JTdG9yZVB1dCB8fCBub3BcblxuICBpZiAoKChwYWNrZXQucW9zIHx8IDApID09PSAwICYmIHRoaXMucXVldWVRb1NaZXJvKSB8fCBwYWNrZXQuY21kICE9PSAncHVibGlzaCcpIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2goeyBwYWNrZXQ6IHBhY2tldCwgY2I6IGNiIH0pXG4gIH0gZWxzZSBpZiAocGFja2V0LnFvcyA+IDApIHtcbiAgICBjYiA9IHRoaXMub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF0gPyB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdLmNiIDogbnVsbFxuICAgIHRoaXMub3V0Z29pbmdTdG9yZS5wdXQocGFja2V0LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYiAmJiBjYihlcnIpXG4gICAgICB9XG4gICAgICBjYlN0b3JlUHV0KClcbiAgICB9KVxuICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgY2IobmV3IEVycm9yKCdObyBjb25uZWN0aW9uIHRvIGJyb2tlcicpKVxuICB9XG59XG5cbi8qKlxuICogX3NldHVwUGluZ1RpbWVyIC0gc2V0dXAgdGhlIHBpbmcgdGltZXJcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3NldHVwUGluZ1RpbWVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IHRoaXNcblxuICBpZiAoIXRoaXMucGluZ1RpbWVyICYmIHRoaXMub3B0aW9ucy5rZWVwYWxpdmUpIHtcbiAgICB0aGlzLnBpbmdSZXNwID0gdHJ1ZVxuICAgIHRoaXMucGluZ1RpbWVyID0gcmVJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0Ll9jaGVja1BpbmcoKVxuICAgIH0sIHRoaXMub3B0aW9ucy5rZWVwYWxpdmUgKiAxMDAwKVxuICB9XG59XG5cbi8qKlxuICogX3NoaWZ0UGluZ0ludGVydmFsIC0gcmVzY2hlZHVsZSB0aGUgcGluZyBpbnRlcnZhbFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fc2hpZnRQaW5nSW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBpbmdUaW1lciAmJiB0aGlzLm9wdGlvbnMua2VlcGFsaXZlICYmIHRoaXMub3B0aW9ucy5yZXNjaGVkdWxlUGluZ3MpIHtcbiAgICB0aGlzLnBpbmdUaW1lci5yZXNjaGVkdWxlKHRoaXMub3B0aW9ucy5rZWVwYWxpdmUgKiAxMDAwKVxuICB9XG59XG4vKipcbiAqIF9jaGVja1BpbmcgLSBjaGVjayBpZiBhIHBpbmdyZXNwIGhhcyBjb21lIGJhY2ssIGFuZCBwaW5nIHRoZSBzZXJ2ZXIgYWdhaW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX2NoZWNrUGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGluZ1Jlc3ApIHtcbiAgICB0aGlzLnBpbmdSZXNwID0gZmFsc2VcbiAgICB0aGlzLl9zZW5kUGFja2V0KHsgY21kOiAncGluZ3JlcScgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBkbyBhIGZvcmNlZCBjbGVhbnVwIHNpbmNlIHNvY2tldCB3aWxsIGJlIGluIGJhZCBzaGFwZVxuICAgIHRoaXMuX2NsZWFuVXAodHJ1ZSlcbiAgfVxufVxuXG4vKipcbiAqIF9oYW5kbGVQaW5ncmVzcCAtIGhhbmRsZSBhIHBpbmdyZXNwXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVQaW5ncmVzcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5waW5nUmVzcCA9IHRydWVcbn1cblxuLyoqXG4gKiBfaGFuZGxlQ29ubmFja1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVDb25uYWNrID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuICB2YXIgdmVyc2lvbiA9IG9wdGlvbnMucHJvdG9jb2xWZXJzaW9uXG4gIHZhciByYyA9IHZlcnNpb24gPT09IDUgPyBwYWNrZXQucmVhc29uQ29kZSA6IHBhY2tldC5yZXR1cm5Db2RlXG5cbiAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmFja1RpbWVyKVxuXG4gIGlmIChwYWNrZXQucHJvcGVydGllcykge1xuICAgIGlmIChwYWNrZXQucHJvcGVydGllcy50b3BpY0FsaWFzTWF4aW11bSkge1xuICAgICAgaWYgKCFvcHRpb25zLnByb3BlcnRpZXMpIHsgb3B0aW9ucy5wcm9wZXJ0aWVzID0ge30gfVxuICAgICAgb3B0aW9ucy5wcm9wZXJ0aWVzLnRvcGljQWxpYXNNYXhpbXVtID0gcGFja2V0LnByb3BlcnRpZXMudG9waWNBbGlhc01heGltdW1cbiAgICB9XG4gICAgaWYgKHBhY2tldC5wcm9wZXJ0aWVzLnNlcnZlcktlZXBBbGl2ZSAmJiBvcHRpb25zLmtlZXBhbGl2ZSkge1xuICAgICAgb3B0aW9ucy5rZWVwYWxpdmUgPSBwYWNrZXQucHJvcGVydGllcy5zZXJ2ZXJLZWVwQWxpdmVcbiAgICAgIHRoaXMuX3NoaWZ0UGluZ0ludGVydmFsKClcbiAgICB9XG4gICAgaWYgKHBhY2tldC5wcm9wZXJ0aWVzLm1heGltdW1QYWNrZXRTaXplKSB7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvcGVydGllcykgeyBvcHRpb25zLnByb3BlcnRpZXMgPSB7fSB9XG4gICAgICBvcHRpb25zLnByb3BlcnRpZXMubWF4aW11bVBhY2tldFNpemUgPSBwYWNrZXQucHJvcGVydGllcy5tYXhpbXVtUGFja2V0U2l6ZVxuICAgIH1cbiAgfVxuXG4gIGlmIChyYyA9PT0gMCkge1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2VcbiAgICB0aGlzLl9vbkNvbm5lY3QocGFja2V0KVxuICB9IGVsc2UgaWYgKHJjID4gMCkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gcmVmdXNlZDogJyArIGVycm9yc1tyY10pXG4gICAgZXJyLmNvZGUgPSByY1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cbn1cblxuLyoqXG4gKiBfaGFuZGxlUHVibGlzaFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG4vKlxudGhvc2UgbGF0ZSAyIGNhc2Ugc2hvdWxkIGJlIHJld3JpdGUgdG8gY29tcGx5IHdpdGggY29kaW5nIHN0eWxlOlxuXG5jYXNlIDE6XG5jYXNlIDA6XG4gIC8vIGRvIG5vdCB3YWl0IHNlbmRpbmcgYSBwdWJhY2tcbiAgLy8gbm8gY2FsbGJhY2sgcGFzc2VkXG4gIGlmICgxID09PSBxb3MpIHtcbiAgICB0aGlzLl9zZW5kUGFja2V0KHtcbiAgICAgIGNtZDogJ3B1YmFjaycsXG4gICAgICBtZXNzYWdlSWQ6IG1pZFxuICAgIH0pO1xuICB9XG4gIC8vIGVtaXQgdGhlIG1lc3NhZ2UgZXZlbnQgZm9yIGJvdGggcW9zIDEgYW5kIDBcbiAgdGhpcy5lbWl0KCdtZXNzYWdlJywgdG9waWMsIG1lc3NhZ2UsIHBhY2tldCk7XG4gIHRoaXMuaGFuZGxlTWVzc2FnZShwYWNrZXQsIGRvbmUpO1xuICBicmVhaztcbmRlZmF1bHQ6XG4gIC8vIGRvIG5vdGhpbmcgYnV0IGV2ZXJ5IHN3aXRjaCBtdXMgaGF2ZSBhIGRlZmF1bHRcbiAgLy8gbG9nIG9yIHRocm93IGFuIGVycm9yIGFib3V0IHVua25vd24gcW9zXG4gIGJyZWFrO1xuXG5mb3Igbm93IGkganVzdCBzdXBwcmVzc2VkIHRoZSB3YXJuaW5nc1xuKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVQdWJsaXNoID0gZnVuY3Rpb24gKHBhY2tldCwgZG9uZSkge1xuICBkb25lID0gdHlwZW9mIGRvbmUgIT09ICd1bmRlZmluZWQnID8gZG9uZSA6IG5vcFxuICB2YXIgdG9waWMgPSBwYWNrZXQudG9waWMudG9TdHJpbmcoKVxuICB2YXIgbWVzc2FnZSA9IHBhY2tldC5wYXlsb2FkXG4gIHZhciBxb3MgPSBwYWNrZXQucW9zXG4gIHZhciBtaWQgPSBwYWNrZXQubWVzc2FnZUlkXG4gIHZhciB0aGF0ID0gdGhpc1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuICB2YXIgdmFsaWRSZWFzb25Db2RlcyA9IFswLCAxNiwgMTI4LCAxMzEsIDEzNSwgMTQ0LCAxNDUsIDE1MSwgMTUzXVxuXG4gIHN3aXRjaCAocW9zKSB7XG4gICAgY2FzZSAyOiB7XG4gICAgICBvcHRpb25zLmN1c3RvbUhhbmRsZUFja3ModG9waWMsIG1lc3NhZ2UsIHBhY2tldCwgZnVuY3Rpb24gKGVycm9yLCBjb2RlKSB7XG4gICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgY29kZSA9IGVycm9yXG4gICAgICAgICAgZXJyb3IgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yKSB7IHJldHVybiB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyb3IpIH1cbiAgICAgICAgaWYgKHZhbGlkUmVhc29uQ29kZXMuaW5kZXhPZihjb2RlKSA9PT0gLTEpIHsgcmV0dXJuIHRoYXQuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1dyb25nIHJlYXNvbiBjb2RlIGZvciBwdWJyZWMnKSkgfVxuICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgIHRoYXQuX3NlbmRQYWNrZXQoe2NtZDogJ3B1YnJlYycsIG1lc3NhZ2VJZDogbWlkLCByZWFzb25Db2RlOiBjb2RlfSwgZG9uZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0LmluY29taW5nU3RvcmUucHV0KHBhY2tldCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5fc2VuZFBhY2tldCh7Y21kOiAncHVicmVjJywgbWVzc2FnZUlkOiBtaWR9LCBkb25lKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIDE6IHtcbiAgICAgIC8vIGVtaXQgdGhlIG1lc3NhZ2UgZXZlbnRcbiAgICAgIG9wdGlvbnMuY3VzdG9tSGFuZGxlQWNrcyh0b3BpYywgbWVzc2FnZSwgcGFja2V0LCBmdW5jdGlvbiAoZXJyb3IsIGNvZGUpIHtcbiAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBjb2RlID0gZXJyb3JcbiAgICAgICAgICBlcnJvciA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IpIHsgcmV0dXJuIHRoYXQuZW1pdCgnZXJyb3InLCBlcnJvcikgfVxuICAgICAgICBpZiAodmFsaWRSZWFzb25Db2Rlcy5pbmRleE9mKGNvZGUpID09PSAtMSkgeyByZXR1cm4gdGhhdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignV3JvbmcgcmVhc29uIGNvZGUgZm9yIHB1YmFjaycpKSB9XG4gICAgICAgIGlmICghY29kZSkgeyB0aGF0LmVtaXQoJ21lc3NhZ2UnLCB0b3BpYywgbWVzc2FnZSwgcGFja2V0KSB9XG4gICAgICAgIHRoYXQuaGFuZGxlTWVzc2FnZShwYWNrZXQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSAmJiBkb25lKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhhdC5fc2VuZFBhY2tldCh7Y21kOiAncHViYWNrJywgbWVzc2FnZUlkOiBtaWQsIHJlYXNvbkNvZGU6IGNvZGV9LCBkb25lKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgMDpcbiAgICAgIC8vIGVtaXQgdGhlIG1lc3NhZ2UgZXZlbnRcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHRvcGljLCBtZXNzYWdlLCBwYWNrZXQpXG4gICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UocGFja2V0LCBkb25lKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgLy8gbG9nIG9yIHRocm93IGFuIGVycm9yIGFib3V0IHVua25vd24gcW9zXG4gICAgICBicmVha1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIG1lc3NhZ2VzIHdpdGggYmFja3ByZXNzdXJlIHN1cHBvcnQsIG9uZSBhdCBhIHRpbWUuXG4gKiBPdmVycmlkZSBhdCB3aWxsLlxuICpcbiAqIEBwYXJhbSBQYWNrZXQgcGFja2V0IHRoZSBwYWNrZXRcbiAqIEBwYXJhbSBGdW5jdGlvbiBjYWxsYmFjayBjYWxsIHdoZW4gZmluaXNoZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiAocGFja2V0LCBjYWxsYmFjaykge1xuICBjYWxsYmFjaygpXG59XG5cbi8qKlxuICogX2hhbmRsZUFja1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVBY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIC8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogXCJvZmZcIiAqL1xuICB2YXIgbWlkID0gcGFja2V0Lm1lc3NhZ2VJZFxuICB2YXIgdHlwZSA9IHBhY2tldC5jbWRcbiAgdmFyIHJlc3BvbnNlID0gbnVsbFxuICB2YXIgY2IgPSB0aGlzLm91dGdvaW5nW21pZF0gPyB0aGlzLm91dGdvaW5nW21pZF0uY2IgOiBudWxsXG4gIHZhciB0aGF0ID0gdGhpc1xuICB2YXIgZXJyXG5cbiAgaWYgKCFjYikge1xuICAgIC8vIFNlcnZlciBzZW50IGFuIGFjayBpbiBlcnJvciwgaWdub3JlIGl0LlxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gUHJvY2Vzc1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdwdWJjb21wJzpcbiAgICAgIC8vIHNhbWUgdGhpbmcgYXMgcHViYWNrIGZvciBRb1MgMlxuICAgIGNhc2UgJ3B1YmFjayc6XG4gICAgICB2YXIgcHViYWNrUkMgPSBwYWNrZXQucmVhc29uQ29kZVxuICAgICAgLy8gQ2FsbGJhY2sgLSB3ZSdyZSBkb25lXG4gICAgICBpZiAocHViYWNrUkMgJiYgcHViYWNrUkMgPiAwICYmIHB1YmFja1JDICE9PSAxNikge1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoJ1B1Ymxpc2ggZXJyb3I6ICcgKyBlcnJvcnNbcHViYWNrUkNdKVxuICAgICAgICBlcnIuY29kZSA9IHB1YmFja1JDXG4gICAgICAgIGNiKGVyciwgcGFja2V0KVxuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMub3V0Z29pbmdbbWlkXVxuICAgICAgdGhpcy5vdXRnb2luZ1N0b3JlLmRlbChwYWNrZXQsIGNiKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwdWJyZWMnOlxuICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgIGNtZDogJ3B1YnJlbCcsXG4gICAgICAgIHFvczogMixcbiAgICAgICAgbWVzc2FnZUlkOiBtaWRcbiAgICAgIH1cbiAgICAgIHZhciBwdWJyZWNSQyA9IHBhY2tldC5yZWFzb25Db2RlXG5cbiAgICAgIGlmIChwdWJyZWNSQyAmJiBwdWJyZWNSQyA+IDAgJiYgcHVicmVjUkMgIT09IDE2KSB7XG4gICAgICAgIGVyciA9IG5ldyBFcnJvcignUHVibGlzaCBlcnJvcjogJyArIGVycm9yc1twdWJyZWNSQ10pXG4gICAgICAgIGVyci5jb2RlID0gcHVicmVjUkNcbiAgICAgICAgY2IoZXJyLCBwYWNrZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZW5kUGFja2V0KHJlc3BvbnNlKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdzdWJhY2snOlxuICAgICAgZGVsZXRlIHRoaXMub3V0Z29pbmdbbWlkXVxuICAgICAgZm9yICh2YXIgZ3JhbnRlZEkgPSAwOyBncmFudGVkSSA8IHBhY2tldC5ncmFudGVkLmxlbmd0aDsgZ3JhbnRlZEkrKykge1xuICAgICAgICBpZiAoKHBhY2tldC5ncmFudGVkW2dyYW50ZWRJXSAmIDB4ODApICE9PSAwKSB7XG4gICAgICAgICAgLy8gc3ViYWNrIHdpdGggRmFpbHVyZSBzdGF0dXNcbiAgICAgICAgICB2YXIgdG9waWNzID0gdGhpcy5tZXNzYWdlSWRUb1RvcGljW21pZF1cbiAgICAgICAgICBpZiAodG9waWNzKSB7XG4gICAgICAgICAgICB0b3BpY3MuZm9yRWFjaChmdW5jdGlvbiAodG9waWMpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoYXQuX3Jlc3Vic2NyaWJlVG9waWNzW3RvcGljXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNiKG51bGwsIHBhY2tldClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndW5zdWJhY2snOlxuICAgICAgZGVsZXRlIHRoaXMub3V0Z29pbmdbbWlkXVxuICAgICAgY2IobnVsbClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBwYWNrZXQgdHlwZScpKVxuICB9XG5cbiAgaWYgKHRoaXMuZGlzY29ubmVjdGluZyAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5vdXRnb2luZykubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5lbWl0KCdvdXRnb2luZ0VtcHR5JylcbiAgfVxufVxuXG4vKipcbiAqIF9oYW5kbGVQdWJyZWxcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX2hhbmRsZVB1YnJlbCA9IGZ1bmN0aW9uIChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gdHlwZW9mIGNhbGxiYWNrICE9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogbm9wXG4gIHZhciBtaWQgPSBwYWNrZXQubWVzc2FnZUlkXG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIHZhciBjb21wID0ge2NtZDogJ3B1YmNvbXAnLCBtZXNzYWdlSWQ6IG1pZH1cblxuICB0aGF0LmluY29taW5nU3RvcmUuZ2V0KHBhY2tldCwgZnVuY3Rpb24gKGVyciwgcHViKSB7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIHRoYXQuZW1pdCgnbWVzc2FnZScsIHB1Yi50b3BpYywgcHViLnBheWxvYWQsIHB1YilcbiAgICAgIHRoYXQuaGFuZGxlTWVzc2FnZShwdWIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5pbmNvbWluZ1N0b3JlLmRlbChwdWIsIG5vcClcbiAgICAgICAgdGhhdC5fc2VuZFBhY2tldChjb21wLCBjYWxsYmFjaylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX3NlbmRQYWNrZXQoY29tcCwgY2FsbGJhY2spXG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIF9oYW5kbGVEaXNjb25uZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVEaXNjb25uZWN0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBwYWNrZXQpXG59XG5cbi8qKlxuICogX25leHRJZFxuICogQHJldHVybiB1bnNpZ25lZCBpbnRcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX25leHRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gaWQgYmVjb21lcyBjdXJyZW50IHN0YXRlIG9mIHRoaXMubmV4dElkIGFuZCBpbmNyZW1lbnRzIGFmdGVyd2FyZHNcbiAgdmFyIGlkID0gdGhpcy5uZXh0SWQrK1xuICAvLyBFbnN1cmUgMTYgYml0IHVuc2lnbmVkIGludCAobWF4IDY1NTM1LCBuZXh0SWQgZ290IG9uZSBoaWdoZXIpXG4gIGlmICh0aGlzLm5leHRJZCA9PT0gNjU1MzYpIHtcbiAgICB0aGlzLm5leHRJZCA9IDFcbiAgfVxuICByZXR1cm4gaWRcbn1cblxuLyoqXG4gKiBnZXRMYXN0TWVzc2FnZUlkXG4gKiBAcmV0dXJuIHVuc2lnbmVkIGludFxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5nZXRMYXN0TWVzc2FnZUlkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMubmV4dElkID09PSAxKSA/IDY1NTM1IDogKHRoaXMubmV4dElkIC0gMSlcbn1cblxuLyoqXG4gKiBfcmVzdWJzY3JpYmVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fcmVzdWJzY3JpYmUgPSBmdW5jdGlvbiAoY29ubmFjaykge1xuICB2YXIgX3Jlc3Vic2NyaWJlVG9waWNzS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzKVxuICBpZiAoIXRoaXMuX2ZpcnN0Q29ubmVjdGlvbiAmJlxuICAgICAgKHRoaXMub3B0aW9ucy5jbGVhbiB8fCAodGhpcy5vcHRpb25zLnByb3RvY29sVmVyc2lvbiA9PT0gNSAmJiAhY29ubmFjay5zZXNzaW9uUHJlc2VudCkpICYmXG4gICAgICBfcmVzdWJzY3JpYmVUb3BpY3NLZXlzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3Vic2NyaWJlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgICAgICBmb3IgKHZhciB0b3BpY0kgPSAwOyB0b3BpY0kgPCBfcmVzdWJzY3JpYmVUb3BpY3NLZXlzLmxlbmd0aDsgdG9waWNJKyspIHtcbiAgICAgICAgICB2YXIgcmVzdWJzY3JpYmVUb3BpYyA9IHt9XG4gICAgICAgICAgcmVzdWJzY3JpYmVUb3BpY1tfcmVzdWJzY3JpYmVUb3BpY3NLZXlzW3RvcGljSV1dID0gdGhpcy5fcmVzdWJzY3JpYmVUb3BpY3NbX3Jlc3Vic2NyaWJlVG9waWNzS2V5c1t0b3BpY0ldXVxuICAgICAgICAgIHJlc3Vic2NyaWJlVG9waWMucmVzdWJzY3JpYmUgPSB0cnVlXG4gICAgICAgICAgdGhpcy5zdWJzY3JpYmUocmVzdWJzY3JpYmVUb3BpYywge3Byb3BlcnRpZXM6IHJlc3Vic2NyaWJlVG9waWNbX3Jlc3Vic2NyaWJlVG9waWNzS2V5c1t0b3BpY0ldXS5wcm9wZXJ0aWVzfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzdWJzY3JpYmVUb3BpY3MucmVzdWJzY3JpYmUgPSB0cnVlXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXN1YnNjcmliZVRvcGljcyA9IHt9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fZmlyc3RDb25uZWN0aW9uID0gZmFsc2Vcbn1cblxuLyoqXG4gKiBfb25Db25uZWN0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9vbkNvbm5lY3QgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkge1xuICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIHBhY2tldClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIHRoaXMuX3NldHVwUGluZ1RpbWVyKClcbiAgdGhpcy5fcmVzdWJzY3JpYmUocGFja2V0KVxuXG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZVxuXG4gIGZ1bmN0aW9uIHN0YXJ0U3RyZWFtUHJvY2VzcyAoKSB7XG4gICAgdmFyIG91dFN0b3JlID0gdGhhdC5vdXRnb2luZ1N0b3JlLmNyZWF0ZVN0cmVhbSgpXG5cbiAgICBmdW5jdGlvbiBjbGVhclN0b3JlUHJvY2Vzc2luZyAoKSB7XG4gICAgICB0aGF0Ll9zdG9yZVByb2Nlc3NpbmcgPSBmYWxzZVxuICAgICAgdGhhdC5fcGFja2V0SWRzRHVyaW5nU3RvcmVQcm9jZXNzaW5nID0ge31cbiAgICB9XG5cbiAgICB0aGF0Lm9uY2UoJ2Nsb3NlJywgcmVtb3ZlKVxuICAgIG91dFN0b3JlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGNsZWFyU3RvcmVQcm9jZXNzaW5nKClcbiAgICAgIHRoYXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgcmVtb3ZlKVxuICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICAgIG91dFN0b3JlLmRlc3Ryb3koKVxuICAgICAgb3V0U3RvcmUgPSBudWxsXG4gICAgICBjbGVhclN0b3JlUHJvY2Vzc2luZygpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RvcmVEZWxpdmVyICgpIHtcbiAgICAgIC8vIGVkZ2UgY2FzZSwgd2Ugd3JhcHBlZCB0aGlzIHR3aWNlXG4gICAgICBpZiAoIW91dFN0b3JlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhhdC5fc3RvcmVQcm9jZXNzaW5nID0gdHJ1ZVxuXG4gICAgICB2YXIgcGFja2V0ID0gb3V0U3RvcmUucmVhZCgxKVxuXG4gICAgICB2YXIgY2JcblxuICAgICAgaWYgKCFwYWNrZXQpIHtcbiAgICAgICAgLy8gcmVhZCB3aGVuIGRhdGEgaXMgYXZhaWxhYmxlIGluIHRoZSBmdXR1cmVcbiAgICAgICAgb3V0U3RvcmUub25jZSgncmVhZGFibGUnLCBzdG9yZURlbGl2ZXIpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGFscmVhZHkgcHJvY2Vzc2VkIHN0b3JlIHBhY2tldHNcbiAgICAgIGlmICh0aGF0Ll9wYWNrZXRJZHNEdXJpbmdTdG9yZVByb2Nlc3NpbmdbcGFja2V0Lm1lc3NhZ2VJZF0pIHtcbiAgICAgICAgc3RvcmVEZWxpdmVyKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IHN0cmVhbSByZWFkIG9wZXJhdGlvbnMgd2hlbiBkaXNjb25uZWN0ZWRcbiAgICAgIGlmICghdGhhdC5kaXNjb25uZWN0aW5nICYmICF0aGF0LnJlY29ubmVjdFRpbWVyKSB7XG4gICAgICAgIGNiID0gdGhhdC5vdXRnb2luZ1twYWNrZXQubWVzc2FnZUlkXSA/IHRoYXQub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF0uY2IgOiBudWxsXG4gICAgICAgIHRoYXQub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF0gPSB7XG4gICAgICAgICAgdm9sYXRpbGU6IGZhbHNlLFxuICAgICAgICAgIGNiOiBmdW5jdGlvbiAoZXJyLCBzdGF0dXMpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBvcmlnaW5hbCBjYWxsYmFjayBwYXNzZWQgaW4gdG8gcHVibGlzaCBnZXRzIGludm9rZWRcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICBjYihlcnIsIHN0YXR1cylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RvcmVEZWxpdmVyKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fcGFja2V0SWRzRHVyaW5nU3RvcmVQcm9jZXNzaW5nW3BhY2tldC5tZXNzYWdlSWRdID0gdHJ1ZVxuICAgICAgICB0aGF0Ll9zZW5kUGFja2V0KHBhY2tldClcbiAgICAgIH0gZWxzZSBpZiAob3V0U3RvcmUuZGVzdHJveSkge1xuICAgICAgICBvdXRTdG9yZS5kZXN0cm95KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRTdG9yZS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFsbFByb2Nlc3NlZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGlkIGluIHRoYXQuX3BhY2tldElkc0R1cmluZ1N0b3JlUHJvY2Vzc2luZykge1xuICAgICAgICBpZiAoIXRoYXQuX3BhY2tldElkc0R1cmluZ1N0b3JlUHJvY2Vzc2luZ1tpZF0pIHtcbiAgICAgICAgICBhbGxQcm9jZXNzZWQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbGxQcm9jZXNzZWQpIHtcbiAgICAgICAgY2xlYXJTdG9yZVByb2Nlc3NpbmcoKVxuICAgICAgICB0aGF0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHJlbW92ZSlcbiAgICAgICAgdGhhdC5lbWl0KCdjb25uZWN0JywgcGFja2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRTdHJlYW1Qcm9jZXNzKClcbiAgICAgIH1cbiAgICB9KVxuICAgIHN0b3JlRGVsaXZlcigpXG4gIH1cbiAgLy8gc3RhcnQgZmxvd2luZ1xuICBzdGFydFN0cmVhbVByb2Nlc3MoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1xdHRDbGllbnRcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9zdG9yZVwiOjcsXCIuL3ZhbGlkYXRpb25zXCI6OCxcIl9wcm9jZXNzXCI6OTIsXCJldmVudHNcIjoxMyxcImluaGVyaXRzXCI6ODAsXCJtcXR0LXBhY2tldFwiOjg0LFwicmVhZGFibGUtc3RyZWFtXCI6MTA4LFwicmVpbnRlcnZhbFwiOjEwOSxcInh0ZW5kXCI6MTIxfV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKEJ1ZmZlcil7XG4ndXNlIHN0cmljdCdcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlRyYW5zZm9ybVxudmFyIGR1cGxleGlmeSA9IHJlcXVpcmUoJ2R1cGxleGlmeScpXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcblxuLyogZ2xvYmFsIEZpbGVSZWFkZXIgKi9cbnZhciBteVxudmFyIHByb3h5XG52YXIgc3RyZWFtXG52YXIgaXNJbml0aWFsaXplZCA9IGZhbHNlXG5cbmZ1bmN0aW9uIGJ1aWxkUHJveHkgKCkge1xuICB2YXIgcHJveHkgPSBuZXcgVHJhbnNmb3JtKClcbiAgcHJveHkuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgbmV4dCkge1xuICAgIG15LnNlbmRTb2NrZXRNZXNzYWdlKHtcbiAgICAgIGRhdGE6IGNodW5rLmJ1ZmZlcixcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dCgpXG4gICAgICB9LFxuICAgICAgZmFpbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0KG5ldyBFcnJvcigpKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgcHJveHkuX2ZsdXNoID0gZnVuY3Rpb24gc29ja2V0RW5kIChkb25lKSB7XG4gICAgbXkuY2xvc2VTb2NrZXQoe1xuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHByb3h5XG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRPcHRzIChvcHRzKSB7XG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSAnbG9jYWxob3N0J1xuICB9XG4gIGlmICghb3B0cy5wYXRoKSB7XG4gICAgb3B0cy5wYXRoID0gJy8nXG4gIH1cblxuICBpZiAoIW9wdHMud3NPcHRpb25zKSB7XG4gICAgb3B0cy53c09wdGlvbnMgPSB7fVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVXJsIChvcHRzLCBjbGllbnQpIHtcbiAgdmFyIHByb3RvY29sID0gb3B0cy5wcm90b2NvbCA9PT0gJ2FsaXMnID8gJ3dzcycgOiAnd3MnXG4gIHZhciB1cmwgPSBwcm90b2NvbCArICc6Ly8nICsgb3B0cy5ob3N0bmFtZSArIG9wdHMucGF0aFxuICBpZiAob3B0cy5wb3J0ICYmIG9wdHMucG9ydCAhPT0gODAgJiYgb3B0cy5wb3J0ICE9PSA0NDMpIHtcbiAgICB1cmwgPSBwcm90b2NvbCArICc6Ly8nICsgb3B0cy5ob3N0bmFtZSArICc6JyArIG9wdHMucG9ydCArIG9wdHMucGF0aFxuICB9XG4gIGlmICh0eXBlb2YgKG9wdHMudHJhbnNmb3JtV3NVcmwpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXJsID0gb3B0cy50cmFuc2Zvcm1Xc1VybCh1cmwsIG9wdHMsIGNsaWVudClcbiAgfVxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIGJpbmRFdmVudEhhbmRsZXIgKCkge1xuICBpZiAoaXNJbml0aWFsaXplZCkgcmV0dXJuXG5cbiAgaXNJbml0aWFsaXplZCA9IHRydWVcblxuICBteS5vblNvY2tldE9wZW4oZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5zZXRSZWFkYWJsZShwcm94eSlcbiAgICBzdHJlYW0uc2V0V3JpdGFibGUocHJveHkpXG4gICAgc3RyZWFtLmVtaXQoJ2Nvbm5lY3QnKVxuICB9KVxuXG4gIG15Lm9uU29ja2V0TWVzc2FnZShmdW5jdGlvbiAocmVzKSB7XG4gICAgaWYgKHR5cGVvZiByZXMuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBhcnJheSA9IGJhc2U2NC50b0J5dGVBcnJheShyZXMuZGF0YSlcbiAgICAgIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbShhcnJheSlcbiAgICAgIHByb3h5LnB1c2goYnVmZmVyKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gcmVhZGVyLnJlc3VsdFxuXG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKVxuICAgICAgICBlbHNlIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCAndXRmOCcpXG4gICAgICAgIHByb3h5LnB1c2goZGF0YSlcbiAgICAgIH0pXG4gICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIocmVzLmRhdGEpXG4gICAgfVxuICB9KVxuXG4gIG15Lm9uU29ja2V0Q2xvc2UoZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5lbmQoKVxuICAgIHN0cmVhbS5kZXN0cm95KClcbiAgfSlcblxuICBteS5vblNvY2tldEVycm9yKGZ1bmN0aW9uIChyZXMpIHtcbiAgICBzdHJlYW0uZGVzdHJveShyZXMpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGJ1aWxkU3RyZWFtIChjbGllbnQsIG9wdHMpIHtcbiAgb3B0cy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0XG5cbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIGhvc3QuIFNwZWNpZnkgaG9zdCBtYW51YWxseS4nKVxuICB9XG5cbiAgdmFyIHdlYnNvY2tldFN1YlByb3RvY29sID1cbiAgICAob3B0cy5wcm90b2NvbElkID09PSAnTVFJc2RwJykgJiYgKG9wdHMucHJvdG9jb2xWZXJzaW9uID09PSAzKVxuICAgICAgPyAnbXF0dHYzLjEnXG4gICAgICA6ICdtcXR0J1xuXG4gIHNldERlZmF1bHRPcHRzKG9wdHMpXG5cbiAgdmFyIHVybCA9IGJ1aWxkVXJsKG9wdHMsIGNsaWVudClcbiAgbXkgPSBvcHRzLm15XG4gIG15LmNvbm5lY3RTb2NrZXQoe1xuICAgIHVybDogdXJsLFxuICAgIHByb3RvY29sczogd2Vic29ja2V0U3ViUHJvdG9jb2xcbiAgfSlcblxuICBwcm94eSA9IGJ1aWxkUHJveHkoKVxuICBzdHJlYW0gPSBkdXBsZXhpZnkub2JqKClcblxuICBiaW5kRXZlbnRIYW5kbGVyKClcblxuICByZXR1cm4gc3RyZWFtXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRTdHJlYW1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxufSx7XCJiYXNlNjQtanNcIjoxMCxcImJ1ZmZlclwiOjEyLFwiZHVwbGV4aWZ5XCI6MTcsXCJyZWFkYWJsZS1zdHJlYW1cIjoxMDh9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0J1xudmFyIG5ldCA9IHJlcXVpcmUoJ25ldCcpXG5cbi8qXG4gIHZhcmlhYmxlcyBwb3J0IGFuZCBob3N0IGNhbiBiZSByZW1vdmVkIHNpbmNlXG4gIHlvdSBoYXZlIGFsbCByZXF1aXJlZCBpbmZvcm1hdGlvbiBpbiBvcHRzIG9iamVjdFxuKi9cbmZ1bmN0aW9uIGJ1aWxkQnVpbGRlciAoY2xpZW50LCBvcHRzKSB7XG4gIHZhciBwb3J0LCBob3N0XG4gIG9wdHMucG9ydCA9IG9wdHMucG9ydCB8fCAxODgzXG4gIG9wdHMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8IG9wdHMuaG9zdCB8fCAnbG9jYWxob3N0J1xuXG4gIHBvcnQgPSBvcHRzLnBvcnRcbiAgaG9zdCA9IG9wdHMuaG9zdG5hbWVcblxuICByZXR1cm4gbmV0LmNyZWF0ZUNvbm5lY3Rpb24ocG9ydCwgaG9zdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWlsZEJ1aWxkZXJcblxufSx7XCJuZXRcIjoxMX1dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG52YXIgdGxzID0gcmVxdWlyZSgndGxzJylcblxuZnVuY3Rpb24gYnVpbGRCdWlsZGVyIChtcXR0Q2xpZW50LCBvcHRzKSB7XG4gIHZhciBjb25uZWN0aW9uXG4gIG9wdHMucG9ydCA9IG9wdHMucG9ydCB8fCA4ODgzXG4gIG9wdHMuaG9zdCA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0IHx8ICdsb2NhbGhvc3QnXG5cbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCAhPT0gZmFsc2VcblxuICBkZWxldGUgb3B0cy5wYXRoXG5cbiAgY29ubmVjdGlvbiA9IHRscy5jb25uZWN0KG9wdHMpXG4gIC8qIGVzbGludCBuby11c2UtYmVmb3JlLWRlZmluZTogWzIsIFwibm9mdW5jXCJdICovXG4gIGNvbm5lY3Rpb24ub24oJ3NlY3VyZUNvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9wdHMucmVqZWN0VW5hdXRob3JpemVkICYmICFjb25uZWN0aW9uLmF1dGhvcml6ZWQpIHtcbiAgICAgIGNvbm5lY3Rpb24uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1RMUyBub3QgYXV0aG9yaXplZCcpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVRMU2Vycm9ycylcbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gaGFuZGxlVExTZXJyb3JzIChlcnIpIHtcbiAgICAvLyBIb3cgY2FuIEkgZ2V0IHZlcmlmeSB0aGlzIGVycm9yIGlzIGEgdGxzIGVycm9yP1xuICAgIGlmIChvcHRzLnJlamVjdFVuYXV0aG9yaXplZCkge1xuICAgICAgbXF0dENsaWVudC5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9XG5cbiAgICAvLyBjbG9zZSB0aGlzIGNvbm5lY3Rpb24gdG8gbWF0Y2ggdGhlIGJlaGF2aW91ciBvZiBuZXRcbiAgICAvLyBvdGhlcndpc2UgYWxsIHdlIGdldCBpcyBhbiBlcnJvciBmcm9tIHRoZSBjb25uZWN0aW9uXG4gICAgLy8gYW5kIGNsb3NlIGV2ZW50IGRvZXNuJ3QgZmlyZS4gVGhpcyBpcyBhIHdvcmsgYXJvdW5kXG4gICAgLy8gdG8gZW5hYmxlIHRoZSByZWNvbm5lY3QgY29kZSB0byB3b3JrIHRoZSBzYW1lIGFzIHdpdGhcbiAgICAvLyBuZXQuY3JlYXRlQ29ubmVjdGlvblxuICAgIGNvbm5lY3Rpb24uZW5kKClcbiAgfVxuXG4gIGNvbm5lY3Rpb24ub24oJ2Vycm9yJywgaGFuZGxlVExTZXJyb3JzKVxuICByZXR1cm4gY29ubmVjdGlvblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQnVpbGRlclxuXG59LHtcInRsc1wiOjExfV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCd3ZWJzb2NrZXQtc3RyZWFtJylcbnZhciB1cmxNb2R1bGUgPSByZXF1aXJlKCd1cmwnKVxudmFyIFdTU19PUFRJT05TID0gW1xuICAncmVqZWN0VW5hdXRob3JpemVkJyxcbiAgJ2NhJyxcbiAgJ2NlcnQnLFxuICAna2V5JyxcbiAgJ3BmeCcsXG4gICdwYXNzcGhyYXNlJ1xuXVxudmFyIElTX0JST1dTRVIgPSBwcm9jZXNzLnRpdGxlID09PSAnYnJvd3NlcidcblxuZnVuY3Rpb24gYnVpbGRVcmwgKG9wdHMsIGNsaWVudCkge1xuICB2YXIgdXJsID0gb3B0cy5wcm90b2NvbCArICc6Ly8nICsgb3B0cy5ob3N0bmFtZSArICc6JyArIG9wdHMucG9ydCArIG9wdHMucGF0aFxuICBpZiAodHlwZW9mIChvcHRzLnRyYW5zZm9ybVdzVXJsKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVybCA9IG9wdHMudHJhbnNmb3JtV3NVcmwodXJsLCBvcHRzLCBjbGllbnQpXG4gIH1cbiAgcmV0dXJuIHVybFxufVxuXG5mdW5jdGlvbiBzZXREZWZhdWx0T3B0cyAob3B0cykge1xuICBpZiAoIW9wdHMuaG9zdG5hbWUpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gJ2xvY2FsaG9zdCdcbiAgfVxuICBpZiAoIW9wdHMucG9ydCkge1xuICAgIGlmIChvcHRzLnByb3RvY29sID09PSAnd3NzJykge1xuICAgICAgb3B0cy5wb3J0ID0gNDQzXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMucG9ydCA9IDgwXG4gICAgfVxuICB9XG4gIGlmICghb3B0cy5wYXRoKSB7XG4gICAgb3B0cy5wYXRoID0gJy8nXG4gIH1cblxuICBpZiAoIW9wdHMud3NPcHRpb25zKSB7XG4gICAgb3B0cy53c09wdGlvbnMgPSB7fVxuICB9XG4gIGlmICghSVNfQlJPV1NFUiAmJiBvcHRzLnByb3RvY29sID09PSAnd3NzJykge1xuICAgIC8vIEFkZCBjZXJ0L2tleS9jYSBldGMgb3B0aW9uc1xuICAgIFdTU19PUFRJT05TLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KHByb3ApICYmICFvcHRzLndzT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBvcHRzLndzT3B0aW9uc1twcm9wXSA9IG9wdHNbcHJvcF1cbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldCAoY2xpZW50LCBvcHRzKSB7XG4gIHZhciB3ZWJzb2NrZXRTdWJQcm90b2NvbCA9XG4gICAgKG9wdHMucHJvdG9jb2xJZCA9PT0gJ01RSXNkcCcpICYmIChvcHRzLnByb3RvY29sVmVyc2lvbiA9PT0gMylcbiAgICAgID8gJ21xdHR2My4xJ1xuICAgICAgOiAnbXF0dCdcblxuICBzZXREZWZhdWx0T3B0cyhvcHRzKVxuICB2YXIgdXJsID0gYnVpbGRVcmwob3B0cywgY2xpZW50KVxuICByZXR1cm4gd2Vic29ja2V0KHVybCwgW3dlYnNvY2tldFN1YlByb3RvY29sXSwgb3B0cy53c09wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGJ1aWxkQnVpbGRlciAoY2xpZW50LCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVXZWJTb2NrZXQoY2xpZW50LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBidWlsZEJ1aWxkZXJCcm93c2VyIChjbGllbnQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IG9wdHMuaG9zdFxuICB9XG5cbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XG4gICAgLy8gVGhyb3dpbmcgYW4gZXJyb3IgaW4gYSBXZWIgV29ya2VyIGlmIG5vIGBob3N0bmFtZWAgaXMgZ2l2ZW4sIGJlY2F1c2Ugd2VcbiAgICAvLyBjYW4gbm90IGRldGVybWluZSB0aGUgYGhvc3RuYW1lYCBhdXRvbWF0aWNhbGx5LiAgSWYgY29ubmVjdGluZyB0b1xuICAgIC8vIGxvY2FsaG9zdCwgcGxlYXNlIHN1cHBseSB0aGUgYGhvc3RuYW1lYCBhcyBhbiBhcmd1bWVudC5cbiAgICBpZiAodHlwZW9mIChkb2N1bWVudCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgaG9zdC4gU3BlY2lmeSBob3N0IG1hbnVhbGx5LicpXG4gICAgfVxuICAgIHZhciBwYXJzZWQgPSB1cmxNb2R1bGUucGFyc2UoZG9jdW1lbnQuVVJMKVxuICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZWQuaG9zdG5hbWVcblxuICAgIGlmICghb3B0cy5wb3J0KSB7XG4gICAgICBvcHRzLnBvcnQgPSBwYXJzZWQucG9ydFxuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlV2ViU29ja2V0KGNsaWVudCwgb3B0cylcbn1cblxuaWYgKElTX0JST1dTRVIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWlsZEJ1aWxkZXJCcm93c2VyXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQnVpbGRlclxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiX3Byb2Nlc3NcIjo5MixcInVybFwiOjExMyxcIndlYnNvY2tldC1zdHJlYW1cIjoxMTh9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBkdXBsZXhpZnkgPSByZXF1aXJlKCdkdXBsZXhpZnknKVxuXG4vKiBnbG9iYWwgd3ggKi9cbnZhciBzb2NrZXRUYXNrXG52YXIgcHJveHlcbnZhciBzdHJlYW1cblxuZnVuY3Rpb24gYnVpbGRQcm94eSAoKSB7XG4gIHZhciBwcm94eSA9IG5ldyBUcmFuc2Zvcm0oKVxuICBwcm94eS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBuZXh0KSB7XG4gICAgc29ja2V0VGFzay5zZW5kKHtcbiAgICAgIGRhdGE6IGNodW5rLmJ1ZmZlcixcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dCgpXG4gICAgICB9LFxuICAgICAgZmFpbDogZnVuY3Rpb24gKGVyck1zZykge1xuICAgICAgICBuZXh0KG5ldyBFcnJvcihlcnJNc2cpKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgcHJveHkuX2ZsdXNoID0gZnVuY3Rpb24gc29ja2V0RW5kIChkb25lKSB7XG4gICAgc29ja2V0VGFzay5jbG9zZSh7XG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmUoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gcHJveHlcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdE9wdHMgKG9wdHMpIHtcbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9ICdsb2NhbGhvc3QnXG4gIH1cbiAgaWYgKCFvcHRzLnBhdGgpIHtcbiAgICBvcHRzLnBhdGggPSAnLydcbiAgfVxuXG4gIGlmICghb3B0cy53c09wdGlvbnMpIHtcbiAgICBvcHRzLndzT3B0aW9ucyA9IHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRVcmwgKG9wdHMsIGNsaWVudCkge1xuICB2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sID09PSAnd3hzJyA/ICd3c3MnIDogJ3dzJ1xuICB2YXIgdXJsID0gcHJvdG9jb2wgKyAnOi8vJyArIG9wdHMuaG9zdG5hbWUgKyBvcHRzLnBhdGhcbiAgaWYgKG9wdHMucG9ydCAmJiBvcHRzLnBvcnQgIT09IDgwICYmIG9wdHMucG9ydCAhPT0gNDQzKSB7XG4gICAgdXJsID0gcHJvdG9jb2wgKyAnOi8vJyArIG9wdHMuaG9zdG5hbWUgKyAnOicgKyBvcHRzLnBvcnQgKyBvcHRzLnBhdGhcbiAgfVxuICBpZiAodHlwZW9mIChvcHRzLnRyYW5zZm9ybVdzVXJsKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVybCA9IG9wdHMudHJhbnNmb3JtV3NVcmwodXJsLCBvcHRzLCBjbGllbnQpXG4gIH1cbiAgcmV0dXJuIHVybFxufVxuXG5mdW5jdGlvbiBiaW5kRXZlbnRIYW5kbGVyICgpIHtcbiAgc29ja2V0VGFzay5vbk9wZW4oZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5zZXRSZWFkYWJsZShwcm94eSlcbiAgICBzdHJlYW0uc2V0V3JpdGFibGUocHJveHkpXG4gICAgc3RyZWFtLmVtaXQoJ2Nvbm5lY3QnKVxuICB9KVxuXG4gIHNvY2tldFRhc2sub25NZXNzYWdlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICB2YXIgZGF0YSA9IHJlcy5kYXRhXG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSlcbiAgICBlbHNlIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCAndXRmOCcpXG4gICAgcHJveHkucHVzaChkYXRhKVxuICB9KVxuXG4gIHNvY2tldFRhc2sub25DbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLmVuZCgpXG4gICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9KVxuXG4gIHNvY2tldFRhc2sub25FcnJvcihmdW5jdGlvbiAocmVzKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKHJlcy5lcnJNc2cpKVxuICB9KVxufVxuXG5mdW5jdGlvbiBidWlsZFN0cmVhbSAoY2xpZW50LCBvcHRzKSB7XG4gIG9wdHMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8IG9wdHMuaG9zdFxuXG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBob3N0LiBTcGVjaWZ5IGhvc3QgbWFudWFsbHkuJylcbiAgfVxuXG4gIHZhciB3ZWJzb2NrZXRTdWJQcm90b2NvbCA9XG4gICAgKG9wdHMucHJvdG9jb2xJZCA9PT0gJ01RSXNkcCcpICYmIChvcHRzLnByb3RvY29sVmVyc2lvbiA9PT0gMylcbiAgICAgID8gJ21xdHR2My4xJ1xuICAgICAgOiAnbXF0dCdcblxuICBzZXREZWZhdWx0T3B0cyhvcHRzKVxuXG4gIHZhciB1cmwgPSBidWlsZFVybChvcHRzLCBjbGllbnQpXG4gIHNvY2tldFRhc2sgPSB3eC5jb25uZWN0U29ja2V0KHtcbiAgICB1cmw6IHVybCxcbiAgICBwcm90b2NvbHM6IHdlYnNvY2tldFN1YlByb3RvY29sXG4gIH0pXG5cbiAgcHJveHkgPSBidWlsZFByb3h5KClcbiAgc3RyZWFtID0gZHVwbGV4aWZ5Lm9iaigpXG4gIHN0cmVhbS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gICAgc29ja2V0VGFzay5jbG9zZSh7XG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNiICYmIGNiKGVycilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdmFyIGRlc3Ryb3lSZWYgPSBzdHJlYW0uZGVzdHJveVxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0uZGVzdHJveSA9IGRlc3Ryb3lSZWZcblxuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgc29ja2V0VGFzay5jbG9zZSh7XG4gICAgICAgIGZhaWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLl9kZXN0cm95KG5ldyBFcnJvcigpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0uYmluZChzdHJlYW0pXG5cbiAgYmluZEV2ZW50SGFuZGxlcigpXG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkU3RyZWFtXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxufSx7XCJfcHJvY2Vzc1wiOjkyLFwiYnVmZmVyXCI6MTIsXCJkdXBsZXhpZnlcIjoxNyxcInJlYWRhYmxlLXN0cmVhbVwiOjEwOH1dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5SZWFkYWJsZVxudmFyIHN0cmVhbXNPcHRzID0geyBvYmplY3RNb2RlOiB0cnVlIH1cbnZhciBkZWZhdWx0U3RvcmVPcHRpb25zID0ge1xuICBjbGVhbjogdHJ1ZVxufVxuXG4vKipcbiAqIGVzNi1tYXAgY2FuIHByZXNlcnZlIGluc2VydGlvbiBvcmRlciBldmVuIGlmIEVTIHZlcnNpb24gaXMgb2xkZXIuXG4gKlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwI0Rlc2NyaXB0aW9uXG4gKiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCBhIE1hcCB3aGljaCBpcyBhIG1hcCBvZiBhbiBvYmplY3QsIGVzcGVjaWFsbHlcbiAqIGEgZGljdGlvbmFyeSBvZiBkaWN0aW9uYXJpZXMsIHdpbGwgb25seSBtYXAgdG8gdGhlIG9iamVjdCdzIGluc2VydGlvblxuICogb3JkZXIuIEluIEVTMjAxNSB0aGlzIGlzIG9yZGVyZWQgZm9yIG9iamVjdHMgYnV0IGZvciBvbGRlciB2ZXJzaW9ucyBvZlxuICogRVMsIHRoaXMgbWF5IGJlIHJhbmRvbSBhbmQgbm90IG9yZGVyZWQuXG4gKlxuICovXG52YXIgTWFwID0gcmVxdWlyZSgnZXM2LW1hcCcpXG5cbi8qKlxuICogSW4tbWVtb3J5IGltcGxlbWVudGF0aW9uIG9mIHRoZSBtZXNzYWdlIHN0b3JlXG4gKiBUaGlzIGNhbiBhY3R1YWxseSBiZSBzYXZlZCBpbnRvIGZpbGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBzdG9yZSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFN0b3JlIChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdG9yZSkpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JlKG9wdGlvbnMpXG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgLy8gRGVmYXVsdHNcbiAgdGhpcy5vcHRpb25zID0geHRlbmQoZGVmYXVsdFN0b3JlT3B0aW9ucywgb3B0aW9ucylcblxuICB0aGlzLl9pbmZsaWdodHMgPSBuZXcgTWFwKClcbn1cblxuLyoqXG4gKiBBZGRzIGEgcGFja2V0IHRvIHRoZSBzdG9yZSwgYSBwYWNrZXQgaXNcbiAqIGFueXRoaW5nIHRoYXQgaGFzIGEgbWVzc2FnZUlkIHByb3BlcnR5LlxuICpcbiAqL1xuU3RvcmUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChwYWNrZXQsIGNiKSB7XG4gIHRoaXMuX2luZmxpZ2h0cy5zZXQocGFja2V0Lm1lc3NhZ2VJZCwgcGFja2V0KVxuXG4gIGlmIChjYikge1xuICAgIGNiKClcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmVhbSB3aXRoIGFsbCB0aGUgcGFja2V0cyBpbiB0aGUgc3RvcmVcbiAqXG4gKi9cblN0b3JlLnByb3RvdHlwZS5jcmVhdGVTdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHJlYW0gPSBuZXcgUmVhZGFibGUoc3RyZWFtc09wdHMpXG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZVxuICB2YXIgdmFsdWVzID0gW11cbiAgdmFyIGkgPSAwXG5cbiAgdGhpcy5faW5mbGlnaHRzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICB2YWx1ZXMucHVzaCh2YWx1ZSlcbiAgfSlcblxuICBzdHJlYW0uX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFkZXN0cm95ZWQgJiYgaSA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucHVzaCh2YWx1ZXNbaSsrXSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKG51bGwpXG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgICBkZXN0cm95ZWQgPSB0cnVlXG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gc3RyZWFtXG59XG5cbi8qKlxuICogZGVsZXRlcyBhIHBhY2tldCBmcm9tIHRoZSBzdG9yZS5cbiAqL1xuU3RvcmUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChwYWNrZXQsIGNiKSB7XG4gIHBhY2tldCA9IHRoaXMuX2luZmxpZ2h0cy5nZXQocGFja2V0Lm1lc3NhZ2VJZClcbiAgaWYgKHBhY2tldCkge1xuICAgIHRoaXMuX2luZmxpZ2h0cy5kZWxldGUocGFja2V0Lm1lc3NhZ2VJZClcbiAgICBjYihudWxsLCBwYWNrZXQpXG4gIH0gZWxzZSBpZiAoY2IpIHtcbiAgICBjYihuZXcgRXJyb3IoJ21pc3NpbmcgcGFja2V0JykpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIGdldCBhIHBhY2tldCBmcm9tIHRoZSBzdG9yZS5cbiAqL1xuU3RvcmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwYWNrZXQsIGNiKSB7XG4gIHBhY2tldCA9IHRoaXMuX2luZmxpZ2h0cy5nZXQocGFja2V0Lm1lc3NhZ2VJZClcbiAgaWYgKHBhY2tldCkge1xuICAgIGNiKG51bGwsIHBhY2tldClcbiAgfSBlbHNlIGlmIChjYikge1xuICAgIGNiKG5ldyBFcnJvcignbWlzc2luZyBwYWNrZXQnKSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ2xvc2UgdGhlIHN0b3JlXG4gKi9cblN0b3JlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAodGhpcy5vcHRpb25zLmNsZWFuKSB7XG4gICAgdGhpcy5faW5mbGlnaHRzID0gbnVsbFxuICB9XG4gIGlmIChjYikge1xuICAgIGNiKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3JlXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCJfcHJvY2Vzc1wiOjkyLFwiZXM2LW1hcFwiOjY3LFwicmVhZGFibGUtc3RyZWFtXCI6MTA4LFwieHRlbmRcIjoxMjF9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFZhbGlkYXRlIGEgdG9waWMgdG8gc2VlIGlmIGl0J3MgdmFsaWQgb3Igbm90LlxuICogQSB0b3BpYyBpcyB2YWxpZCBpZiBpdCBmb2xsb3cgYmVsb3cgcnVsZXM6XG4gKiAtIFJ1bGUgIzE6IElmIGFueSBwYXJ0IG9mIHRoZSB0b3BpYyBpcyBub3QgYCtgIG9yIGAjYCwgdGhlbiBpdCBtdXN0IG5vdCBjb250YWluIGArYCBhbmQgJyMnXG4gKiAtIFJ1bGUgIzI6IFBhcnQgYCNgIG11c3QgYmUgbG9jYXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBtYWlsYm94XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRvcGljIC0gQSB0b3BpY1xuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSB0b3BpYyBpcyB2YWxpZCwgcmV0dXJucyB0cnVlLiBPdGhlcndpc2UsIHJldHVybnMgZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVG9waWMgKHRvcGljKSB7XG4gIHZhciBwYXJ0cyA9IHRvcGljLnNwbGl0KCcvJylcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhcnRzW2ldID09PSAnKycpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKHBhcnRzW2ldID09PSAnIycpIHtcbiAgICAgIC8vIGZvciBSdWxlICMyXG4gICAgICByZXR1cm4gaSA9PT0gcGFydHMubGVuZ3RoIC0gMVxuICAgIH1cblxuICAgIGlmIChwYXJ0c1tpXS5pbmRleE9mKCcrJykgIT09IC0xIHx8IHBhcnRzW2ldLmluZGV4T2YoJyMnKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogVmFsaWRhdGUgYW4gYXJyYXkgb2YgdG9waWNzIHRvIHNlZSBpZiBhbnkgb2YgdGhlbSBpcyB2YWxpZCBvciBub3RcbiAgKiBAcGFyYW0ge0FycmF5fSB0b3BpY3MgLSBBcnJheSBvZiB0b3BpY3NcbiAqIEByZXR1cm5zIHtTdHJpbmd9IElmIHRoZSB0b3BpY3MgaXMgdmFsaWQsIHJldHVybnMgbnVsbC4gT3RoZXJ3aXNlLCByZXR1cm5zIHRoZSBpbnZhbGlkIG9uZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVRvcGljcyAodG9waWNzKSB7XG4gIGlmICh0b3BpY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdlbXB0eV90b3BpY19saXN0J1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9waWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCF2YWxpZGF0ZVRvcGljKHRvcGljc1tpXSkpIHtcbiAgICAgIHJldHVybiB0b3BpY3NbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZhbGlkYXRlVG9waWNzOiB2YWxpZGF0ZVRvcGljc1xufVxuXG59LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCdcblxudmFyIE1xdHRDbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQnKVxudmFyIFN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmUnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgcHJvdG9jb2xzID0ge31cblxuaWYgKHByb2Nlc3MudGl0bGUgIT09ICdicm93c2VyJykge1xuICBwcm90b2NvbHMubXF0dCA9IHJlcXVpcmUoJy4vdGNwJylcbiAgcHJvdG9jb2xzLnRjcCA9IHJlcXVpcmUoJy4vdGNwJylcbiAgcHJvdG9jb2xzLnNzbCA9IHJlcXVpcmUoJy4vdGxzJylcbiAgcHJvdG9jb2xzLnRscyA9IHJlcXVpcmUoJy4vdGxzJylcbiAgcHJvdG9jb2xzLm1xdHRzID0gcmVxdWlyZSgnLi90bHMnKVxufSBlbHNlIHtcbiAgcHJvdG9jb2xzLnd4ID0gcmVxdWlyZSgnLi93eCcpXG4gIHByb3RvY29scy53eHMgPSByZXF1aXJlKCcuL3d4JylcblxuICBwcm90b2NvbHMuYWxpID0gcmVxdWlyZSgnLi9hbGknKVxuICBwcm90b2NvbHMuYWxpcyA9IHJlcXVpcmUoJy4vYWxpJylcbn1cblxucHJvdG9jb2xzLndzID0gcmVxdWlyZSgnLi93cycpXG5wcm90b2NvbHMud3NzID0gcmVxdWlyZSgnLi93cycpXG5cbi8qKlxuICogUGFyc2UgdGhlIGF1dGggYXR0cmlidXRlIGFuZCBtZXJnZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gb3B0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBwYXJzZUF1dGhPcHRpb25zIChvcHRzKSB7XG4gIHZhciBtYXRjaGVzXG4gIGlmIChvcHRzLmF1dGgpIHtcbiAgICBtYXRjaGVzID0gb3B0cy5hdXRoLm1hdGNoKC9eKC4rKTooLispJC8pXG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgIG9wdHMudXNlcm5hbWUgPSBtYXRjaGVzWzFdXG4gICAgICBvcHRzLnBhc3N3b3JkID0gbWF0Y2hlc1syXVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLnVzZXJuYW1lID0gb3B0cy5hdXRoXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogY29ubmVjdCAtIGNvbm5lY3QgdG8gYW4gTVFUVCBicm9rZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFticm9rZXJVcmxdIC0gdXJsIG9mIHRoZSBicm9rZXIsIG9wdGlvbmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIHNlZSBNcXR0Q2xpZW50I2NvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3QgKGJyb2tlclVybCwgb3B0cykge1xuICBpZiAoKHR5cGVvZiBicm9rZXJVcmwgPT09ICdvYmplY3QnKSAmJiAhb3B0cykge1xuICAgIG9wdHMgPSBicm9rZXJVcmxcbiAgICBicm9rZXJVcmwgPSBudWxsXG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIGlmIChicm9rZXJVcmwpIHtcbiAgICB2YXIgcGFyc2VkID0gdXJsLnBhcnNlKGJyb2tlclVybCwgdHJ1ZSlcbiAgICBpZiAocGFyc2VkLnBvcnQgIT0gbnVsbCkge1xuICAgICAgcGFyc2VkLnBvcnQgPSBOdW1iZXIocGFyc2VkLnBvcnQpXG4gICAgfVxuXG4gICAgb3B0cyA9IHh0ZW5kKHBhcnNlZCwgb3B0cylcblxuICAgIGlmIChvcHRzLnByb3RvY29sID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJvdG9jb2wnKVxuICAgIH1cbiAgICBvcHRzLnByb3RvY29sID0gb3B0cy5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKVxuICB9XG5cbiAgLy8gbWVyZ2UgaW4gdGhlIGF1dGggb3B0aW9ucyBpZiBzdXBwbGllZFxuICBwYXJzZUF1dGhPcHRpb25zKG9wdHMpXG5cbiAgLy8gc3VwcG9ydCBjbGllbnRJZCBwYXNzZWQgaW4gdGhlIHF1ZXJ5IHN0cmluZyBvZiB0aGUgdXJsXG4gIGlmIChvcHRzLnF1ZXJ5ICYmIHR5cGVvZiBvcHRzLnF1ZXJ5LmNsaWVudElkID09PSAnc3RyaW5nJykge1xuICAgIG9wdHMuY2xpZW50SWQgPSBvcHRzLnF1ZXJ5LmNsaWVudElkXG4gIH1cblxuICBpZiAob3B0cy5jZXJ0ICYmIG9wdHMua2V5KSB7XG4gICAgaWYgKG9wdHMucHJvdG9jb2wpIHtcbiAgICAgIGlmIChbJ21xdHRzJywgJ3dzcycsICd3eHMnLCAnYWxpcyddLmluZGV4T2Yob3B0cy5wcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICAgIHN3aXRjaCAob3B0cy5wcm90b2NvbCkge1xuICAgICAgICAgIGNhc2UgJ21xdHQnOlxuICAgICAgICAgICAgb3B0cy5wcm90b2NvbCA9ICdtcXR0cydcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnd3MnOlxuICAgICAgICAgICAgb3B0cy5wcm90b2NvbCA9ICd3c3MnXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ3d4JzpcbiAgICAgICAgICAgIG9wdHMucHJvdG9jb2wgPSAnd3hzJ1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICdhbGknOlxuICAgICAgICAgICAgb3B0cy5wcm90b2NvbCA9ICdhbGlzJ1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb3RvY29sIGZvciBzZWN1cmUgY29ubmVjdGlvbjogXCInICsgb3B0cy5wcm90b2NvbCArICdcIiEnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvbid0IGtub3cgd2hhdCBwcm90b2NvbCBoZSB3YW50IHRvIHVzZSwgbXF0dHMgb3Igd3NzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2VjdXJlIHByb3RvY29sIGtleScpXG4gICAgfVxuICB9XG5cbiAgaWYgKCFwcm90b2NvbHNbb3B0cy5wcm90b2NvbF0pIHtcbiAgICB2YXIgaXNTZWN1cmUgPSBbJ21xdHRzJywgJ3dzcyddLmluZGV4T2Yob3B0cy5wcm90b2NvbCkgIT09IC0xXG4gICAgb3B0cy5wcm90b2NvbCA9IFtcbiAgICAgICdtcXR0JyxcbiAgICAgICdtcXR0cycsXG4gICAgICAnd3MnLFxuICAgICAgJ3dzcycsXG4gICAgICAnd3gnLFxuICAgICAgJ3d4cycsXG4gICAgICAnYWxpJyxcbiAgICAgICdhbGlzJ1xuICAgIF0uZmlsdGVyKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgICBpZiAoaXNTZWN1cmUgJiYgaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgIC8vIFNraXAgaW5zZWN1cmUgcHJvdG9jb2xzIHdoZW4gcmVxdWVzdGluZyBhIHNlY3VyZSBvbmUuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuICh0eXBlb2YgcHJvdG9jb2xzW2tleV0gPT09ICdmdW5jdGlvbicpXG4gICAgfSlbMF1cbiAgfVxuXG4gIGlmIChvcHRzLmNsZWFuID09PSBmYWxzZSAmJiAhb3B0cy5jbGllbnRJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBjbGllbnRJZCBmb3IgdW5jbGVhbiBjbGllbnRzJylcbiAgfVxuXG4gIGlmIChvcHRzLnByb3RvY29sKSB7XG4gICAgb3B0cy5kZWZhdWx0UHJvdG9jb2wgPSBvcHRzLnByb3RvY29sXG4gIH1cblxuICBmdW5jdGlvbiB3cmFwcGVyIChjbGllbnQpIHtcbiAgICBpZiAob3B0cy5zZXJ2ZXJzKSB7XG4gICAgICBpZiAoIWNsaWVudC5fcmVjb25uZWN0Q291bnQgfHwgY2xpZW50Ll9yZWNvbm5lY3RDb3VudCA9PT0gb3B0cy5zZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgICBjbGllbnQuX3JlY29ubmVjdENvdW50ID0gMFxuICAgICAgfVxuXG4gICAgICBvcHRzLmhvc3QgPSBvcHRzLnNlcnZlcnNbY2xpZW50Ll9yZWNvbm5lY3RDb3VudF0uaG9zdFxuICAgICAgb3B0cy5wb3J0ID0gb3B0cy5zZXJ2ZXJzW2NsaWVudC5fcmVjb25uZWN0Q291bnRdLnBvcnRcbiAgICAgIG9wdHMucHJvdG9jb2wgPSAoIW9wdHMuc2VydmVyc1tjbGllbnQuX3JlY29ubmVjdENvdW50XS5wcm90b2NvbCA/IG9wdHMuZGVmYXVsdFByb3RvY29sIDogb3B0cy5zZXJ2ZXJzW2NsaWVudC5fcmVjb25uZWN0Q291bnRdLnByb3RvY29sKVxuICAgICAgb3B0cy5ob3N0bmFtZSA9IG9wdHMuaG9zdFxuXG4gICAgICBjbGllbnQuX3JlY29ubmVjdENvdW50KytcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvdG9jb2xzW29wdHMucHJvdG9jb2xdKGNsaWVudCwgb3B0cylcbiAgfVxuXG4gIHJldHVybiBuZXcgTXF0dENsaWVudCh3cmFwcGVyLCBvcHRzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3Rcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSBjb25uZWN0XG5tb2R1bGUuZXhwb3J0cy5NcXR0Q2xpZW50ID0gTXF0dENsaWVudFxubW9kdWxlLmV4cG9ydHMuU3RvcmUgPSBTdG9yZVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiLi4vY2xpZW50XCI6MSxcIi4uL3N0b3JlXCI6NyxcIi4vYWxpXCI6MixcIi4vdGNwXCI6MyxcIi4vdGxzXCI6NCxcIi4vd3NcIjo1LFwiLi93eFwiOjYsXCJfcHJvY2Vzc1wiOjkyLFwidXJsXCI6MTEzLFwieHRlbmRcIjoxMjF9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxufSx7fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG59LHt9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG59LHtcImJhc2U2NC1qc1wiOjEwLFwiaWVlZTc1NFwiOjc5fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IG9iamVjdENyZWF0ZVBvbHlmaWxsXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IG9iamVjdEtleXNQb2x5ZmlsbFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbFxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG52YXIgaGFzRGVmaW5lUHJvcGVydHk7XG50cnkge1xuICB2YXIgbyA9IHt9O1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ3gnLCB7IHZhbHVlOiAwIH0pO1xuICBoYXNEZWZpbmVQcm9wZXJ0eSA9IG8ueCA9PT0gMDtcbn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH1cbmlmIChoYXNEZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlIG51bWJlciAod2hvc2UgdmFsdWUgaXMgemVybyBvclxuICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS5cbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IGFyZyAhPT0gYXJnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG59XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cztcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdC4nKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJyVzOiAlcycsIHcubmFtZSwgdy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBiaW5kLmNhbGwob25jZVdyYXBwZXIsIHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFldmxpc3RlbmVyKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKSB7XG4gIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSB7XG4gICAga2V5cy5wdXNoKGspO1xuICB9XG4gIHJldHVybiBrO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25CaW5kUG9seWZpbGwoY29udGV4dCkge1xuICB2YXIgZm4gPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG59LHt9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKEJ1ZmZlcil7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cbn0pLmNhbGwodGhpcyx7XCJpc0J1ZmZlclwiOnJlcXVpcmUoXCIuLi8uLi9pcy1idWZmZXIvaW5kZXguanNcIil9KVxufSx7XCIuLi8uLi9pcy1idWZmZXIvaW5kZXguanNcIjo4MX1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGNvcHkgICAgICAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9jb3B5JylcbiAgLCBub3JtYWxpemVPcHRpb25zID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMnKVxuICAsIGVuc3VyZUNhbGxhYmxlICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgbWFwICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L21hcCcpXG4gICwgY2FsbGFibGUgICAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcbiAgLCB2YWxpZFZhbHVlICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWUnKVxuXG4gICwgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGRlZmluZTtcblxuZGVmaW5lID0gZnVuY3Rpb24gKG5hbWUsIGRlc2MsIG9wdGlvbnMpIHtcblx0dmFyIHZhbHVlID0gdmFsaWRWYWx1ZShkZXNjKSAmJiBjYWxsYWJsZShkZXNjLnZhbHVlKSwgZGdzO1xuXHRkZ3MgPSBjb3B5KGRlc2MpO1xuXHRkZWxldGUgZGdzLndyaXRhYmxlO1xuXHRkZWxldGUgZGdzLnZhbHVlO1xuXHRkZ3MuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICghb3B0aW9ucy5vdmVyd3JpdGVEZWZpbml0aW9uICYmIGhhc093blByb3BlcnR5LmNhbGwodGhpcywgbmFtZSkpIHJldHVybiB2YWx1ZTtcblx0XHRkZXNjLnZhbHVlID0gYmluZC5jYWxsKHZhbHVlLCBvcHRpb25zLnJlc29sdmVDb250ZXh0ID8gb3B0aW9ucy5yZXNvbHZlQ29udGV4dCh0aGlzKSA6IHRoaXMpO1xuXHRcdGRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIGRlc2MpO1xuXHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHR9O1xuXHRyZXR1cm4gZGdzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvcHMvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBvcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucyhhcmd1bWVudHNbMV0pO1xuXHRpZiAob3B0aW9ucy5yZXNvbHZlQ29udGV4dCAhPSBudWxsKSBlbnN1cmVDYWxsYWJsZShvcHRpb25zLnJlc29sdmVDb250ZXh0KTtcblx0cmV0dXJuIG1hcChwcm9wcywgZnVuY3Rpb24gKGRlc2MsIG5hbWUpIHsgcmV0dXJuIGRlZmluZShuYW1lLCBkZXNjLCBvcHRpb25zKTsgfSk7XG59O1xuXG59LHtcImVzNS1leHQvb2JqZWN0L2NvcHlcIjozOSxcImVzNS1leHQvb2JqZWN0L21hcFwiOjQ4LFwiZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnNcIjo0OSxcImVzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlXCI6NTQsXCJlczUtZXh0L29iamVjdC92YWxpZC12YWx1ZVwiOjU1fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduICAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2Fzc2lnbicpXG4gICwgbm9ybWFsaXplT3B0cyA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zJylcbiAgLCBpc0NhbGxhYmxlICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvaXMtY2FsbGFibGUnKVxuICAsIGNvbnRhaW5zICAgICAgPSByZXF1aXJlKCdlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zJylcblxuICAsIGQ7XG5cbmQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkc2NyLCB2YWx1ZS8qLCBvcHRpb25zKi8pIHtcblx0dmFyIGMsIGUsIHcsIG9wdGlvbnMsIGRlc2M7XG5cdGlmICgoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHx8ICh0eXBlb2YgZHNjciAhPT0gJ3N0cmluZycpKSB7XG5cdFx0b3B0aW9ucyA9IHZhbHVlO1xuXHRcdHZhbHVlID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzJdO1xuXHR9XG5cdGlmIChkc2NyID09IG51bGwpIHtcblx0XHRjID0gdyA9IHRydWU7XG5cdFx0ZSA9IGZhbHNlO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSBjb250YWlucy5jYWxsKGRzY3IsICdjJyk7XG5cdFx0ZSA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2UnKTtcblx0XHR3ID0gY29udGFpbnMuY2FsbChkc2NyLCAndycpO1xuXHR9XG5cblx0ZGVzYyA9IHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IGMsIGVudW1lcmFibGU6IGUsIHdyaXRhYmxlOiB3IH07XG5cdHJldHVybiAhb3B0aW9ucyA/IGRlc2MgOiBhc3NpZ24obm9ybWFsaXplT3B0cyhvcHRpb25zKSwgZGVzYyk7XG59O1xuXG5kLmdzID0gZnVuY3Rpb24gKGRzY3IsIGdldCwgc2V0LyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgb3B0aW9ucywgZGVzYztcblx0aWYgKHR5cGVvZiBkc2NyICE9PSAnc3RyaW5nJykge1xuXHRcdG9wdGlvbnMgPSBzZXQ7XG5cdFx0c2V0ID0gZ2V0O1xuXHRcdGdldCA9IGRzY3I7XG5cdFx0ZHNjciA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1szXTtcblx0fVxuXHRpZiAoZ2V0ID09IG51bGwpIHtcblx0XHRnZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUoZ2V0KSkge1xuXHRcdG9wdGlvbnMgPSBnZXQ7XG5cdFx0Z2V0ID0gc2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKHNldCA9PSBudWxsKSB7XG5cdFx0c2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKHNldCkpIHtcblx0XHRvcHRpb25zID0gc2V0O1xuXHRcdHNldCA9IHVuZGVmaW5lZDtcblx0fVxuXHRpZiAoZHNjciA9PSBudWxsKSB7XG5cdFx0YyA9IHRydWU7XG5cdFx0ZSA9IGZhbHNlO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSBjb250YWlucy5jYWxsKGRzY3IsICdjJyk7XG5cdFx0ZSA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2UnKTtcblx0fVxuXG5cdGRlc2MgPSB7IGdldDogZ2V0LCBzZXQ6IHNldCwgY29uZmlndXJhYmxlOiBjLCBlbnVtZXJhYmxlOiBlIH07XG5cdHJldHVybiAhb3B0aW9ucyA/IGRlc2MgOiBhc3NpZ24obm9ybWFsaXplT3B0cyhvcHRpb25zKSwgZGVzYyk7XG59O1xuXG59LHtcImVzNS1leHQvb2JqZWN0L2Fzc2lnblwiOjM2LFwiZXM1LWV4dC9vYmplY3QvaXMtY2FsbGFibGVcIjo0MixcImVzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zXCI6NDksXCJlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zXCI6NTZ9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsQnVmZmVyKXtcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIGVvcyA9IHJlcXVpcmUoJ2VuZC1vZi1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHNoaWZ0ID0gcmVxdWlyZSgnc3RyZWFtLXNoaWZ0JylcblxudmFyIFNJR05BTF9GTFVTSCA9IChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tKVxuICA/IEJ1ZmZlci5mcm9tKFswXSlcbiAgOiBuZXcgQnVmZmVyKFswXSlcblxudmFyIG9udW5jb3JrID0gZnVuY3Rpb24oc2VsZiwgZm4pIHtcbiAgaWYgKHNlbGYuX2NvcmtlZCkgc2VsZi5vbmNlKCd1bmNvcmsnLCBmbilcbiAgZWxzZSBmbigpXG59XG5cbnZhciBhdXRvRGVzdHJveSA9IGZ1bmN0aW9uIChzZWxmLCBlcnIpIHtcbiAgaWYgKHNlbGYuX2F1dG9EZXN0cm95KSBzZWxmLmRlc3Ryb3koZXJyKVxufVxuXG52YXIgZGVzdHJveWVyID0gZnVuY3Rpb24oc2VsZiwgZW5kKSB7XG4gIHJldHVybiBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoZXJyKSBhdXRvRGVzdHJveShzZWxmLCBlcnIubWVzc2FnZSA9PT0gJ3ByZW1hdHVyZSBjbG9zZScgPyBudWxsIDogZXJyKVxuICAgIGVsc2UgaWYgKGVuZCAmJiAhc2VsZi5fZW5kZWQpIHNlbGYuZW5kKClcbiAgfVxufVxuXG52YXIgZW5kID0gZnVuY3Rpb24od3MsIGZuKSB7XG4gIGlmICghd3MpIHJldHVybiBmbigpXG4gIGlmICh3cy5fd3JpdGFibGVTdGF0ZSAmJiB3cy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkgcmV0dXJuIGZuKClcbiAgaWYgKHdzLl93cml0YWJsZVN0YXRlKSByZXR1cm4gd3MuZW5kKGZuKVxuICB3cy5lbmQoKVxuICBmbigpXG59XG5cbnZhciB0b1N0cmVhbXMyID0gZnVuY3Rpb24ocnMpIHtcbiAgcmV0dXJuIG5ldyAoc3RyZWFtLlJlYWRhYmxlKSh7b2JqZWN0TW9kZTp0cnVlLCBoaWdoV2F0ZXJNYXJrOjE2fSkud3JhcChycylcbn1cblxudmFyIER1cGxleGlmeSA9IGZ1bmN0aW9uKHdyaXRhYmxlLCByZWFkYWJsZSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4aWZ5KSkgcmV0dXJuIG5ldyBEdXBsZXhpZnkod3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKVxuICBzdHJlYW0uRHVwbGV4LmNhbGwodGhpcywgb3B0cylcblxuICB0aGlzLl93cml0YWJsZSA9IG51bGxcbiAgdGhpcy5fcmVhZGFibGUgPSBudWxsXG4gIHRoaXMuX3JlYWRhYmxlMiA9IG51bGxcblxuICB0aGlzLl9hdXRvRGVzdHJveSA9ICFvcHRzIHx8IG9wdHMuYXV0b0Rlc3Ryb3kgIT09IGZhbHNlXG4gIHRoaXMuX2ZvcndhcmREZXN0cm95ID0gIW9wdHMgfHwgb3B0cy5kZXN0cm95ICE9PSBmYWxzZVxuICB0aGlzLl9mb3J3YXJkRW5kID0gIW9wdHMgfHwgb3B0cy5lbmQgIT09IGZhbHNlXG4gIHRoaXMuX2NvcmtlZCA9IDEgLy8gc3RhcnQgY29ya2VkXG4gIHRoaXMuX29uZHJhaW4gPSBudWxsXG4gIHRoaXMuX2RyYWluZWQgPSBmYWxzZVxuICB0aGlzLl9mb3J3YXJkaW5nID0gZmFsc2VcbiAgdGhpcy5fdW53cml0ZSA9IG51bGxcbiAgdGhpcy5fdW5yZWFkID0gbnVsbFxuICB0aGlzLl9lbmRlZCA9IGZhbHNlXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuXG4gIGlmICh3cml0YWJsZSkgdGhpcy5zZXRXcml0YWJsZSh3cml0YWJsZSlcbiAgaWYgKHJlYWRhYmxlKSB0aGlzLnNldFJlYWRhYmxlKHJlYWRhYmxlKVxufVxuXG5pbmhlcml0cyhEdXBsZXhpZnksIHN0cmVhbS5EdXBsZXgpXG5cbkR1cGxleGlmeS5vYmogPSBmdW5jdGlvbih3cml0YWJsZSwgcmVhZGFibGUsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgb3B0cy5vYmplY3RNb2RlID0gdHJ1ZVxuICBvcHRzLmhpZ2hXYXRlck1hcmsgPSAxNlxuICByZXR1cm4gbmV3IER1cGxleGlmeSh3cml0YWJsZSwgcmVhZGFibGUsIG9wdHMpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uKCkge1xuICBpZiAoKyt0aGlzLl9jb3JrZWQgPT09IDEpIHRoaXMuZW1pdCgnY29yaycpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9jb3JrZWQgJiYgLS10aGlzLl9jb3JrZWQgPT09IDApIHRoaXMuZW1pdCgndW5jb3JrJylcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5zZXRXcml0YWJsZSA9IGZ1bmN0aW9uKHdyaXRhYmxlKSB7XG4gIGlmICh0aGlzLl91bndyaXRlKSB0aGlzLl91bndyaXRlKClcblxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICBpZiAod3JpdGFibGUgJiYgd3JpdGFibGUuZGVzdHJveSkgd3JpdGFibGUuZGVzdHJveSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAod3JpdGFibGUgPT09IG51bGwgfHwgd3JpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgdGhpcy5lbmQoKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciB1bmVuZCA9IGVvcyh3cml0YWJsZSwge3dyaXRhYmxlOnRydWUsIHJlYWRhYmxlOmZhbHNlfSwgZGVzdHJveWVyKHRoaXMsIHRoaXMuX2ZvcndhcmRFbmQpKVxuXG4gIHZhciBvbmRyYWluID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uZHJhaW4gPSBzZWxmLl9vbmRyYWluXG4gICAgc2VsZi5fb25kcmFpbiA9IG51bGxcbiAgICBpZiAob25kcmFpbikgb25kcmFpbigpXG4gIH1cblxuICB2YXIgY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLl93cml0YWJsZS5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKVxuICAgIHVuZW5kKClcbiAgfVxuXG4gIGlmICh0aGlzLl91bndyaXRlKSBwcm9jZXNzLm5leHRUaWNrKG9uZHJhaW4pIC8vIGZvcmNlIGEgZHJhaW4gb24gc3RyZWFtIHJlc2V0IHRvIGF2b2lkIGxpdmVsb2Nrc1xuXG4gIHRoaXMuX3dyaXRhYmxlID0gd3JpdGFibGVcbiAgdGhpcy5fd3JpdGFibGUub24oJ2RyYWluJywgb25kcmFpbilcbiAgdGhpcy5fdW53cml0ZSA9IGNsZWFyXG5cbiAgdGhpcy51bmNvcmsoKSAvLyBhbHdheXMgdW5jb3JrIHNldFdyaXRhYmxlXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuc2V0UmVhZGFibGUgPSBmdW5jdGlvbihyZWFkYWJsZSkge1xuICBpZiAodGhpcy5fdW5yZWFkKSB0aGlzLl91bnJlYWQoKVxuXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgIGlmIChyZWFkYWJsZSAmJiByZWFkYWJsZS5kZXN0cm95KSByZWFkYWJsZS5kZXN0cm95KClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChyZWFkYWJsZSA9PT0gbnVsbCB8fCByZWFkYWJsZSA9PT0gZmFsc2UpIHtcbiAgICB0aGlzLnB1c2gobnVsbClcbiAgICB0aGlzLnJlc3VtZSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHVuZW5kID0gZW9zKHJlYWRhYmxlLCB7d3JpdGFibGU6ZmFsc2UsIHJlYWRhYmxlOnRydWV9LCBkZXN0cm95ZXIodGhpcykpXG5cbiAgdmFyIG9ucmVhZGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9mb3J3YXJkKClcbiAgfVxuXG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYucHVzaChudWxsKVxuICB9XG5cbiAgdmFyIGNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fcmVhZGFibGUyLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIG9ucmVhZGFibGUpXG4gICAgc2VsZi5fcmVhZGFibGUyLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICB1bmVuZCgpXG4gIH1cblxuICB0aGlzLl9kcmFpbmVkID0gdHJ1ZVxuICB0aGlzLl9yZWFkYWJsZSA9IHJlYWRhYmxlXG4gIHRoaXMuX3JlYWRhYmxlMiA9IHJlYWRhYmxlLl9yZWFkYWJsZVN0YXRlID8gcmVhZGFibGUgOiB0b1N0cmVhbXMyKHJlYWRhYmxlKVxuICB0aGlzLl9yZWFkYWJsZTIub24oJ3JlYWRhYmxlJywgb25yZWFkYWJsZSlcbiAgdGhpcy5fcmVhZGFibGUyLm9uKCdlbmQnLCBvbmVuZClcbiAgdGhpcy5fdW5yZWFkID0gY2xlYXJcblxuICB0aGlzLl9mb3J3YXJkKClcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9kcmFpbmVkID0gdHJ1ZVxuICB0aGlzLl9mb3J3YXJkKClcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5fZm9yd2FyZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZm9yd2FyZGluZyB8fCAhdGhpcy5fcmVhZGFibGUyIHx8ICF0aGlzLl9kcmFpbmVkKSByZXR1cm5cbiAgdGhpcy5fZm9yd2FyZGluZyA9IHRydWVcblxuICB2YXIgZGF0YVxuXG4gIHdoaWxlICh0aGlzLl9kcmFpbmVkICYmIChkYXRhID0gc2hpZnQodGhpcy5fcmVhZGFibGUyKSkgIT09IG51bGwpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIGNvbnRpbnVlXG4gICAgdGhpcy5fZHJhaW5lZCA9IHRoaXMucHVzaChkYXRhKVxuICB9XG5cbiAgdGhpcy5fZm9yd2FyZGluZyA9IGZhbHNlXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9kZXN0cm95KGVycilcbiAgfSlcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAoZXJyKSB7XG4gICAgdmFyIG9uZHJhaW4gPSB0aGlzLl9vbmRyYWluXG4gICAgdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgICBpZiAob25kcmFpbikgb25kcmFpbihlcnIpXG4gICAgZWxzZSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG5cbiAgaWYgKHRoaXMuX2ZvcndhcmREZXN0cm95KSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlICYmIHRoaXMuX3JlYWRhYmxlLmRlc3Ryb3kpIHRoaXMuX3JlYWRhYmxlLmRlc3Ryb3koKVxuICAgIGlmICh0aGlzLl93cml0YWJsZSAmJiB0aGlzLl93cml0YWJsZS5kZXN0cm95KSB0aGlzLl93cml0YWJsZS5kZXN0cm95KClcbiAgfVxuXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGVuYywgY2IpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm4gY2IoKVxuICBpZiAodGhpcy5fY29ya2VkKSByZXR1cm4gb251bmNvcmsodGhpcywgdGhpcy5fd3JpdGUuYmluZCh0aGlzLCBkYXRhLCBlbmMsIGNiKSlcbiAgaWYgKGRhdGEgPT09IFNJR05BTF9GTFVTSCkgcmV0dXJuIHRoaXMuX2ZpbmlzaChjYilcbiAgaWYgKCF0aGlzLl93cml0YWJsZSkgcmV0dXJuIGNiKClcblxuICBpZiAodGhpcy5fd3JpdGFibGUud3JpdGUoZGF0YSkgPT09IGZhbHNlKSB0aGlzLl9vbmRyYWluID0gY2JcbiAgZWxzZSBjYigpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLmVtaXQoJ3ByZWVuZCcpXG4gIG9udW5jb3JrKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGVuZChzZWxmLl9mb3J3YXJkRW5kICYmIHNlbGYuX3dyaXRhYmxlLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGhheHggdG8gbm90IGVtaXQgcHJlZmluaXNoIHR3aWNlXG4gICAgICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9PT0gZmFsc2UpIHNlbGYuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSB0cnVlXG4gICAgICBzZWxmLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICBvbnVuY29yayhzZWxmLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGRhdGEsIGVuYywgY2IpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5lbmQobnVsbCwgbnVsbCwgZGF0YSlcbiAgaWYgKHR5cGVvZiBlbmMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmVuZChkYXRhLCBudWxsLCBlbmMpXG4gIHRoaXMuX2VuZGVkID0gdHJ1ZVxuICBpZiAoZGF0YSkgdGhpcy53cml0ZShkYXRhKVxuICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nKSB0aGlzLndyaXRlKFNJR05BTF9GTFVTSClcbiAgcmV0dXJuIHN0cmVhbS5Xcml0YWJsZS5wcm90b3R5cGUuZW5kLmNhbGwodGhpcywgY2IpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4aWZ5XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxufSx7XCJfcHJvY2Vzc1wiOjkyLFwiYnVmZmVyXCI6MTIsXCJlbmQtb2Ytc3RyZWFtXCI6MTgsXCJpbmhlcml0c1wiOjgwLFwicmVhZGFibGUtc3RyZWFtXCI6MTA4LFwic3RyZWFtLXNoaWZ0XCI6MTExfV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJyk7XG5cbnZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxudmFyIGlzUmVxdWVzdCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRyZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGlzQ2hpbGRQcm9jZXNzID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHJldHVybiBzdHJlYW0uc3RkaW8gJiYgQXJyYXkuaXNBcnJheShzdHJlYW0uc3RkaW8pICYmIHN0cmVhbS5zdGRpby5sZW5ndGggPT09IDNcbn07XG5cbnZhciBlb3MgPSBmdW5jdGlvbihzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XG5cdGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpO1xuXHRpZiAoIW9wdHMpIG9wdHMgPSB7fTtcblxuXHRjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG5cblx0dmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuXHR2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cdHZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgKG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZSk7XG5cdHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgKG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZSk7XG5cblx0dmFyIG9ubGVnYWN5ZmluaXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCFzdHJlYW0ud3JpdGFibGUpIG9uZmluaXNoKCk7XG5cdH07XG5cblx0dmFyIG9uZmluaXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0d3JpdGFibGUgPSBmYWxzZTtcblx0XHRpZiAoIXJlYWRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG5cdH07XG5cblx0dmFyIG9uZW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0cmVhZGFibGUgPSBmYWxzZTtcblx0XHRpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG5cdH07XG5cblx0dmFyIG9uZXhpdCA9IGZ1bmN0aW9uKGV4aXRDb2RlKSB7XG5cdFx0Y2FsbGJhY2suY2FsbChzdHJlYW0sIGV4aXRDb2RlID8gbmV3IEVycm9yKCdleGl0ZWQgd2l0aCBlcnJvciBjb2RlOiAnICsgZXhpdENvZGUpIDogbnVsbCk7XG5cdH07XG5cblx0dmFyIG9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcblx0fTtcblxuXHR2YXIgb25jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChyZWFkYWJsZSAmJiAhKHJzICYmIHJzLmVuZGVkKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTtcblx0XHRpZiAod3JpdGFibGUgJiYgISh3cyAmJiB3cy5lbmRlZCkpIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgbmV3IEVycm9yKCdwcmVtYXR1cmUgY2xvc2UnKSk7XG5cdH07XG5cblx0dmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0fTtcblxuXHRpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcblx0XHRzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcblx0XHRpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7XG5cdFx0ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuXHR9IGVsc2UgaWYgKHdyaXRhYmxlICYmICF3cykgeyAvLyBsZWdhY3kgc3RyZWFtc1xuXHRcdHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdH1cblxuXHRpZiAoaXNDaGlsZFByb2Nlc3Moc3RyZWFtKSkgc3RyZWFtLm9uKCdleGl0Jywgb25leGl0KTtcblxuXHRzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTtcblx0c3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXHRzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG5cdFx0aWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXhpdCcsIG9uZXhpdCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zO1xuXG59LHtcIm9uY2VcIjo5MH1dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIEluc3BpcmVkIGJ5IEdvb2dsZSBDbG9zdXJlOlxuLy8gaHR0cDovL2Nsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9zdm4vZG9jcy9cbi8vIGNsb3N1cmVfZ29vZ19hcnJheV9hcnJheS5qcy5odG1sI2dvb2cuYXJyYXkuY2xlYXJcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB2YWx1ZSA9IHJlcXVpcmUoXCIuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YWx1ZSh0aGlzKS5sZW5ndGggPSAwO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbn0se1wiLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlXCI6NTV9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG51bWJlcklzTmFOICAgICAgID0gcmVxdWlyZShcIi4uLy4uL251bWJlci9pcy1uYW5cIilcbiAgLCB0b1Bvc0ludCAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9udW1iZXIvdG8tcG9zLWludGVnZXJcIilcbiAgLCB2YWx1ZSAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWVcIilcbiAgLCBpbmRleE9mICAgICAgICAgICA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mXG4gICwgb2JqSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgYWJzICAgICAgICAgICAgICAgPSBNYXRoLmFic1xuICAsIGZsb29yICAgICAgICAgICAgID0gTWF0aC5mbG9vcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4Ki8pIHtcblx0dmFyIGksIGxlbmd0aCwgZnJvbUluZGV4LCB2YWw7XG5cdGlmICghbnVtYmVySXNOYU4oc2VhcmNoRWxlbWVudCkpIHJldHVybiBpbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0bGVuZ3RoID0gdG9Qb3NJbnQodmFsdWUodGhpcykubGVuZ3RoKTtcblx0ZnJvbUluZGV4ID0gYXJndW1lbnRzWzFdO1xuXHRpZiAoaXNOYU4oZnJvbUluZGV4KSkgZnJvbUluZGV4ID0gMDtcblx0ZWxzZSBpZiAoZnJvbUluZGV4ID49IDApIGZyb21JbmRleCA9IGZsb29yKGZyb21JbmRleCk7XG5cdGVsc2UgZnJvbUluZGV4ID0gdG9Qb3NJbnQodGhpcy5sZW5ndGgpIC0gZmxvb3IoYWJzKGZyb21JbmRleCkpO1xuXG5cdGZvciAoaSA9IGZyb21JbmRleDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0aWYgKG9iakhhc093blByb3BlcnR5LmNhbGwodGhpcywgaSkpIHtcblx0XHRcdHZhbCA9IHRoaXNbaV07XG5cdFx0XHRpZiAobnVtYmVySXNOYU4odmFsKSkgcmV0dXJuIGk7IC8vIEpzbGludDogaWdub3JlXG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG5cbn0se1wiLi4vLi4vbnVtYmVyL2lzLW5hblwiOjMwLFwiLi4vLi4vbnVtYmVyL3RvLXBvcy1pbnRlZ2VyXCI6MzQsXCIuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWVcIjo1NX1dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKClcblx0PyBBcnJheS5mcm9tXG5cdDogcmVxdWlyZShcIi4vc2hpbVwiKTtcblxufSx7XCIuL2lzLWltcGxlbWVudGVkXCI6MjIsXCIuL3NoaW1cIjoyM31dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGZyb20gPSBBcnJheS5mcm9tLCBhcnIsIHJlc3VsdDtcblx0aWYgKHR5cGVvZiBmcm9tICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0YXJyID0gW1wicmF6XCIsIFwiZHdhXCJdO1xuXHRyZXN1bHQgPSBmcm9tKGFycik7XG5cdHJldHVybiBCb29sZWFuKHJlc3VsdCAmJiAocmVzdWx0ICE9PSBhcnIpICYmIChyZXN1bHRbMV0gPT09IFwiZHdhXCIpKTtcbn07XG5cbn0se31dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXRlcmF0b3JTeW1ib2wgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKS5pdGVyYXRvclxuICAsIGlzQXJndW1lbnRzICAgID0gcmVxdWlyZShcIi4uLy4uL2Z1bmN0aW9uL2lzLWFyZ3VtZW50c1wiKVxuICAsIGlzRnVuY3Rpb24gICAgID0gcmVxdWlyZShcIi4uLy4uL2Z1bmN0aW9uL2lzLWZ1bmN0aW9uXCIpXG4gICwgdG9Qb3NJbnQgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vbnVtYmVyL3RvLXBvcy1pbnRlZ2VyXCIpXG4gICwgY2FsbGFibGUgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L3ZhbGlkLWNhbGxhYmxlXCIpXG4gICwgdmFsaWRWYWx1ZSAgICAgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlXCIpXG4gICwgaXNWYWx1ZSAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L2lzLXZhbHVlXCIpXG4gICwgaXNTdHJpbmcgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vc3RyaW5nL2lzLXN0cmluZ1wiKVxuICAsIGlzQXJyYXkgICAgICAgID0gQXJyYXkuaXNBcnJheVxuICAsIGNhbGwgICAgICAgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBkZXNjICAgICAgICAgICA9IHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG51bGwgfVxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyYXlMaWtlIC8qLCBtYXBGbiwgdGhpc0FyZyovKSB7XG5cdHZhciBtYXBGbiA9IGFyZ3VtZW50c1sxXVxuXHQgICwgdGhpc0FyZyA9IGFyZ3VtZW50c1syXVxuXHQgICwgQ29udGV4dFxuXHQgICwgaVxuXHQgICwgalxuXHQgICwgYXJyXG5cdCAgLCBsZW5ndGhcblx0ICAsIGNvZGVcblx0ICAsIGl0ZXJhdG9yXG5cdCAgLCByZXN1bHRcblx0ICAsIGdldEl0ZXJhdG9yXG5cdCAgLCB2YWx1ZTtcblxuXHRhcnJheUxpa2UgPSBPYmplY3QodmFsaWRWYWx1ZShhcnJheUxpa2UpKTtcblxuXHRpZiAoaXNWYWx1ZShtYXBGbikpIGNhbGxhYmxlKG1hcEZuKTtcblx0aWYgKCF0aGlzIHx8IHRoaXMgPT09IEFycmF5IHx8ICFpc0Z1bmN0aW9uKHRoaXMpKSB7XG5cdFx0Ly8gUmVzdWx0OiBQbGFpbiBhcnJheVxuXHRcdGlmICghbWFwRm4pIHtcblx0XHRcdGlmIChpc0FyZ3VtZW50cyhhcnJheUxpa2UpKSB7XG5cdFx0XHRcdC8vIFNvdXJjZTogQXJndW1lbnRzXG5cdFx0XHRcdGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGg7XG5cdFx0XHRcdGlmIChsZW5ndGggIT09IDEpIHJldHVybiBBcnJheS5hcHBseShudWxsLCBhcnJheUxpa2UpO1xuXHRcdFx0XHRhcnIgPSBuZXcgQXJyYXkoMSk7XG5cdFx0XHRcdGFyclswXSA9IGFycmF5TGlrZVswXTtcblx0XHRcdFx0cmV0dXJuIGFycjtcblx0XHRcdH1cblx0XHRcdGlmIChpc0FycmF5KGFycmF5TGlrZSkpIHtcblx0XHRcdFx0Ly8gU291cmNlOiBBcnJheVxuXHRcdFx0XHRhcnIgPSBuZXcgQXJyYXkobGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aCk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgYXJyW2ldID0gYXJyYXlMaWtlW2ldO1xuXHRcdFx0XHRyZXR1cm4gYXJyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRhcnIgPSBbXTtcblx0fSBlbHNlIHtcblx0XHQvLyBSZXN1bHQ6IE5vbiBwbGFpbiBhcnJheVxuXHRcdENvbnRleHQgPSB0aGlzO1xuXHR9XG5cblx0aWYgKCFpc0FycmF5KGFycmF5TGlrZSkpIHtcblx0XHRpZiAoKGdldEl0ZXJhdG9yID0gYXJyYXlMaWtlW2l0ZXJhdG9yU3ltYm9sXSkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gU291cmNlOiBJdGVyYXRvclxuXHRcdFx0aXRlcmF0b3IgPSBjYWxsYWJsZShnZXRJdGVyYXRvcikuY2FsbChhcnJheUxpa2UpO1xuXHRcdFx0aWYgKENvbnRleHQpIGFyciA9IG5ldyBDb250ZXh0KCk7XG5cdFx0XHRyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cdFx0XHRpID0gMDtcblx0XHRcdHdoaWxlICghcmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0dmFsdWUgPSBtYXBGbiA/IGNhbGwuY2FsbChtYXBGbiwgdGhpc0FyZywgcmVzdWx0LnZhbHVlLCBpKSA6IHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0aWYgKENvbnRleHQpIHtcblx0XHRcdFx0XHRkZXNjLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoYXJyLCBpLCBkZXNjKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhcnJbaV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cdFx0XHRcdCsraTtcblx0XHRcdH1cblx0XHRcdGxlbmd0aCA9IGk7XG5cdFx0fSBlbHNlIGlmIChpc1N0cmluZyhhcnJheUxpa2UpKSB7XG5cdFx0XHQvLyBTb3VyY2U6IFN0cmluZ1xuXHRcdFx0bGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aDtcblx0XHRcdGlmIChDb250ZXh0KSBhcnIgPSBuZXcgQ29udGV4dCgpO1xuXHRcdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0XHR2YWx1ZSA9IGFycmF5TGlrZVtpXTtcblx0XHRcdFx0aWYgKGkgKyAxIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuXHRcdFx0XHRcdGlmIChjb2RlID49IDB4ZDgwMCAmJiBjb2RlIDw9IDB4ZGJmZikgdmFsdWUgKz0gYXJyYXlMaWtlWysraV07XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWUgPSBtYXBGbiA/IGNhbGwuY2FsbChtYXBGbiwgdGhpc0FyZywgdmFsdWUsIGopIDogdmFsdWU7XG5cdFx0XHRcdGlmIChDb250ZXh0KSB7XG5cdFx0XHRcdFx0ZGVzYy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KGFyciwgaiwgZGVzYyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXJyW2pdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0KytqO1xuXHRcdFx0fVxuXHRcdFx0bGVuZ3RoID0gajtcblx0XHR9XG5cdH1cblx0aWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gU291cmNlOiBhcnJheSBvciBhcnJheS1saWtlXG5cdFx0bGVuZ3RoID0gdG9Qb3NJbnQoYXJyYXlMaWtlLmxlbmd0aCk7XG5cdFx0aWYgKENvbnRleHQpIGFyciA9IG5ldyBDb250ZXh0KGxlbmd0aCk7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YWx1ZSA9IG1hcEZuID8gY2FsbC5jYWxsKG1hcEZuLCB0aGlzQXJnLCBhcnJheUxpa2VbaV0sIGkpIDogYXJyYXlMaWtlW2ldO1xuXHRcdFx0aWYgKENvbnRleHQpIHtcblx0XHRcdFx0ZGVzYy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShhcnIsIGksIGRlc2MpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJyW2ldID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmIChDb250ZXh0KSB7XG5cdFx0ZGVzYy52YWx1ZSA9IG51bGw7XG5cdFx0YXJyLmxlbmd0aCA9IGxlbmd0aDtcblx0fVxuXHRyZXR1cm4gYXJyO1xufTtcblxufSx7XCIuLi8uLi9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIjoyNCxcIi4uLy4uL2Z1bmN0aW9uL2lzLWZ1bmN0aW9uXCI6MjUsXCIuLi8uLi9udW1iZXIvdG8tcG9zLWludGVnZXJcIjozNCxcIi4uLy4uL29iamVjdC9pcy12YWx1ZVwiOjQ0LFwiLi4vLi4vb2JqZWN0L3ZhbGlkLWNhbGxhYmxlXCI6NTQsXCIuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWVcIjo1NSxcIi4uLy4uL3N0cmluZy9pcy1zdHJpbmdcIjo1OSxcImVzNi1zeW1ib2xcIjo3M31dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICwgaWQgPSBvYmpUb1N0cmluZy5jYWxsKFxuXHQoZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBhcmd1bWVudHM7XG5cdH0pKClcbik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gaWQ7XG59O1xuXG59LHt9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZywgaWQgPSBvYmpUb1N0cmluZy5jYWxsKHJlcXVpcmUoXCIuL25vb3BcIikpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IGlkO1xufTtcblxufSx7XCIuL25vb3BcIjoyNn1dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge307XG5cbn0se31dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKClcblx0PyBNYXRoLnNpZ25cblx0OiByZXF1aXJlKFwiLi9zaGltXCIpO1xuXG59LHtcIi4vaXMtaW1wbGVtZW50ZWRcIjoyOCxcIi4vc2hpbVwiOjI5fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2lnbiA9IE1hdGguc2lnbjtcblx0aWYgKHR5cGVvZiBzaWduICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIChzaWduKDEwKSA9PT0gMSkgJiYgKHNpZ24oLTIwKSA9PT0gLTEpO1xufTtcblxufSx7fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblx0aWYgKGlzTmFOKHZhbHVlKSB8fCAodmFsdWUgPT09IDApKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiB2YWx1ZSA+IDAgPyAxIDogLTE7XG59O1xuXG59LHt9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpXG5cdD8gTnVtYmVyLmlzTmFOXG5cdDogcmVxdWlyZShcIi4vc2hpbVwiKTtcblxufSx7XCIuL2lzLWltcGxlbWVudGVkXCI6MzEsXCIuL3NoaW1cIjozMn1dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOO1xuXHRpZiAodHlwZW9mIG51bWJlcklzTmFOICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuICFudW1iZXJJc05hTih7fSkgJiYgbnVtYmVySXNOYU4oTmFOKSAmJiAhbnVtYmVySXNOYU4oMzQpO1xufTtcblxufSx7fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblx0cmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG5cbn0se31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgc2lnbiA9IHJlcXVpcmUoXCIuLi9tYXRoL3NpZ25cIilcblxuICAsIGFicyA9IE1hdGguYWJzLCBmbG9vciA9IE1hdGguZmxvb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmIChpc05hTih2YWx1ZSkpIHJldHVybiAwO1xuXHR2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdGlmICgodmFsdWUgPT09IDApIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcblx0cmV0dXJuIHNpZ24odmFsdWUpICogZmxvb3IoYWJzKHZhbHVlKSk7XG59O1xuXG59LHtcIi4uL21hdGgvc2lnblwiOjI3fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKFwiLi90by1pbnRlZ2VyXCIpXG5cbiAgLCBtYXggPSBNYXRoLm1heDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiByZXR1cm4gbWF4KDAsIHRvSW50ZWdlcih2YWx1ZSkpO1xufTtcblxufSx7XCIuL3RvLWludGVnZXJcIjozM31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIEludGVybmFsIG1ldGhvZCwgdXNlZCBieSBpdGVyYXRpb24gZnVuY3Rpb25zLlxuLy8gQ2FsbHMgYSBmdW5jdGlvbiBmb3IgZWFjaCBrZXktdmFsdWUgcGFpciBmb3VuZCBpbiBvYmplY3Rcbi8vIE9wdGlvbmFsbHkgdGFrZXMgY29tcGFyZUZuIHRvIGl0ZXJhdGUgb2JqZWN0IGluIHNwZWNpZmljIG9yZGVyXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2FsbGFibGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi92YWxpZC1jYWxsYWJsZVwiKVxuICAsIHZhbHVlICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdmFsaWQtdmFsdWVcIilcbiAgLCBiaW5kICAgICAgICAgICAgICAgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gICwgY2FsbCAgICAgICAgICAgICAgICAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbFxuICAsIGtleXMgICAgICAgICAgICAgICAgICAgID0gT2JqZWN0LmtleXNcbiAgLCBvYmpQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgZGVmVmFsKSB7XG5cdHJldHVybiBmdW5jdGlvbiAob2JqLCBjYiAvKiwgdGhpc0FyZywgY29tcGFyZUZuKi8pIHtcblx0XHR2YXIgbGlzdCwgdGhpc0FyZyA9IGFyZ3VtZW50c1syXSwgY29tcGFyZUZuID0gYXJndW1lbnRzWzNdO1xuXHRcdG9iaiA9IE9iamVjdCh2YWx1ZShvYmopKTtcblx0XHRjYWxsYWJsZShjYik7XG5cblx0XHRsaXN0ID0ga2V5cyhvYmopO1xuXHRcdGlmIChjb21wYXJlRm4pIHtcblx0XHRcdGxpc3Quc29ydCh0eXBlb2YgY29tcGFyZUZuID09PSBcImZ1bmN0aW9uXCIgPyBiaW5kLmNhbGwoY29tcGFyZUZuLCBvYmopIDogdW5kZWZpbmVkKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBtZXRob2QgIT09IFwiZnVuY3Rpb25cIikgbWV0aG9kID0gbGlzdFttZXRob2RdO1xuXHRcdHJldHVybiBjYWxsLmNhbGwobWV0aG9kLCBsaXN0LCBmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuXHRcdFx0aWYgKCFvYmpQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwga2V5KSkgcmV0dXJuIGRlZlZhbDtcblx0XHRcdHJldHVybiBjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIG9ialtrZXldLCBrZXksIG9iaiwgaW5kZXgpO1xuXHRcdH0pO1xuXHR9O1xufTtcblxufSx7XCIuL3ZhbGlkLWNhbGxhYmxlXCI6NTQsXCIuL3ZhbGlkLXZhbHVlXCI6NTV9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpXG5cdD8gT2JqZWN0LmFzc2lnblxuXHQ6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG5cbn0se1wiLi9pcy1pbXBsZW1lbnRlZFwiOjM3LFwiLi9zaGltXCI6Mzh9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduLCBvYmo7XG5cdGlmICh0eXBlb2YgYXNzaWduICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0b2JqID0geyBmb286IFwicmF6XCIgfTtcblx0YXNzaWduKG9iaiwgeyBiYXI6IFwiZHdhXCIgfSwgeyB0cnp5OiBcInRyenlcIiB9KTtcblx0cmV0dXJuIChvYmouZm9vICsgb2JqLmJhciArIG9iai50cnp5KSA9PT0gXCJyYXpkd2F0cnp5XCI7XG59O1xuXG59LHt9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGtleXMgID0gcmVxdWlyZShcIi4uL2tleXNcIilcbiAgLCB2YWx1ZSA9IHJlcXVpcmUoXCIuLi92YWxpZC12YWx1ZVwiKVxuICAsIG1heCAgID0gTWF0aC5tYXg7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlc3QsIHNyYyAvKiwg4oCmc3JjbiovKSB7XG5cdHZhciBlcnJvciwgaSwgbGVuZ3RoID0gbWF4KGFyZ3VtZW50cy5sZW5ndGgsIDIpLCBhc3NpZ247XG5cdGRlc3QgPSBPYmplY3QodmFsdWUoZGVzdCkpO1xuXHRhc3NpZ24gPSBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dHJ5IHtcblx0XHRcdGRlc3Rba2V5XSA9IHNyY1trZXldO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZTtcblx0XHR9XG5cdH07XG5cdGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRrZXlzKHNyYykuZm9yRWFjaChhc3NpZ24pO1xuXHR9XG5cdGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnJvcjtcblx0cmV0dXJuIGRlc3Q7XG59O1xuXG59LHtcIi4uL2tleXNcIjo0NSxcIi4uL3ZhbGlkLXZhbHVlXCI6NTV9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFGcm9tICA9IHJlcXVpcmUoXCIuLi9hcnJheS9mcm9tXCIpXG4gICwgYXNzaWduID0gcmVxdWlyZShcIi4vYXNzaWduXCIpXG4gICwgdmFsdWUgID0gcmVxdWlyZShcIi4vdmFsaWQtdmFsdWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iai8qLCBwcm9wZXJ0eU5hbWVzLCBvcHRpb25zKi8pIHtcblx0dmFyIGNvcHkgPSBPYmplY3QodmFsdWUob2JqKSksIHByb3BlcnR5TmFtZXMgPSBhcmd1bWVudHNbMV0sIG9wdGlvbnMgPSBPYmplY3QoYXJndW1lbnRzWzJdKTtcblx0aWYgKGNvcHkgIT09IG9iaiAmJiAhcHJvcGVydHlOYW1lcykgcmV0dXJuIGNvcHk7XG5cdHZhciByZXN1bHQgPSB7fTtcblx0aWYgKHByb3BlcnR5TmFtZXMpIHtcblx0XHRhRnJvbShwcm9wZXJ0eU5hbWVzLCBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5lbnN1cmUgfHwgcHJvcGVydHlOYW1lIGluIG9iaikgcmVzdWx0W3Byb3BlcnR5TmFtZV0gPSBvYmpbcHJvcGVydHlOYW1lXTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRhc3NpZ24ocmVzdWx0LCBvYmopO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG59LHtcIi4uL2FycmF5L2Zyb21cIjoyMSxcIi4vYXNzaWduXCI6MzYsXCIuL3ZhbGlkLXZhbHVlXCI6NTV9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBXb3JrYXJvdW5kIGZvciBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yODA0XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgc2hpbTtcblxuaWYgKCFyZXF1aXJlKFwiLi9zZXQtcHJvdG90eXBlLW9mL2lzLWltcGxlbWVudGVkXCIpKCkpIHtcblx0c2hpbSA9IHJlcXVpcmUoXCIuL3NldC1wcm90b3R5cGUtb2Yvc2hpbVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgbnVsbE9iamVjdCwgcG9seVByb3BzLCBkZXNjO1xuXHRpZiAoIXNoaW0pIHJldHVybiBjcmVhdGU7XG5cdGlmIChzaGltLmxldmVsICE9PSAxKSByZXR1cm4gY3JlYXRlO1xuXG5cdG51bGxPYmplY3QgPSB7fTtcblx0cG9seVByb3BzID0ge307XG5cdGRlc2MgPSB7XG5cdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHR2YWx1ZTogdW5kZWZpbmVkXG5cdH07XG5cdE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIikge1xuXHRcdFx0cG9seVByb3BzW25hbWVdID0ge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHVuZGVmaW5lZFxuXHRcdFx0fTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cG9seVByb3BzW25hbWVdID0gZGVzYztcblx0fSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG51bGxPYmplY3QsIHBvbHlQcm9wcyk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHNoaW0sIFwibnVsbFBvbHlmaWxsXCIsIHtcblx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHR2YWx1ZTogbnVsbE9iamVjdFxuXHR9KTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcHMpIHtcblx0XHRyZXR1cm4gY3JlYXRlKHByb3RvdHlwZSA9PT0gbnVsbCA/IG51bGxPYmplY3QgOiBwcm90b3R5cGUsIHByb3BzKTtcblx0fTtcbn0oKSk7XG5cbn0se1wiLi9zZXQtcHJvdG90eXBlLW9mL2lzLWltcGxlbWVudGVkXCI6NTIsXCIuL3NldC1wcm90b3R5cGUtb2Yvc2hpbVwiOjUzfV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vX2l0ZXJhdGVcIikoXCJmb3JFYWNoXCIpO1xuXG59LHtcIi4vX2l0ZXJhdGVcIjozNX1dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIERlcHJlY2F0ZWRcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG59LHt9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgPSByZXF1aXJlKFwiLi9pcy12YWx1ZVwiKTtcblxudmFyIG1hcCA9IHsgZnVuY3Rpb246IHRydWUsIG9iamVjdDogdHJ1ZSB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gKGlzVmFsdWUodmFsdWUpICYmIG1hcFt0eXBlb2YgdmFsdWVdKSB8fCBmYWxzZTtcbn07XG5cbn0se1wiLi9pcy12YWx1ZVwiOjQ0fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdW5kZWZpbmVkID0gcmVxdWlyZShcIi4uL2Z1bmN0aW9uL25vb3BcIikoKTsgLy8gU3VwcG9ydCBFUzMgZW5naW5lc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwpIHtcbiByZXR1cm4gKHZhbCAhPT0gX3VuZGVmaW5lZCkgJiYgKHZhbCAhPT0gbnVsbCk7XG59O1xuXG59LHtcIi4uL2Z1bmN0aW9uL25vb3BcIjoyNn1dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBPYmplY3Qua2V5cyA6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG5cbn0se1wiLi9pcy1pbXBsZW1lbnRlZFwiOjQ2LFwiLi9zaGltXCI6NDd9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmtleXMoXCJwcmltaXRpdmVcIik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbn0se31dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuLi9pcy12YWx1ZVwiKTtcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBrZXlzKGlzVmFsdWUob2JqZWN0KSA/IE9iamVjdChvYmplY3QpIDogb2JqZWN0KTsgfTtcblxufSx7XCIuLi9pcy12YWx1ZVwiOjQ0fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjYWxsYWJsZSA9IHJlcXVpcmUoXCIuL3ZhbGlkLWNhbGxhYmxlXCIpXG4gICwgZm9yRWFjaCAgPSByZXF1aXJlKFwiLi9mb3ItZWFjaFwiKVxuICAsIGNhbGwgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgY2IgLyosIHRoaXNBcmcqLykge1xuXHR2YXIgcmVzdWx0ID0ge30sIHRoaXNBcmcgPSBhcmd1bWVudHNbMl07XG5cdGNhbGxhYmxlKGNiKTtcblx0Zm9yRWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5LCB0YXJnZXRPYmosIGluZGV4KSB7XG5cdFx0cmVzdWx0W2tleV0gPSBjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHZhbHVlLCBrZXksIHRhcmdldE9iaiwgaW5kZXgpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbn0se1wiLi9mb3ItZWFjaFwiOjQxLFwiLi92YWxpZC1jYWxsYWJsZVwiOjU0fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlID0gcmVxdWlyZShcIi4vaXMtdmFsdWVcIik7XG5cbnZhciBmb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbnZhciBwcm9jZXNzID0gZnVuY3Rpb24gKHNyYywgb2JqKSB7XG5cdHZhciBrZXk7XG5cdGZvciAoa2V5IGluIHNyYykgb2JqW2tleV0gPSBzcmNba2V5XTtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0czEgLyosIOKApm9wdGlvbnMqLykge1xuXHR2YXIgcmVzdWx0ID0gY3JlYXRlKG51bGwpO1xuXHRmb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdGlmICghaXNWYWx1ZShvcHRpb25zKSkgcmV0dXJuO1xuXHRcdHByb2Nlc3MoT2JqZWN0KG9wdGlvbnMpLCByZXN1bHQpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbn0se1wiLi9pcy12YWx1ZVwiOjQ0fV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJnIC8qLCDigKZhcmdzKi8pIHtcblx0dmFyIHNldCA9IGNyZWF0ZShudWxsKTtcblx0Zm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRzZXRbbmFtZV0gPSB0cnVlO1xuXHR9KTtcblx0cmV0dXJuIHNldDtcbn07XG5cbn0se31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKClcblx0PyBPYmplY3Quc2V0UHJvdG90eXBlT2Zcblx0OiByZXF1aXJlKFwiLi9zaGltXCIpO1xuXG59LHtcIi4vaXMtaW1wbGVtZW50ZWRcIjo1MixcIi4vc2hpbVwiOjUzfV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgcGxhaW5PYmplY3QgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLyogQ3VzdG9tQ3JlYXRlKi8pIHtcblx0dmFyIHNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mLCBjdXN0b21DcmVhdGUgPSBhcmd1bWVudHNbMF0gfHwgY3JlYXRlO1xuXHRpZiAodHlwZW9mIHNldFByb3RvdHlwZU9mICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIGdldFByb3RvdHlwZU9mKHNldFByb3RvdHlwZU9mKGN1c3RvbUNyZWF0ZShudWxsKSwgcGxhaW5PYmplY3QpKSA9PT0gcGxhaW5PYmplY3Q7XG59O1xuXG59LHt9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBlc2xpbnQgbm8tcHJvdG86IFwib2ZmXCIgKi9cblxuLy8gQmlnIHRoYW5rcyB0byBAV2ViUmVmbGVjdGlvbiBmb3Igc29ydGluZyB0aGlzIG91dFxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi81NTkzNTU0XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPYmplY3QgICAgICAgID0gcmVxdWlyZShcIi4uL2lzLW9iamVjdFwiKVxuICAsIHZhbHVlICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi92YWxpZC12YWx1ZVwiKVxuICAsIG9iaklzUHJvdG90eXBlT2YgPSBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2ZcbiAgLCBkZWZpbmVQcm9wZXJ0eSAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBudWxsRGVzYyAgICAgICAgPSB7XG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdHdyaXRhYmxlOiB0cnVlLFxuXHR2YWx1ZTogdW5kZWZpbmVkXG59XG4gICwgdmFsaWRhdGU7XG5cbnZhbGlkYXRlID0gZnVuY3Rpb24gKG9iaiwgcHJvdG90eXBlKSB7XG5cdHZhbHVlKG9iaik7XG5cdGlmIChwcm90b3R5cGUgPT09IG51bGwgfHwgaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIG9iajtcblx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb3RvdHlwZSBtdXN0IGJlIG51bGwgb3IgYW4gb2JqZWN0XCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKHN0YXR1cykge1xuXHR2YXIgZm4sIHNldDtcblx0aWYgKCFzdGF0dXMpIHJldHVybiBudWxsO1xuXHRpZiAoc3RhdHVzLmxldmVsID09PSAyKSB7XG5cdFx0aWYgKHN0YXR1cy5zZXQpIHtcblx0XHRcdHNldCA9IHN0YXR1cy5zZXQ7XG5cdFx0XHRmbiA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0XHRzZXQuY2FsbCh2YWxpZGF0ZShvYmosIHByb3RvdHlwZSksIHByb3RvdHlwZSk7XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmbiA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0XHR2YWxpZGF0ZShvYmosIHByb3RvdHlwZSkuX19wcm90b19fID0gcHJvdG90eXBlO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm4gPSBmdW5jdGlvbiBzZWxmKG9iaiwgcHJvdG90eXBlKSB7XG5cdFx0XHR2YXIgaXNOdWxsQmFzZTtcblx0XHRcdHZhbGlkYXRlKG9iaiwgcHJvdG90eXBlKTtcblx0XHRcdGlzTnVsbEJhc2UgPSBvYmpJc1Byb3RvdHlwZU9mLmNhbGwoc2VsZi5udWxsUG9seWZpbGwsIG9iaik7XG5cdFx0XHRpZiAoaXNOdWxsQmFzZSkgZGVsZXRlIHNlbGYubnVsbFBvbHlmaWxsLl9fcHJvdG9fXztcblx0XHRcdGlmIChwcm90b3R5cGUgPT09IG51bGwpIHByb3RvdHlwZSA9IHNlbGYubnVsbFBvbHlmaWxsO1xuXHRcdFx0b2JqLl9fcHJvdG9fXyA9IHByb3RvdHlwZTtcblx0XHRcdGlmIChpc051bGxCYXNlKSBkZWZpbmVQcm9wZXJ0eShzZWxmLm51bGxQb2x5ZmlsbCwgXCJfX3Byb3RvX19cIiwgbnVsbERlc2MpO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9O1xuXHR9XG5cdHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIFwibGV2ZWxcIiwge1xuXHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdHZhbHVlOiBzdGF0dXMubGV2ZWxcblx0fSk7XG59KFxuXHQoZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0bXBPYmoxID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXHRcdCAgLCB0bXBPYmoyID0ge31cblx0XHQgICwgc2V0XG5cdFx0ICAsIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsIFwiX19wcm90b19fXCIpO1xuXG5cdFx0aWYgKGRlc2MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHNldCA9IGRlc2Muc2V0OyAvLyBPcGVyYSBjcmFzaGVzIGF0IHRoaXMgcG9pbnRcblx0XHRcdFx0c2V0LmNhbGwodG1wT2JqMSwgdG1wT2JqMik7XG5cdFx0XHR9IGNhdGNoIChpZ25vcmUpIHt9XG5cdFx0XHRpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRtcE9iajEpID09PSB0bXBPYmoyKSByZXR1cm4geyBzZXQ6IHNldCwgbGV2ZWw6IDIgfTtcblx0XHR9XG5cblx0XHR0bXBPYmoxLl9fcHJvdG9fXyA9IHRtcE9iajI7XG5cdFx0aWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0bXBPYmoxKSA9PT0gdG1wT2JqMikgcmV0dXJuIHsgbGV2ZWw6IDIgfTtcblxuXHRcdHRtcE9iajEgPSB7fTtcblx0XHR0bXBPYmoxLl9fcHJvdG9fXyA9IHRtcE9iajI7XG5cdFx0aWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0bXBPYmoxKSA9PT0gdG1wT2JqMikgcmV0dXJuIHsgbGV2ZWw6IDEgfTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSkoKVxuKSk7XG5cbnJlcXVpcmUoXCIuLi9jcmVhdGVcIik7XG5cbn0se1wiLi4vY3JlYXRlXCI6NDAsXCIuLi9pcy1vYmplY3RcIjo0MyxcIi4uL3ZhbGlkLXZhbHVlXCI6NTV9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG5cdHJldHVybiBmbjtcbn07XG5cbn0se31dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuL2lzLXZhbHVlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzVmFsdWUodmFsdWUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSBudWxsIG9yIHVuZGVmaW5lZFwiKTtcblx0cmV0dXJuIHZhbHVlO1xufTtcblxufSx7XCIuL2lzLXZhbHVlXCI6NDR9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpXG5cdD8gU3RyaW5nLnByb3RvdHlwZS5jb250YWluc1xuXHQ6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG5cbn0se1wiLi9pcy1pbXBsZW1lbnRlZFwiOjU3LFwiLi9zaGltXCI6NTh9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHN0ciA9IFwicmF6ZHdhdHJ6eVwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHR5cGVvZiBzdHIuY29udGFpbnMgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gKHN0ci5jb250YWlucyhcImR3YVwiKSA9PT0gdHJ1ZSkgJiYgKHN0ci5jb250YWlucyhcImZvb1wiKSA9PT0gZmFsc2UpO1xufTtcblxufSx7fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbmRleE9mID0gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcvKiwgcG9zaXRpb24qLykge1xuXHRyZXR1cm4gaW5kZXhPZi5jYWxsKHRoaXMsIHNlYXJjaFN0cmluZywgYXJndW1lbnRzWzFdKSA+IC0xO1xufTtcblxufSx7fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsIGlkID0gb2JqVG9TdHJpbmcuY2FsbChcIlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHxcblx0XHQodmFsdWUgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuXHRcdFx0KHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBpZCkpIHx8XG5cdFx0ZmFsc2Vcblx0KTtcbn07XG5cbn0se31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKVxuICAsIGNvbnRhaW5zICAgICAgID0gcmVxdWlyZShcImVzNS1leHQvc3RyaW5nLyMvY29udGFpbnNcIilcbiAgLCBkICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJkXCIpXG4gICwgU3ltYm9sICAgICAgICAgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKVxuICAsIEl0ZXJhdG9yICAgICAgID0gcmVxdWlyZShcIi4vXCIpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIEFycmF5SXRlcmF0b3I7XG5cbkFycmF5SXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnIsIGtpbmQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEFycmF5SXRlcmF0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ29uc3RydWN0b3IgcmVxdWlyZXMgJ25ldydcIik7XG5cdEl0ZXJhdG9yLmNhbGwodGhpcywgYXJyKTtcblx0aWYgKCFraW5kKSBraW5kID0gXCJ2YWx1ZVwiO1xuXHRlbHNlIGlmIChjb250YWlucy5jYWxsKGtpbmQsIFwia2V5K3ZhbHVlXCIpKSBraW5kID0gXCJrZXkrdmFsdWVcIjtcblx0ZWxzZSBpZiAoY29udGFpbnMuY2FsbChraW5kLCBcImtleVwiKSkga2luZCA9IFwia2V5XCI7XG5cdGVsc2Uga2luZCA9IFwidmFsdWVcIjtcblx0ZGVmaW5lUHJvcGVydHkodGhpcywgXCJfX2tpbmRfX1wiLCBkKFwiXCIsIGtpbmQpKTtcbn07XG5pZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKEFycmF5SXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuLy8gSW50ZXJuYWwgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlIGRvZXNuJ3QgZXhwb3NlIGl0cyBjb25zdHJ1Y3RvclxuZGVsZXRlIEFycmF5SXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5BcnJheUl0ZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3IucHJvdG90eXBlLCB7XG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09IFwidmFsdWVcIikgcmV0dXJuIHRoaXMuX19saXN0X19baV07XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09IFwia2V5K3ZhbHVlXCIpIHJldHVybiBbaSwgdGhpcy5fX2xpc3RfX1tpXV07XG5cdFx0cmV0dXJuIGk7XG5cdH0pXG59KTtcbmRlZmluZVByb3BlcnR5KEFycmF5SXRlcmF0b3IucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoXCJjXCIsIFwiQXJyYXkgSXRlcmF0b3JcIikpO1xuXG59LHtcIi4vXCI6NjMsXCJkXCI6MTYsXCJlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCI6NTEsXCJlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zXCI6NTYsXCJlczYtc3ltYm9sXCI6NzN9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZShcImVzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzXCIpXG4gICwgY2FsbGFibGUgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIilcbiAgLCBpc1N0cmluZyAgICA9IHJlcXVpcmUoXCJlczUtZXh0L3N0cmluZy9pcy1zdHJpbmdcIilcbiAgLCBnZXQgICAgICAgICA9IHJlcXVpcmUoXCIuL2dldFwiKTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5LCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGNiIC8qLCB0aGlzQXJnKi8pIHtcblx0dmFyIG1vZGUsIHRoaXNBcmcgPSBhcmd1bWVudHNbMl0sIHJlc3VsdCwgZG9CcmVhaywgYnJva2VuLCBpLCBsZW5ndGgsIGNoYXIsIGNvZGU7XG5cdGlmIChpc0FycmF5KGl0ZXJhYmxlKSB8fCBpc0FyZ3VtZW50cyhpdGVyYWJsZSkpIG1vZGUgPSBcImFycmF5XCI7XG5cdGVsc2UgaWYgKGlzU3RyaW5nKGl0ZXJhYmxlKSkgbW9kZSA9IFwic3RyaW5nXCI7XG5cdGVsc2UgaXRlcmFibGUgPSBnZXQoaXRlcmFibGUpO1xuXG5cdGNhbGxhYmxlKGNiKTtcblx0ZG9CcmVhayA9IGZ1bmN0aW9uICgpIHtcblx0XHRicm9rZW4gPSB0cnVlO1xuXHR9O1xuXHRpZiAobW9kZSA9PT0gXCJhcnJheVwiKSB7XG5cdFx0c29tZS5jYWxsKGl0ZXJhYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgdmFsdWUsIGRvQnJlYWspO1xuXHRcdFx0cmV0dXJuIGJyb2tlbjtcblx0XHR9KTtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKG1vZGUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRsZW5ndGggPSBpdGVyYWJsZS5sZW5ndGg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0XHRjaGFyID0gaXRlcmFibGVbaV07XG5cdFx0XHRpZiAoaSArIDEgPCBsZW5ndGgpIHtcblx0XHRcdFx0Y29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0aWYgKGNvZGUgPj0gMHhkODAwICYmIGNvZGUgPD0gMHhkYmZmKSBjaGFyICs9IGl0ZXJhYmxlWysraV07XG5cdFx0XHR9XG5cdFx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIGNoYXIsIGRvQnJlYWspO1xuXHRcdFx0aWYgKGJyb2tlbikgYnJlYWs7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXHRyZXN1bHQgPSBpdGVyYWJsZS5uZXh0KCk7XG5cblx0d2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuXHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgcmVzdWx0LnZhbHVlLCBkb0JyZWFrKTtcblx0XHRpZiAoYnJva2VuKSByZXR1cm47XG5cdFx0cmVzdWx0ID0gaXRlcmFibGUubmV4dCgpO1xuXHR9XG59O1xuXG59LHtcIi4vZ2V0XCI6NjIsXCJlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50c1wiOjI0LFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIjo1NCxcImVzNS1leHQvc3RyaW5nL2lzLXN0cmluZ1wiOjU5fV0sNjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0FyZ3VtZW50cyAgICA9IHJlcXVpcmUoXCJlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50c1wiKVxuICAsIGlzU3RyaW5nICAgICAgID0gcmVxdWlyZShcImVzNS1leHQvc3RyaW5nL2lzLXN0cmluZ1wiKVxuICAsIEFycmF5SXRlcmF0b3IgID0gcmVxdWlyZShcIi4vYXJyYXlcIilcbiAgLCBTdHJpbmdJdGVyYXRvciA9IHJlcXVpcmUoXCIuL3N0cmluZ1wiKVxuICAsIGl0ZXJhYmxlICAgICAgID0gcmVxdWlyZShcIi4vdmFsaWQtaXRlcmFibGVcIilcbiAgLCBpdGVyYXRvclN5bWJvbCA9IHJlcXVpcmUoXCJlczYtc3ltYm9sXCIpLml0ZXJhdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcblx0aWYgKHR5cGVvZiBpdGVyYWJsZShvYmopW2l0ZXJhdG9yU3ltYm9sXSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gb2JqW2l0ZXJhdG9yU3ltYm9sXSgpO1xuXHRpZiAoaXNBcmd1bWVudHMob2JqKSkgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKG9iaik7XG5cdGlmIChpc1N0cmluZyhvYmopKSByZXR1cm4gbmV3IFN0cmluZ0l0ZXJhdG9yKG9iaik7XG5cdHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihvYmopO1xufTtcblxufSx7XCIuL2FycmF5XCI6NjAsXCIuL3N0cmluZ1wiOjY1LFwiLi92YWxpZC1pdGVyYWJsZVwiOjY2LFwiZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIjoyNCxcImVzNS1leHQvc3RyaW5nL2lzLXN0cmluZ1wiOjU5LFwiZXM2LXN5bWJvbFwiOjczfV0sNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjbGVhciAgICA9IHJlcXVpcmUoXCJlczUtZXh0L2FycmF5LyMvY2xlYXJcIilcbiAgLCBhc3NpZ24gICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9hc3NpZ25cIilcbiAgLCBjYWxsYWJsZSA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZVwiKVxuICAsIHZhbHVlICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlXCIpXG4gICwgZCAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIGF1dG9CaW5kID0gcmVxdWlyZShcImQvYXV0by1iaW5kXCIpXG4gICwgU3ltYm9sICAgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsIEl0ZXJhdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZXJhdG9yID0gZnVuY3Rpb24gKGxpc3QsIGNvbnRleHQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEl0ZXJhdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9yIHJlcXVpcmVzICduZXcnXCIpO1xuXHRkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRfX2xpc3RfXzogZChcIndcIiwgdmFsdWUobGlzdCkpLFxuXHRcdF9fY29udGV4dF9fOiBkKFwid1wiLCBjb250ZXh0KSxcblx0XHRfX25leHRJbmRleF9fOiBkKFwid1wiLCAwKVxuXHR9KTtcblx0aWYgKCFjb250ZXh0KSByZXR1cm47XG5cdGNhbGxhYmxlKGNvbnRleHQub24pO1xuXHRjb250ZXh0Lm9uKFwiX2FkZFwiLCB0aGlzLl9vbkFkZCk7XG5cdGNvbnRleHQub24oXCJfZGVsZXRlXCIsIHRoaXMuX29uRGVsZXRlKTtcblx0Y29udGV4dC5vbihcIl9jbGVhclwiLCB0aGlzLl9vbkNsZWFyKTtcbn07XG5cbi8vIEludGVybmFsICVJdGVyYXRvclByb3RvdHlwZSUgZG9lc24ndCBleHBvc2UgaXRzIGNvbnN0cnVjdG9yXG5kZWxldGUgSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5kZWZpbmVQcm9wZXJ0aWVzKFxuXHRJdGVyYXRvci5wcm90b3R5cGUsXG5cdGFzc2lnbihcblx0XHR7XG5cdFx0XHRfbmV4dDogZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX19saXN0X18pIHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVkb19fKSB7XG5cdFx0XHRcdFx0aSA9IHRoaXMuX19yZWRvX18uc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAoaSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fX25leHRJbmRleF9fIDwgdGhpcy5fX2xpc3RfXy5sZW5ndGgpIHJldHVybiB0aGlzLl9fbmV4dEluZGV4X18rKztcblx0XHRcdFx0dGhpcy5fdW5CaW5kKCk7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9KSxcblx0XHRcdG5leHQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlUmVzdWx0KHRoaXMuX25leHQoKSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGVSZXN1bHQ6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0aWYgKGkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuXHRcdFx0XHRyZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMuX3Jlc29sdmUoaSkgfTtcblx0XHRcdH0pLFxuXHRcdFx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX19saXN0X19baV07XG5cdFx0XHR9KSxcblx0XHRcdF91bkJpbmQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLl9fbGlzdF9fID0gbnVsbDtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX19yZWRvX187XG5cdFx0XHRcdGlmICghdGhpcy5fX2NvbnRleHRfXykgcmV0dXJuO1xuXHRcdFx0XHR0aGlzLl9fY29udGV4dF9fLm9mZihcIl9hZGRcIiwgdGhpcy5fb25BZGQpO1xuXHRcdFx0XHR0aGlzLl9fY29udGV4dF9fLm9mZihcIl9kZWxldGVcIiwgdGhpcy5fb25EZWxldGUpO1xuXHRcdFx0XHR0aGlzLl9fY29udGV4dF9fLm9mZihcIl9jbGVhclwiLCB0aGlzLl9vbkNsZWFyKTtcblx0XHRcdFx0dGhpcy5fX2NvbnRleHRfXyA9IG51bGw7XG5cdFx0XHR9KSxcblx0XHRcdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIFwiW29iamVjdCBcIiArICh0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgXCJPYmplY3RcIikgKyBcIl1cIjtcblx0XHRcdH0pXG5cdFx0fSxcblx0XHRhdXRvQmluZCh7XG5cdFx0XHRfb25BZGQ6IGQoZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRcdGlmIChpbmRleCA+PSB0aGlzLl9fbmV4dEluZGV4X18pIHJldHVybjtcblx0XHRcdFx0Kyt0aGlzLl9fbmV4dEluZGV4X187XG5cdFx0XHRcdGlmICghdGhpcy5fX3JlZG9fXykge1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX19yZWRvX19cIiwgZChcImNcIiwgW2luZGV4XSkpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9fcmVkb19fLmZvckVhY2goZnVuY3Rpb24gKHJlZG8sIGkpIHtcblx0XHRcdFx0XHRpZiAocmVkbyA+PSBpbmRleCkgdGhpcy5fX3JlZG9fX1tpXSA9ICsrcmVkbztcblx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRcdHRoaXMuX19yZWRvX18ucHVzaChpbmRleCk7XG5cdFx0XHR9KSxcblx0XHRcdF9vbkRlbGV0ZTogZChmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRcdFx0dmFyIGk7XG5cdFx0XHRcdGlmIChpbmRleCA+PSB0aGlzLl9fbmV4dEluZGV4X18pIHJldHVybjtcblx0XHRcdFx0LS10aGlzLl9fbmV4dEluZGV4X187XG5cdFx0XHRcdGlmICghdGhpcy5fX3JlZG9fXykgcmV0dXJuO1xuXHRcdFx0XHRpID0gdGhpcy5fX3JlZG9fXy5pbmRleE9mKGluZGV4KTtcblx0XHRcdFx0aWYgKGkgIT09IC0xKSB0aGlzLl9fcmVkb19fLnNwbGljZShpLCAxKTtcblx0XHRcdFx0dGhpcy5fX3JlZG9fXy5mb3JFYWNoKGZ1bmN0aW9uIChyZWRvLCBqKSB7XG5cdFx0XHRcdFx0aWYgKHJlZG8gPiBpbmRleCkgdGhpcy5fX3JlZG9fX1tqXSA9IC0tcmVkbztcblx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHR9KSxcblx0XHRcdF9vbkNsZWFyOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX19yZWRvX18pIGNsZWFyLmNhbGwodGhpcy5fX3JlZG9fXyk7XG5cdFx0XHRcdHRoaXMuX19uZXh0SW5kZXhfXyA9IDA7XG5cdFx0XHR9KVxuXHRcdH0pXG5cdClcbik7XG5cbmRlZmluZVByb3BlcnR5KFxuXHRJdGVyYXRvci5wcm90b3R5cGUsXG5cdFN5bWJvbC5pdGVyYXRvcixcblx0ZChmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0pXG4pO1xuXG59LHtcImRcIjoxNixcImQvYXV0by1iaW5kXCI6MTUsXCJlczUtZXh0L2FycmF5LyMvY2xlYXJcIjoxOSxcImVzNS1leHQvb2JqZWN0L2Fzc2lnblwiOjM2LFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIjo1NCxcImVzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlXCI6NTUsXCJlczYtc3ltYm9sXCI6NzN9XSw2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZShcImVzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzXCIpXG4gICwgaXNWYWx1ZSAgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvaXMtdmFsdWVcIilcbiAgLCBpc1N0cmluZyAgICA9IHJlcXVpcmUoXCJlczUtZXh0L3N0cmluZy9pcy1zdHJpbmdcIik7XG5cbnZhciBpdGVyYXRvclN5bWJvbCA9IHJlcXVpcmUoXCJlczYtc3ltYm9sXCIpLml0ZXJhdG9yXG4gICwgaXNBcnJheSAgICAgICAgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzVmFsdWUodmFsdWUpKSByZXR1cm4gZmFsc2U7XG5cdGlmIChpc0FycmF5KHZhbHVlKSkgcmV0dXJuIHRydWU7XG5cdGlmIChpc1N0cmluZyh2YWx1ZSkpIHJldHVybiB0cnVlO1xuXHRpZiAoaXNBcmd1bWVudHModmFsdWUpKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZVtpdGVyYXRvclN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIjtcbn07XG5cbn0se1wiZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIjoyNCxcImVzNS1leHQvb2JqZWN0L2lzLXZhbHVlXCI6NDQsXCJlczUtZXh0L3N0cmluZy9pcy1zdHJpbmdcIjo1OSxcImVzNi1zeW1ib2xcIjo3M31dLDY1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIFRoYW5rcyBAbWF0aGlhc2J5bmVuc1xuLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlI2l0ZXJhdGluZy1vdmVyLXN5bWJvbHNcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpXG4gICwgZCAgICAgICAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIFN5bWJvbCAgICAgICAgID0gcmVxdWlyZShcImVzNi1zeW1ib2xcIilcbiAgLCBJdGVyYXRvciAgICAgICA9IHJlcXVpcmUoXCIuL1wiKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBTdHJpbmdJdGVyYXRvcjtcblxuU3RyaW5nSXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmluZ0l0ZXJhdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9yIHJlcXVpcmVzICduZXcnXCIpO1xuXHRzdHIgPSBTdHJpbmcoc3RyKTtcblx0SXRlcmF0b3IuY2FsbCh0aGlzLCBzdHIpO1xuXHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9fbGVuZ3RoX19cIiwgZChcIlwiLCBzdHIubGVuZ3RoKSk7XG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihTdHJpbmdJdGVyYXRvciwgSXRlcmF0b3IpO1xuXG4vLyBJbnRlcm5hbCAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUgZG9lc24ndCBleHBvc2UgaXRzIGNvbnN0cnVjdG9yXG5kZWxldGUgU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5TdHJpbmdJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yLnByb3RvdHlwZSwge1xuXHRfbmV4dDogZChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9fbGlzdF9fKSByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPCB0aGlzLl9fbGVuZ3RoX18pIHJldHVybiB0aGlzLl9fbmV4dEluZGV4X18rKztcblx0XHR0aGlzLl91bkJpbmQoKTtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9KSxcblx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHR2YXIgY2hhciA9IHRoaXMuX19saXN0X19baV0sIGNvZGU7XG5cdFx0aWYgKHRoaXMuX19uZXh0SW5kZXhfXyA9PT0gdGhpcy5fX2xlbmd0aF9fKSByZXR1cm4gY2hhcjtcblx0XHRjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXHRcdGlmIChjb2RlID49IDB4ZDgwMCAmJiBjb2RlIDw9IDB4ZGJmZikgcmV0dXJuIGNoYXIgKyB0aGlzLl9fbGlzdF9fW3RoaXMuX19uZXh0SW5kZXhfXysrXTtcblx0XHRyZXR1cm4gY2hhcjtcblx0fSlcbn0pO1xuZGVmaW5lUHJvcGVydHkoU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoXCJjXCIsIFwiU3RyaW5nIEl0ZXJhdG9yXCIpKTtcblxufSx7XCIuL1wiOjYzLFwiZFwiOjE2LFwiZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiOjUxLFwiZXM2LXN5bWJvbFwiOjczfV0sNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0l0ZXJhYmxlID0gcmVxdWlyZShcIi4vaXMtaXRlcmFibGVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNJdGVyYWJsZSh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbn0se1wiLi9pcy1pdGVyYWJsZVwiOjY0fV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpID8gTWFwIDogcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG59LHtcIi4vaXMtaW1wbGVtZW50ZWRcIjo2OCxcIi4vcG9seWZpbGxcIjo3Mn1dLDY4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBtYXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG5cdGlmICh0eXBlb2YgTWFwICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHRyeSB7XG5cdFx0Ly8gV2ViS2l0IGRvZXNuJ3Qgc3VwcG9ydCBhcmd1bWVudHMgYW5kIGNyYXNoZXNcblx0XHRtYXAgPSBuZXcgTWFwKFtbJ3JheicsICdvbmUnXSwgWydkd2EnLCAndHdvJ10sIFsndHJ6eScsICd0aHJlZSddXSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKFN0cmluZyhtYXApICE9PSAnW29iamVjdCBNYXBdJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAobWFwLnNpemUgIT09IDMpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuY2xlYXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZGVsZXRlICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmVudHJpZXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5nZXQgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuaGFzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmtleXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuc2V0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLnZhbHVlcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG5cdGl0ZXJhdG9yID0gbWFwLmVudHJpZXMoKTtcblx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRpZiAocmVzdWx0LmRvbmUgIT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cdGlmICghcmVzdWx0LnZhbHVlKSByZXR1cm4gZmFsc2U7XG5cdGlmIChyZXN1bHQudmFsdWVbMF0gIT09ICdyYXonKSByZXR1cm4gZmFsc2U7XG5cdGlmIChyZXN1bHQudmFsdWVbMV0gIT09ICdvbmUnKSByZXR1cm4gZmFsc2U7XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG59LHt9XSw2OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBFeHBvcnRzIHRydWUgaWYgZW52aXJvbm1lbnQgcHJvdmlkZXMgbmF0aXZlIGBNYXBgIGltcGxlbWVudGF0aW9uLFxuLy8gd2hhdGV2ZXIgdGhhdCBpcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgTWFwKCkpID09PSAnW29iamVjdCBNYXBdJyk7XG59KCkpO1xuXG59LHt9XSw3MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvcHJpbWl0aXZlLXNldCcpKCdrZXknLFxuXHQndmFsdWUnLCAna2V5K3ZhbHVlJyk7XG5cbn0se1wiZXM1LWV4dC9vYmplY3QvcHJpbWl0aXZlLXNldFwiOjUwfV0sNzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIEl0ZXJhdG9yICAgICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yJylcbiAgLCB0b1N0cmluZ1RhZ1N5bWJvbCA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKS50b1N0cmluZ1RhZ1xuICAsIGtpbmRzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9pdGVyYXRvci1raW5kcycpXG5cbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCB1bkJpbmQgPSBJdGVyYXRvci5wcm90b3R5cGUuX3VuQmluZFxuICAsIE1hcEl0ZXJhdG9yO1xuXG5NYXBJdGVyYXRvciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hcCwga2luZCkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFwSXRlcmF0b3IpKSByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKG1hcCwga2luZCk7XG5cdEl0ZXJhdG9yLmNhbGwodGhpcywgbWFwLl9fbWFwS2V5c0RhdGFfXywgbWFwKTtcblx0aWYgKCFraW5kIHx8ICFraW5kc1traW5kXSkga2luZCA9ICdrZXkrdmFsdWUnO1xuXHRkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRfX2tpbmRfXzogZCgnJywga2luZCksXG5cdFx0X192YWx1ZXNfXzogZCgndycsIG1hcC5fX21hcFZhbHVlc0RhdGFfXylcblx0fSk7XG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihNYXBJdGVyYXRvciwgSXRlcmF0b3IpO1xuXG5NYXBJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yLnByb3RvdHlwZSwge1xuXHRjb25zdHJ1Y3RvcjogZChNYXBJdGVyYXRvciksXG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09ICd2YWx1ZScpIHJldHVybiB0aGlzLl9fdmFsdWVzX19baV07XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09ICdrZXknKSByZXR1cm4gdGhpcy5fX2xpc3RfX1tpXTtcblx0XHRyZXR1cm4gW3RoaXMuX19saXN0X19baV0sIHRoaXMuX192YWx1ZXNfX1tpXV07XG5cdH0pLFxuXHRfdW5CaW5kOiBkKGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9fdmFsdWVzX18gPSBudWxsO1xuXHRcdHVuQmluZC5jYWxsKHRoaXMpO1xuXHR9KSxcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7IH0pXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBJdGVyYXRvci5wcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLFxuXHRkKCdjJywgJ01hcCBJdGVyYXRvcicpKTtcblxufSx7XCIuL2l0ZXJhdG9yLWtpbmRzXCI6NzAsXCJkXCI6MTYsXCJlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCI6NTEsXCJlczYtaXRlcmF0b3JcIjo2MyxcImVzNi1zeW1ib2xcIjo3M31dLDcyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGNsZWFyICAgICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9hcnJheS8jL2NsZWFyJylcbiAgLCBlSW5kZXhPZiAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvYXJyYXkvIy9lLWluZGV4LW9mJylcbiAgLCBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YnKVxuICAsIGNhbGxhYmxlICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuICAsIHZhbGlkVmFsdWUgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWUnKVxuICAsIGQgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgZWUgICAgICAgICAgICAgPSByZXF1aXJlKCdldmVudC1lbWl0dGVyJylcbiAgLCBTeW1ib2wgICAgICAgICA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKVxuICAsIGl0ZXJhdG9yICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yL3ZhbGlkLWl0ZXJhYmxlJylcbiAgLCBmb3JPZiAgICAgICAgICA9IHJlcXVpcmUoJ2VzNi1pdGVyYXRvci9mb3Itb2YnKVxuICAsIEl0ZXJhdG9yICAgICAgID0gcmVxdWlyZSgnLi9saWIvaXRlcmF0b3InKVxuICAsIGlzTmF0aXZlICAgICAgID0gcmVxdWlyZSgnLi9pcy1uYXRpdmUtaW1wbGVtZW50ZWQnKVxuXG4gICwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICAsIE1hcFBvbHk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwUG9seSA9IGZ1bmN0aW9uICgvKml0ZXJhYmxlKi8pIHtcblx0dmFyIGl0ZXJhYmxlID0gYXJndW1lbnRzWzBdLCBrZXlzLCB2YWx1ZXMsIHNlbGY7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXBQb2x5KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgcmVxdWlyZXMgXFwnbmV3XFwnJyk7XG5cdGlmIChpc05hdGl2ZSAmJiBzZXRQcm90b3R5cGVPZiAmJiAoTWFwICE9PSBNYXBQb2x5KSkge1xuXHRcdHNlbGYgPSBzZXRQcm90b3R5cGVPZihuZXcgTWFwKCksIGdldFByb3RvdHlwZU9mKHRoaXMpKTtcblx0fSBlbHNlIHtcblx0XHRzZWxmID0gdGhpcztcblx0fVxuXHRpZiAoaXRlcmFibGUgIT0gbnVsbCkgaXRlcmF0b3IoaXRlcmFibGUpO1xuXHRkZWZpbmVQcm9wZXJ0aWVzKHNlbGYsIHtcblx0XHRfX21hcEtleXNEYXRhX186IGQoJ2MnLCBrZXlzID0gW10pLFxuXHRcdF9fbWFwVmFsdWVzRGF0YV9fOiBkKCdjJywgdmFsdWVzID0gW10pXG5cdH0pO1xuXHRpZiAoIWl0ZXJhYmxlKSByZXR1cm4gc2VsZjtcblx0Zm9yT2YoaXRlcmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHZhciBrZXkgPSB2YWxpZFZhbHVlKHZhbHVlKVswXTtcblx0XHR2YWx1ZSA9IHZhbHVlWzFdO1xuXHRcdGlmIChlSW5kZXhPZi5jYWxsKGtleXMsIGtleSkgIT09IC0xKSByZXR1cm47XG5cdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0dmFsdWVzLnB1c2godmFsdWUpO1xuXHR9LCBzZWxmKTtcblx0cmV0dXJuIHNlbGY7XG59O1xuXG5pZiAoaXNOYXRpdmUpIHtcblx0aWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihNYXBQb2x5LCBNYXApO1xuXHRNYXBQb2x5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTWFwLnByb3RvdHlwZSwge1xuXHRcdGNvbnN0cnVjdG9yOiBkKE1hcFBvbHkpXG5cdH0pO1xufVxuXG5lZShkZWZpbmVQcm9wZXJ0aWVzKE1hcFBvbHkucHJvdG90eXBlLCB7XG5cdGNsZWFyOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX19tYXBLZXlzRGF0YV9fLmxlbmd0aCkgcmV0dXJuO1xuXHRcdGNsZWFyLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18pO1xuXHRcdGNsZWFyLmNhbGwodGhpcy5fX21hcFZhbHVlc0RhdGFfXyk7XG5cdFx0dGhpcy5lbWl0KCdfY2xlYXInKTtcblx0fSksXG5cdGRlbGV0ZTogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGluZGV4ID0gZUluZGV4T2YuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXywga2V5KTtcblx0XHRpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cdFx0dGhpcy5fX21hcEtleXNEYXRhX18uc3BsaWNlKGluZGV4LCAxKTtcblx0XHR0aGlzLl9fbWFwVmFsdWVzRGF0YV9fLnNwbGljZShpbmRleCwgMSk7XG5cdFx0dGhpcy5lbWl0KCdfZGVsZXRlJywgaW5kZXgsIGtleSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0pLFxuXHRlbnRyaWVzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJyk7IH0pLFxuXHRmb3JFYWNoOiBkKGZ1bmN0aW9uIChjYi8qLCB0aGlzQXJnKi8pIHtcblx0XHR2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXSwgaXRlcmF0b3IsIHJlc3VsdDtcblx0XHRjYWxsYWJsZShjYik7XG5cdFx0aXRlcmF0b3IgPSB0aGlzLmVudHJpZXMoKTtcblx0XHRyZXN1bHQgPSBpdGVyYXRvci5fbmV4dCgpO1xuXHRcdHdoaWxlIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCB0aGlzLl9fbWFwVmFsdWVzRGF0YV9fW3Jlc3VsdF0sXG5cdFx0XHRcdHRoaXMuX19tYXBLZXlzRGF0YV9fW3Jlc3VsdF0sIHRoaXMpO1xuXHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IuX25leHQoKTtcblx0XHR9XG5cdH0pLFxuXHRnZXQ6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBpbmRleCA9IGVJbmRleE9mLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18sIGtleSk7XG5cdFx0aWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuXHRcdHJldHVybiB0aGlzLl9fbWFwVmFsdWVzRGF0YV9fW2luZGV4XTtcblx0fSksXG5cdGhhczogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIChlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpICE9PSAtMSk7XG5cdH0pLFxuXHRrZXlzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzLCAna2V5Jyk7IH0pLFxuXHRzZXQ6IGQoZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHR2YXIgaW5kZXggPSBlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpLCBlbWl0O1xuXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdGluZGV4ID0gdGhpcy5fX21hcEtleXNEYXRhX18ucHVzaChrZXkpIC0gMTtcblx0XHRcdGVtaXQgPSB0cnVlO1xuXHRcdH1cblx0XHR0aGlzLl9fbWFwVmFsdWVzRGF0YV9fW2luZGV4XSA9IHZhbHVlO1xuXHRcdGlmIChlbWl0KSB0aGlzLmVtaXQoJ19hZGQnLCBpbmRleCwga2V5KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSksXG5cdHNpemU6IGQuZ3MoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fX21hcEtleXNEYXRhX18ubGVuZ3RoOyB9KSxcblx0dmFsdWVzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzLCAndmFsdWUnKTsgfSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IE1hcF0nOyB9KVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFBvbHkucHJvdG90eXBlLCBTeW1ib2wuaXRlcmF0b3IsIGQoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwUG9seS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywgZCgnYycsICdNYXAnKSk7XG5cbn0se1wiLi9pcy1uYXRpdmUtaW1wbGVtZW50ZWRcIjo2OSxcIi4vbGliL2l0ZXJhdG9yXCI6NzEsXCJkXCI6MTYsXCJlczUtZXh0L2FycmF5LyMvY2xlYXJcIjoxOSxcImVzNS1leHQvYXJyYXkvIy9lLWluZGV4LW9mXCI6MjAsXCJlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCI6NTEsXCJlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZVwiOjU0LFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWVcIjo1NSxcImVzNi1pdGVyYXRvci9mb3Itb2ZcIjo2MSxcImVzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZVwiOjY2LFwiZXM2LXN5bWJvbFwiOjczLFwiZXZlbnQtZW1pdHRlclwiOjc4fV0sNzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpID8gU3ltYm9sIDogcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG59LHtcIi4vaXMtaW1wbGVtZW50ZWRcIjo3NCxcIi4vcG9seWZpbGxcIjo3Nn1dLDc0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHZhbGlkVHlwZXMgPSB7IG9iamVjdDogdHJ1ZSwgc3ltYm9sOiB0cnVlIH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc3ltYm9sO1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRzeW1ib2wgPSBTeW1ib2woJ3Rlc3Qgc3ltYm9sJyk7XG5cdHRyeSB7IFN0cmluZyhzeW1ib2wpOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIFJldHVybiAndHJ1ZScgYWxzbyBmb3IgcG9seWZpbGxzXG5cdGlmICghdmFsaWRUeXBlc1t0eXBlb2YgU3ltYm9sLml0ZXJhdG9yXSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoIXZhbGlkVHlwZXNbdHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZV0pIHJldHVybiBmYWxzZTtcblx0aWYgKCF2YWxpZFR5cGVzW3R5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWddKSByZXR1cm4gZmFsc2U7XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG59LHt9XSw3NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgpIHtcblx0aWYgKCF4KSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgeCA9PT0gJ3N5bWJvbCcpIHJldHVybiB0cnVlO1xuXHRpZiAoIXguY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblx0aWYgKHguY29uc3RydWN0b3IubmFtZSAhPT0gJ1N5bWJvbCcpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuICh4W3guY29uc3RydWN0b3IudG9TdHJpbmdUYWddID09PSAnU3ltYm9sJyk7XG59O1xuXG59LHt9XSw3NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBFUzIwMTUgU3ltYm9sIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgKG9yIHBhcnRpYWxseSkgc3VwcG9ydCBpdFxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIHZhbGlkYXRlU3ltYm9sID0gcmVxdWlyZSgnLi92YWxpZGF0ZS1zeW1ib2wnKVxuXG4gICwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIG9ialByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGVcbiAgLCBOYXRpdmVTeW1ib2wsIFN5bWJvbFBvbHlmaWxsLCBIaWRkZW5TeW1ib2wsIGdsb2JhbFN5bWJvbHMgPSBjcmVhdGUobnVsbClcbiAgLCBpc05hdGl2ZVNhZmU7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdE5hdGl2ZVN5bWJvbCA9IFN5bWJvbDtcblx0dHJ5IHtcblx0XHRTdHJpbmcoTmF0aXZlU3ltYm9sKCkpO1xuXHRcdGlzTmF0aXZlU2FmZSA9IHRydWU7XG5cdH0gY2F0Y2ggKGlnbm9yZSkge31cbn1cblxudmFyIGdlbmVyYXRlTmFtZSA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciBjcmVhdGVkID0gY3JlYXRlKG51bGwpO1xuXHRyZXR1cm4gZnVuY3Rpb24gKGRlc2MpIHtcblx0XHR2YXIgcG9zdGZpeCA9IDAsIG5hbWUsIGllMTFCdWdXb3JrYXJvdW5kO1xuXHRcdHdoaWxlIChjcmVhdGVkW2Rlc2MgKyAocG9zdGZpeCB8fCAnJyldKSArK3Bvc3RmaXg7XG5cdFx0ZGVzYyArPSAocG9zdGZpeCB8fCAnJyk7XG5cdFx0Y3JlYXRlZFtkZXNjXSA9IHRydWU7XG5cdFx0bmFtZSA9ICdAQCcgKyBkZXNjO1xuXHRcdGRlZmluZVByb3BlcnR5KG9ialByb3RvdHlwZSwgbmFtZSwgZC5ncyhudWxsLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdC8vIEZvciBJRTExIGlzc3VlIHNlZTpcblx0XHRcdC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrZGV0YWlsL3ZpZXcvMTkyODUwOC9cblx0XHRcdC8vICAgIGllMTEtYnJva2VuLWdldHRlcnMtb24tZG9tLW9iamVjdHNcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpa29vL2VzNi1zeW1ib2wvaXNzdWVzLzEyXG5cdFx0XHRpZiAoaWUxMUJ1Z1dvcmthcm91bmQpIHJldHVybjtcblx0XHRcdGllMTFCdWdXb3JrYXJvdW5kID0gdHJ1ZTtcblx0XHRcdGRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIGQodmFsdWUpKTtcblx0XHRcdGllMTFCdWdXb3JrYXJvdW5kID0gZmFsc2U7XG5cdFx0fSkpO1xuXHRcdHJldHVybiBuYW1lO1xuXHR9O1xufSgpKTtcblxuLy8gSW50ZXJuYWwgY29uc3RydWN0b3IgKG5vdCBvbmUgZXhwb3NlZCkgZm9yIGNyZWF0aW5nIFN5bWJvbCBpbnN0YW5jZXMuXG4vLyBUaGlzIG9uZSBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IGBzb21lU3ltYm9sIGluc3RhbmNlb2YgU3ltYm9sYCBhbHdheXMgcmV0dXJuIGZhbHNlXG5IaWRkZW5TeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woZGVzY3JpcHRpb24pIHtcblx0aWYgKHRoaXMgaW5zdGFuY2VvZiBIaWRkZW5TeW1ib2wpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuXHRyZXR1cm4gU3ltYm9sUG9seWZpbGwoZGVzY3JpcHRpb24pO1xufTtcblxuLy8gRXhwb3NlZCBgU3ltYm9sYCBjb25zdHJ1Y3RvclxuLy8gKHJldHVybnMgaW5zdGFuY2VzIG9mIEhpZGRlblN5bWJvbClcbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sUG9seWZpbGwgPSBmdW5jdGlvbiBTeW1ib2woZGVzY3JpcHRpb24pIHtcblx0dmFyIHN5bWJvbDtcblx0aWYgKHRoaXMgaW5zdGFuY2VvZiBTeW1ib2wpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuXHRpZiAoaXNOYXRpdmVTYWZlKSByZXR1cm4gTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKTtcblx0c3ltYm9sID0gY3JlYXRlKEhpZGRlblN5bWJvbC5wcm90b3R5cGUpO1xuXHRkZXNjcmlwdGlvbiA9IChkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcoZGVzY3JpcHRpb24pKTtcblx0cmV0dXJuIGRlZmluZVByb3BlcnRpZXMoc3ltYm9sLCB7XG5cdFx0X19kZXNjcmlwdGlvbl9fOiBkKCcnLCBkZXNjcmlwdGlvbiksXG5cdFx0X19uYW1lX186IGQoJycsIGdlbmVyYXRlTmFtZShkZXNjcmlwdGlvbikpXG5cdH0pO1xufTtcbmRlZmluZVByb3BlcnRpZXMoU3ltYm9sUG9seWZpbGwsIHtcblx0Zm9yOiBkKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRpZiAoZ2xvYmFsU3ltYm9sc1trZXldKSByZXR1cm4gZ2xvYmFsU3ltYm9sc1trZXldO1xuXHRcdHJldHVybiAoZ2xvYmFsU3ltYm9sc1trZXldID0gU3ltYm9sUG9seWZpbGwoU3RyaW5nKGtleSkpKTtcblx0fSksXG5cdGtleUZvcjogZChmdW5jdGlvbiAocykge1xuXHRcdHZhciBrZXk7XG5cdFx0dmFsaWRhdGVTeW1ib2wocyk7XG5cdFx0Zm9yIChrZXkgaW4gZ2xvYmFsU3ltYm9scykgaWYgKGdsb2JhbFN5bWJvbHNba2V5XSA9PT0gcykgcmV0dXJuIGtleTtcblx0fSksXG5cblx0Ly8gVG8gZW5zdXJlIHByb3BlciBpbnRlcm9wZXJhYmlsaXR5IHdpdGggb3RoZXIgbmF0aXZlIGZ1bmN0aW9ucyAoZS5nLiBBcnJheS5mcm9tKVxuXHQvLyBmYWxsYmFjayB0byBldmVudHVhbCBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgZ2l2ZW4gc3ltYm9sXG5cdGhhc0luc3RhbmNlOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5oYXNJbnN0YW5jZSkgfHwgU3ltYm9sUG9seWZpbGwoJ2hhc0luc3RhbmNlJykpLFxuXHRpc0NvbmNhdFNwcmVhZGFibGU6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSkgfHxcblx0XHRTeW1ib2xQb2x5ZmlsbCgnaXNDb25jYXRTcHJlYWRhYmxlJykpLFxuXHRpdGVyYXRvcjogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuaXRlcmF0b3IpIHx8IFN5bWJvbFBvbHlmaWxsKCdpdGVyYXRvcicpKSxcblx0bWF0Y2g6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLm1hdGNoKSB8fCBTeW1ib2xQb2x5ZmlsbCgnbWF0Y2gnKSksXG5cdHJlcGxhY2U6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnJlcGxhY2UpIHx8IFN5bWJvbFBvbHlmaWxsKCdyZXBsYWNlJykpLFxuXHRzZWFyY2g6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnNlYXJjaCkgfHwgU3ltYm9sUG9seWZpbGwoJ3NlYXJjaCcpKSxcblx0c3BlY2llczogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuc3BlY2llcykgfHwgU3ltYm9sUG9seWZpbGwoJ3NwZWNpZXMnKSksXG5cdHNwbGl0OiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5zcGxpdCkgfHwgU3ltYm9sUG9seWZpbGwoJ3NwbGl0JykpLFxuXHR0b1ByaW1pdGl2ZTogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wudG9QcmltaXRpdmUpIHx8IFN5bWJvbFBvbHlmaWxsKCd0b1ByaW1pdGl2ZScpKSxcblx0dG9TdHJpbmdUYWc6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnRvU3RyaW5nVGFnKSB8fCBTeW1ib2xQb2x5ZmlsbCgndG9TdHJpbmdUYWcnKSksXG5cdHVuc2NvcGFibGVzOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC51bnNjb3BhYmxlcykgfHwgU3ltYm9sUG9seWZpbGwoJ3Vuc2NvcGFibGVzJykpXG59KTtcblxuLy8gSW50ZXJuYWwgdHdlYWtzIGZvciByZWFsIHN5bWJvbCBwcm9kdWNlclxuZGVmaW5lUHJvcGVydGllcyhIaWRkZW5TeW1ib2wucHJvdG90eXBlLCB7XG5cdGNvbnN0cnVjdG9yOiBkKFN5bWJvbFBvbHlmaWxsKSxcblx0dG9TdHJpbmc6IGQoJycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX19uYW1lX187IH0pXG59KTtcblxuLy8gUHJvcGVyIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgZXhwb3NlZCBvbiBTeW1ib2wucHJvdG90eXBlXG4vLyBUaGV5IHdvbid0IGJlIGFjY2Vzc2libGUgb24gcHJvZHVjZWQgc3ltYm9sIGluc3RhbmNlcyBhcyB0aGV5IGRlcml2ZSBmcm9tIEhpZGRlblN5bWJvbC5wcm90b3R5cGVcbmRlZmluZVByb3BlcnRpZXMoU3ltYm9sUG9seWZpbGwucHJvdG90eXBlLCB7XG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdTeW1ib2wgKCcgKyB2YWxpZGF0ZVN5bWJvbCh0aGlzKS5fX2Rlc2NyaXB0aW9uX18gKyAnKSc7IH0pLFxuXHR2YWx1ZU9mOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlU3ltYm9sKHRoaXMpOyB9KVxufSk7XG5kZWZpbmVQcm9wZXJ0eShTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvUHJpbWl0aXZlLCBkKCcnLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBzeW1ib2wgPSB2YWxpZGF0ZVN5bWJvbCh0aGlzKTtcblx0aWYgKHR5cGVvZiBzeW1ib2wgPT09ICdzeW1ib2wnKSByZXR1cm4gc3ltYm9sO1xuXHRyZXR1cm4gc3ltYm9sLnRvU3RyaW5nKCk7XG59KSk7XG5kZWZpbmVQcm9wZXJ0eShTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCBkKCdjJywgJ1N5bWJvbCcpKTtcblxuLy8gUHJvcGVyIGltcGxlbWVudGF0b24gb2YgdG9QcmltaXRpdmUgYW5kIHRvU3RyaW5nVGFnIGZvciByZXR1cm5lZCBzeW1ib2wgaW5zdGFuY2VzXG5kZWZpbmVQcm9wZXJ0eShIaWRkZW5TeW1ib2wucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyxcblx0ZCgnYycsIFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZVtTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZ10pKTtcblxuLy8gTm90ZTogSXQncyBpbXBvcnRhbnQgdG8gZGVmaW5lIGB0b1ByaW1pdGl2ZWAgYXMgbGFzdCBvbmUsIGFzIHNvbWUgaW1wbGVtZW50YXRpb25zXG4vLyBpbXBsZW1lbnQgYHRvUHJpbWl0aXZlYCBuYXRpdmVseSB3aXRob3V0IGltcGxlbWVudGluZyBgdG9TdHJpbmdUYWdgIChvciBvdGhlciBzcGVjaWZpZWQgc3ltYm9scylcbi8vIEFuZCB0aGF0IG1heSBpbnZva2UgZXJyb3IgaW4gZGVmaW5pdGlvbiBmbG93OlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWtvby9lczYtc3ltYm9sL2lzc3Vlcy8xMyNpc3N1ZWNvbW1lbnQtMTY0MTQ2MTQ5XG5kZWZpbmVQcm9wZXJ0eShIaWRkZW5TeW1ib2wucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1ByaW1pdGl2ZSxcblx0ZCgnYycsIFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZVtTeW1ib2xQb2x5ZmlsbC50b1ByaW1pdGl2ZV0pKTtcblxufSx7XCIuL3ZhbGlkYXRlLXN5bWJvbFwiOjc3LFwiZFwiOjE2fV0sNzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzLXN5bWJvbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzU3ltYm9sKHZhbHVlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcih2YWx1ZSArIFwiIGlzIG5vdCBhIHN5bWJvbFwiKTtcblx0cmV0dXJuIHZhbHVlO1xufTtcblxufSx7XCIuL2lzLXN5bWJvbFwiOjc1fV0sNzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBjYWxsYWJsZSA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcblxuICAsIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGRlc2NyaXB0b3IgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH1cblxuICAsIG9uLCBvbmNlLCBvZmYsIGVtaXQsIG1ldGhvZHMsIGRlc2NyaXB0b3JzLCBiYXNlO1xuXG5vbiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkge1xuXHRcdGRhdGEgPSBkZXNjcmlwdG9yLnZhbHVlID0gY3JlYXRlKG51bGwpO1xuXHRcdGRlZmluZVByb3BlcnR5KHRoaXMsICdfX2VlX18nLCBkZXNjcmlwdG9yKTtcblx0XHRkZXNjcmlwdG9yLnZhbHVlID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRkYXRhID0gdGhpcy5fX2VlX187XG5cdH1cblx0aWYgKCFkYXRhW3R5cGVdKSBkYXRhW3R5cGVdID0gbGlzdGVuZXI7XG5cdGVsc2UgaWYgKHR5cGVvZiBkYXRhW3R5cGVdID09PSAnb2JqZWN0JykgZGF0YVt0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0ZWxzZSBkYXRhW3R5cGVdID0gW2RhdGFbdHlwZV0sIGxpc3RlbmVyXTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9uY2UgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIG9uY2UsIHNlbGY7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXHRzZWxmID0gdGhpcztcblx0b24uY2FsbCh0aGlzLCB0eXBlLCBvbmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdG9mZi5jYWxsKHNlbGYsIHR5cGUsIG9uY2UpO1xuXHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0pO1xuXG5cdG9uY2UuX19lZU9uY2VMaXN0ZW5lcl9fID0gbGlzdGVuZXI7XG5cdHJldHVybiB0aGlzO1xufTtcblxub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBkYXRhLCBsaXN0ZW5lcnMsIGNhbmRpZGF0ZSwgaTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuIHRoaXM7XG5cdGRhdGEgPSB0aGlzLl9fZWVfXztcblx0aWYgKCFkYXRhW3R5cGVdKSByZXR1cm4gdGhpcztcblx0bGlzdGVuZXJzID0gZGF0YVt0eXBlXTtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRmb3IgKGkgPSAwOyAoY2FuZGlkYXRlID0gbGlzdGVuZXJzW2ldKTsgKytpKSB7XG5cdFx0XHRpZiAoKGNhbmRpZGF0ZSA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdFx0KGNhbmRpZGF0ZS5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMikgZGF0YVt0eXBlXSA9IGxpc3RlbmVyc1tpID8gMCA6IDFdO1xuXHRcdFx0XHRlbHNlIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmICgobGlzdGVuZXJzID09PSBsaXN0ZW5lcikgfHxcblx0XHRcdFx0KGxpc3RlbmVycy5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0ZGVsZXRlIGRhdGFbdHlwZV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0dmFyIGksIGwsIGxpc3RlbmVyLCBsaXN0ZW5lcnMsIGFyZ3M7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuO1xuXHRsaXN0ZW5lcnMgPSB0aGlzLl9fZWVfX1t0eXBlXTtcblx0aWYgKCFsaXN0ZW5lcnMpIHJldHVybjtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRmb3IgKGkgPSAxOyBpIDwgbDsgKytpKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuXHRcdGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xuXHRcdGZvciAoaSA9IDA7IChsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0YXBwbHkuY2FsbChsaXN0ZW5lciwgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGNhc2UgMTpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJndW1lbnRzWzFdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHRhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdH1cblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH1cbn07XG5cbm1ldGhvZHMgPSB7XG5cdG9uOiBvbixcblx0b25jZTogb25jZSxcblx0b2ZmOiBvZmYsXG5cdGVtaXQ6IGVtaXRcbn07XG5cbmRlc2NyaXB0b3JzID0ge1xuXHRvbjogZChvbiksXG5cdG9uY2U6IGQob25jZSksXG5cdG9mZjogZChvZmYpLFxuXHRlbWl0OiBkKGVtaXQpXG59O1xuXG5iYXNlID0gZGVmaW5lUHJvcGVydGllcyh7fSwgZGVzY3JpcHRvcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiAobykge1xuXHRyZXR1cm4gKG8gPT0gbnVsbCkgPyBjcmVhdGUoYmFzZSkgOiBkZWZpbmVQcm9wZXJ0aWVzKE9iamVjdChvKSwgZGVzY3JpcHRvcnMpO1xufTtcbmV4cG9ydHMubWV0aG9kcyA9IG1ldGhvZHM7XG5cbn0se1wiZFwiOjE2LFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIjo1NH1dLDc5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxufSx7fV0sODA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0se31dLDgxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuXG59LHt9XSw4MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8qIFByb3RvY29sIC0gcHJvdG9jb2wgY29uc3RhbnRzICovXG52YXIgcHJvdG9jb2wgPSBtb2R1bGUuZXhwb3J0c1xuXG4vKiBDb21tYW5kIGNvZGUgPT4gbW5lbW9uaWMgKi9cbnByb3RvY29sLnR5cGVzID0ge1xuICAwOiAncmVzZXJ2ZWQnLFxuICAxOiAnY29ubmVjdCcsXG4gIDI6ICdjb25uYWNrJyxcbiAgMzogJ3B1Ymxpc2gnLFxuICA0OiAncHViYWNrJyxcbiAgNTogJ3B1YnJlYycsXG4gIDY6ICdwdWJyZWwnLFxuICA3OiAncHViY29tcCcsXG4gIDg6ICdzdWJzY3JpYmUnLFxuICA5OiAnc3ViYWNrJyxcbiAgMTA6ICd1bnN1YnNjcmliZScsXG4gIDExOiAndW5zdWJhY2snLFxuICAxMjogJ3BpbmdyZXEnLFxuICAxMzogJ3BpbmdyZXNwJyxcbiAgMTQ6ICdkaXNjb25uZWN0JyxcbiAgMTU6ICdhdXRoJ1xufVxuXG4vKiBNbmVtb25pYyA9PiBDb21tYW5kIGNvZGUgKi9cbnByb3RvY29sLmNvZGVzID0ge31cbmZvciAodmFyIGsgaW4gcHJvdG9jb2wudHlwZXMpIHtcbiAgdmFyIHYgPSBwcm90b2NvbC50eXBlc1trXVxuICBwcm90b2NvbC5jb2Rlc1t2XSA9IGtcbn1cblxuLyogSGVhZGVyICovXG5wcm90b2NvbC5DTURfU0hJRlQgPSA0XG5wcm90b2NvbC5DTURfTUFTSyA9IDB4RjBcbnByb3RvY29sLkRVUF9NQVNLID0gMHgwOFxucHJvdG9jb2wuUU9TX01BU0sgPSAweDAzXG5wcm90b2NvbC5RT1NfU0hJRlQgPSAxXG5wcm90b2NvbC5SRVRBSU5fTUFTSyA9IDB4MDFcblxuLyogTGVuZ3RoICovXG5wcm90b2NvbC5MRU5HVEhfTUFTSyA9IDB4N0ZcbnByb3RvY29sLkxFTkdUSF9GSU5fTUFTSyA9IDB4ODBcblxuLyogQ29ubmFjayAqL1xucHJvdG9jb2wuU0VTU0lPTlBSRVNFTlRfTUFTSyA9IDB4MDFcbnByb3RvY29sLlNFU1NJT05QUkVTRU5UX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5TRVNTSU9OUFJFU0VOVF9NQVNLXSlcbnByb3RvY29sLkNPTk5BQ0tfSEVBREVSID0gQnVmZmVyLmZyb20oW3Byb3RvY29sLmNvZGVzWydjb25uYWNrJ10gPDwgcHJvdG9jb2wuQ01EX1NISUZUXSlcblxuLyogQ29ubmVjdCAqL1xucHJvdG9jb2wuVVNFUk5BTUVfTUFTSyA9IDB4ODBcbnByb3RvY29sLlBBU1NXT1JEX01BU0sgPSAweDQwXG5wcm90b2NvbC5XSUxMX1JFVEFJTl9NQVNLID0gMHgyMFxucHJvdG9jb2wuV0lMTF9RT1NfTUFTSyA9IDB4MThcbnByb3RvY29sLldJTExfUU9TX1NISUZUID0gM1xucHJvdG9jb2wuV0lMTF9GTEFHX01BU0sgPSAweDA0XG5wcm90b2NvbC5DTEVBTl9TRVNTSU9OX01BU0sgPSAweDAyXG5wcm90b2NvbC5DT05ORUNUX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1snY29ubmVjdCddIDw8IHByb3RvY29sLkNNRF9TSElGVF0pXG5cbi8qIFByb3BlcnRpZXMgKi9cbnByb3RvY29sLnByb3BlcnRpZXMgPSB7XG4gIHNlc3Npb25FeHBpcnlJbnRlcnZhbDogMTcsXG4gIHdpbGxEZWxheUludGVydmFsOiAyNCxcbiAgcmVjZWl2ZU1heGltdW06IDMzLFxuICBtYXhpbXVtUGFja2V0U2l6ZTogMzksXG4gIHRvcGljQWxpYXNNYXhpbXVtOiAzNCxcbiAgcmVxdWVzdFJlc3BvbnNlSW5mb3JtYXRpb246IDI1LFxuICByZXF1ZXN0UHJvYmxlbUluZm9ybWF0aW9uOiAyMyxcbiAgdXNlclByb3BlcnRpZXM6IDM4LFxuICBhdXRoZW50aWNhdGlvbk1ldGhvZDogMjEsXG4gIGF1dGhlbnRpY2F0aW9uRGF0YTogMjIsXG4gIHBheWxvYWRGb3JtYXRJbmRpY2F0b3I6IDEsXG4gIG1lc3NhZ2VFeHBpcnlJbnRlcnZhbDogMixcbiAgY29udGVudFR5cGU6IDMsXG4gIHJlc3BvbnNlVG9waWM6IDgsXG4gIGNvcnJlbGF0aW9uRGF0YTogOSxcbiAgbWF4aW11bVFvUzogMzYsXG4gIHJldGFpbkF2YWlsYWJsZTogMzcsXG4gIGFzc2lnbmVkQ2xpZW50SWRlbnRpZmllcjogMTgsXG4gIHJlYXNvblN0cmluZzogMzEsXG4gIHdpbGRjYXJkU3Vic2NyaXB0aW9uQXZhaWxhYmxlOiA0MCxcbiAgc3Vic2NyaXB0aW9uSWRlbnRpZmllcnNBdmFpbGFibGU6IDQxLFxuICBzaGFyZWRTdWJzY3JpcHRpb25BdmFpbGFibGU6IDQyLFxuICBzZXJ2ZXJLZWVwQWxpdmU6IDE5LFxuICByZXNwb25zZUluZm9ybWF0aW9uOiAyNixcbiAgc2VydmVyUmVmZXJlbmNlOiAyOCxcbiAgdG9waWNBbGlhczogMzUsXG4gIHN1YnNjcmlwdGlvbklkZW50aWZpZXI6IDExXG59XG5wcm90b2NvbC5wcm9wZXJ0aWVzQ29kZXMgPSB7fVxuZm9yICh2YXIgcHJvcCBpbiBwcm90b2NvbC5wcm9wZXJ0aWVzKSB7XG4gIHZhciBpZCA9IHByb3RvY29sLnByb3BlcnRpZXNbcHJvcF1cbiAgcHJvdG9jb2wucHJvcGVydGllc0NvZGVzW2lkXSA9IHByb3Bcbn1cbnByb3RvY29sLnByb3BlcnRpZXNUeXBlcyA9IHtcbiAgc2Vzc2lvbkV4cGlyeUludGVydmFsOiAnaW50MzInLFxuICB3aWxsRGVsYXlJbnRlcnZhbDogJ2ludDMyJyxcbiAgcmVjZWl2ZU1heGltdW06ICdpbnQxNicsXG4gIG1heGltdW1QYWNrZXRTaXplOiAnaW50MzInLFxuICB0b3BpY0FsaWFzTWF4aW11bTogJ2ludDE2JyxcbiAgcmVxdWVzdFJlc3BvbnNlSW5mb3JtYXRpb246ICdieXRlJyxcbiAgcmVxdWVzdFByb2JsZW1JbmZvcm1hdGlvbjogJ2J5dGUnLFxuICB1c2VyUHJvcGVydGllczogJ3BhaXInLFxuICBhdXRoZW50aWNhdGlvbk1ldGhvZDogJ3N0cmluZycsXG4gIGF1dGhlbnRpY2F0aW9uRGF0YTogJ2JpbmFyeScsXG4gIHBheWxvYWRGb3JtYXRJbmRpY2F0b3I6ICdieXRlJyxcbiAgbWVzc2FnZUV4cGlyeUludGVydmFsOiAnaW50MzInLFxuICBjb250ZW50VHlwZTogJ3N0cmluZycsXG4gIHJlc3BvbnNlVG9waWM6ICdzdHJpbmcnLFxuICBjb3JyZWxhdGlvbkRhdGE6ICdiaW5hcnknLFxuICBtYXhpbXVtUW9TOiAnaW50OCcsXG4gIHJldGFpbkF2YWlsYWJsZTogJ2J5dGUnLFxuICBhc3NpZ25lZENsaWVudElkZW50aWZpZXI6ICdzdHJpbmcnLFxuICByZWFzb25TdHJpbmc6ICdzdHJpbmcnLFxuICB3aWxkY2FyZFN1YnNjcmlwdGlvbkF2YWlsYWJsZTogJ2J5dGUnLFxuICBzdWJzY3JpcHRpb25JZGVudGlmaWVyc0F2YWlsYWJsZTogJ2J5dGUnLFxuICBzaGFyZWRTdWJzY3JpcHRpb25BdmFpbGFibGU6ICdieXRlJyxcbiAgc2VydmVyS2VlcEFsaXZlOiAnaW50MzInLFxuICByZXNwb25zZUluZm9ybWF0aW9uOiAnc3RyaW5nJyxcbiAgc2VydmVyUmVmZXJlbmNlOiAnc3RyaW5nJyxcbiAgdG9waWNBbGlhczogJ2ludDE2JyxcbiAgc3Vic2NyaXB0aW9uSWRlbnRpZmllcjogJ3Zhcidcbn1cblxuZnVuY3Rpb24gZ2VuSGVhZGVyICh0eXBlKSB7XG4gIHJldHVybiBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChxb3MpIHtcbiAgICByZXR1cm4gWzAsIDFdLm1hcChmdW5jdGlvbiAoZHVwKSB7XG4gICAgICByZXR1cm4gWzAsIDFdLm1hcChmdW5jdGlvbiAocmV0YWluKSB7XG4gICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKDEpXG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KFxuICAgICAgICAgIHByb3RvY29sLmNvZGVzW3R5cGVdIDw8IHByb3RvY29sLkNNRF9TSElGVCB8XG4gICAgICAgICAgKGR1cCA/IHByb3RvY29sLkRVUF9NQVNLIDogMCkgfFxuICAgICAgICAgIHFvcyA8PCBwcm90b2NvbC5RT1NfU0hJRlQgfCByZXRhaW4sIDAsIHRydWUpXG4gICAgICAgIHJldHVybiBidWZcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLyogUHVibGlzaCAqL1xucHJvdG9jb2wuUFVCTElTSF9IRUFERVIgPSBnZW5IZWFkZXIoJ3B1Ymxpc2gnKVxuXG4vKiBTdWJzY3JpYmUgKi9cbnByb3RvY29sLlNVQlNDUklCRV9IRUFERVIgPSBnZW5IZWFkZXIoJ3N1YnNjcmliZScpXG5wcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19RT1NfTUFTSyA9IDB4MDNcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX05MX01BU0sgPSAweDAxXG5wcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19OTF9TSElGVCA9IDJcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1JBUF9NQVNLID0gMHgwMVxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkFQX1NISUZUID0gM1xucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkhfTUFTSyA9IDB4MDNcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1JIX1NISUZUID0gNFxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkggPSBbMHgwMCwgMHgxMCwgMHgyMF1cbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX05MID0gMHgwNFxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkFQID0gMHgwOFxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUU9TID0gWzB4MDAsIDB4MDEsIDB4MDJdXG5cbi8qIFVuc3Vic2NyaWJlICovXG5wcm90b2NvbC5VTlNVQlNDUklCRV9IRUFERVIgPSBnZW5IZWFkZXIoJ3Vuc3Vic2NyaWJlJylcblxuLyogQ29uZmlybWF0aW9ucyAqL1xucHJvdG9jb2wuQUNLUyA9IHtcbiAgdW5zdWJhY2s6IGdlbkhlYWRlcigndW5zdWJhY2snKSxcbiAgcHViYWNrOiBnZW5IZWFkZXIoJ3B1YmFjaycpLFxuICBwdWJjb21wOiBnZW5IZWFkZXIoJ3B1YmNvbXAnKSxcbiAgcHVicmVsOiBnZW5IZWFkZXIoJ3B1YnJlbCcpLFxuICBwdWJyZWM6IGdlbkhlYWRlcigncHVicmVjJylcbn1cblxucHJvdG9jb2wuU1VCQUNLX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1snc3ViYWNrJ10gPDwgcHJvdG9jb2wuQ01EX1NISUZUXSlcblxuLyogUHJvdG9jb2wgdmVyc2lvbnMgKi9cbnByb3RvY29sLlZFUlNJT04zID0gQnVmZmVyLmZyb20oWzNdKVxucHJvdG9jb2wuVkVSU0lPTjQgPSBCdWZmZXIuZnJvbShbNF0pXG5wcm90b2NvbC5WRVJTSU9ONSA9IEJ1ZmZlci5mcm9tKFs1XSlcblxuLyogUW9TICovXG5wcm90b2NvbC5RT1MgPSBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChxb3MpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtxb3NdKVxufSlcblxuLyogRW1wdHkgcGFja2V0cyAqL1xucHJvdG9jb2wuRU1QVFkgPSB7XG4gIHBpbmdyZXE6IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1sncGluZ3JlcSddIDw8IDQsIDBdKSxcbiAgcGluZ3Jlc3A6IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1sncGluZ3Jlc3AnXSA8PCA0LCAwXSksXG4gIGRpc2Nvbm5lY3Q6IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1snZGlzY29ubmVjdCddIDw8IDQsIDBdKVxufVxuXG59LHtcInNhZmUtYnVmZmVyXCI6MTEwfV0sODM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIHdyaXRlVG9TdHJlYW0gPSByZXF1aXJlKCcuL3dyaXRlVG9TdHJlYW0nKVxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChwYWNrZXQsIG9wdHMpIHtcbiAgdmFyIHN0cmVhbSA9IG5ldyBBY2N1bXVsYXRvcigpXG4gIHdyaXRlVG9TdHJlYW0ocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gIHJldHVybiBzdHJlYW0uY29uY2F0KClcbn1cblxuZnVuY3Rpb24gQWNjdW11bGF0b3IgKCkge1xuICB0aGlzLl9hcnJheSA9IG5ldyBBcnJheSgyMClcbiAgdGhpcy5faSA9IDBcbn1cblxuaW5oZXJpdHMoQWNjdW11bGF0b3IsIEVFKVxuXG5BY2N1bXVsYXRvci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5fYXJyYXlbdGhpcy5faSsrXSA9IGNodW5rXG4gIHJldHVybiB0cnVlXG59XG5cbkFjY3VtdWxhdG9yLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW5ndGggPSAwXG4gIHZhciBsZW5ndGhzID0gbmV3IEFycmF5KHRoaXMuX2FycmF5Lmxlbmd0aClcbiAgdmFyIGxpc3QgPSB0aGlzLl9hcnJheVxuICB2YXIgcG9zID0gMFxuICB2YXIgaVxuICB2YXIgcmVzdWx0XG5cbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoICYmIGxpc3RbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0W2ldICE9PSAnc3RyaW5nJykgbGVuZ3Roc1tpXSA9IGxpc3RbaV0ubGVuZ3RoXG4gICAgZWxzZSBsZW5ndGhzW2ldID0gQnVmZmVyLmJ5dGVMZW5ndGgobGlzdFtpXSlcblxuICAgIGxlbmd0aCArPSBsZW5ndGhzW2ldXG4gIH1cblxuICByZXN1bHQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aCAmJiBsaXN0W2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgIGlmICh0eXBlb2YgbGlzdFtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGxpc3RbaV0uY29weShyZXN1bHQsIHBvcylcbiAgICAgIHBvcyArPSBsZW5ndGhzW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC53cml0ZShsaXN0W2ldLCBwb3MpXG4gICAgICBwb3MgKz0gbGVuZ3Roc1tpXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZVxuXG59LHtcIi4vd3JpdGVUb1N0cmVhbVwiOjg5LFwiZXZlbnRzXCI6MTMsXCJpbmhlcml0c1wiOjgwLFwic2FmZS1idWZmZXJcIjoxMTB9XSw4NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpXG5leHBvcnRzLmdlbmVyYXRlID0gcmVxdWlyZSgnLi9nZW5lcmF0ZScpXG5leHBvcnRzLndyaXRlVG9TdHJlYW0gPSByZXF1aXJlKCcuL3dyaXRlVG9TdHJlYW0nKVxuXG59LHtcIi4vZ2VuZXJhdGVcIjo4MyxcIi4vcGFyc2VyXCI6ODgsXCIuL3dyaXRlVG9TdHJlYW1cIjo4OX1dLDg1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBEdXBsZXhTdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4JylcbiAgLCB1dGlsICAgICAgICAgPSByZXF1aXJlKCd1dGlsJylcbiAgLCBCdWZmZXIgICAgICAgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QgKGNhbGxiYWNrKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXJMaXN0KSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlckxpc3QoY2FsbGJhY2spXG5cbiAgdGhpcy5fYnVmcyAgPSBbXVxuICB0aGlzLmxlbmd0aCA9IDBcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrXG5cbiAgICB2YXIgcGlwZXIgPSBmdW5jdGlvbiBwaXBlciAoZXJyKSB7XG4gICAgICBpZiAodGhpcy5fY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2soZXJyKVxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGxcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcylcblxuICAgIHRoaXMub24oJ3BpcGUnLCBmdW5jdGlvbiBvblBpcGUgKHNyYykge1xuICAgICAgc3JjLm9uKCdlcnJvcicsIHBpcGVyKVxuICAgIH0pXG4gICAgdGhpcy5vbigndW5waXBlJywgZnVuY3Rpb24gb25VbnBpcGUgKHNyYykge1xuICAgICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHBpcGVyKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hcHBlbmQoY2FsbGJhY2spXG4gIH1cblxuICBEdXBsZXhTdHJlYW0uY2FsbCh0aGlzKVxufVxuXG5cbnV0aWwuaW5oZXJpdHMoQnVmZmVyTGlzdCwgRHVwbGV4U3RyZWFtKVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9vZmZzZXQgPSBmdW5jdGlvbiBfb2Zmc2V0IChvZmZzZXQpIHtcbiAgdmFyIHRvdCA9IDAsIGkgPSAwLCBfdFxuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gWyAwLCAwIF1cbiAgZm9yICg7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgX3QgPSB0b3QgKyB0aGlzLl9idWZzW2ldLmxlbmd0aFxuICAgIGlmIChvZmZzZXQgPCBfdCB8fCBpID09IHRoaXMuX2J1ZnMubGVuZ3RoIC0gMSlcbiAgICAgIHJldHVybiBbIGksIG9mZnNldCAtIHRvdCBdXG4gICAgdG90ID0gX3RcbiAgfVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAoYnVmKSB7XG4gIHZhciBpID0gMFxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRoaXMuX2FwcGVuZEJ1ZmZlcihidWYpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYnVmKSkge1xuICAgIGZvciAoOyBpIDwgYnVmLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5hcHBlbmQoYnVmW2ldKVxuICB9IGVsc2UgaWYgKGJ1ZiBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QpIHtcbiAgICAvLyB1bndyYXAgYXJndW1lbnQgaW50byBpbmRpdmlkdWFsIEJ1ZmZlckxpc3RzXG4gICAgZm9yICg7IGkgPCBidWYuX2J1ZnMubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLmFwcGVuZChidWYuX2J1ZnNbaV0pXG4gIH0gZWxzZSBpZiAoYnVmICE9IG51bGwpIHtcbiAgICAvLyBjb2VyY2UgbnVtYmVyIGFyZ3VtZW50cyB0byBzdHJpbmdzLCBzaW5jZSBCdWZmZXIobnVtYmVyKSBkb2VzXG4gICAgLy8gdW5pbml0aWFsaXplZCBtZW1vcnkgYWxsb2NhdGlvblxuICAgIGlmICh0eXBlb2YgYnVmID09ICdudW1iZXInKVxuICAgICAgYnVmID0gYnVmLnRvU3RyaW5nKClcblxuICAgIHRoaXMuX2FwcGVuZEJ1ZmZlcihCdWZmZXIuZnJvbShidWYpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX2FwcGVuZEJ1ZmZlciA9IGZ1bmN0aW9uIGFwcGVuZEJ1ZmZlciAoYnVmKSB7XG4gIHRoaXMuX2J1ZnMucHVzaChidWYpXG4gIHRoaXMubGVuZ3RoICs9IGJ1Zi5sZW5ndGhcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUgKGJ1ZiwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHRoaXMuX2FwcGVuZEJ1ZmZlcihidWYpXG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKVxuICAgIGNhbGxiYWNrKClcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIF9yZWFkIChzaXplKSB7XG4gIGlmICghdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMucHVzaChudWxsKVxuXG4gIHNpemUgPSBNYXRoLm1pbihzaXplLCB0aGlzLmxlbmd0aClcbiAgdGhpcy5wdXNoKHRoaXMuc2xpY2UoMCwgc2l6ZSkpXG4gIHRoaXMuY29uc3VtZShzaXplKVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZCAoY2h1bmspIHtcbiAgRHVwbGV4U3RyZWFtLnByb3RvdHlwZS5lbmQuY2FsbCh0aGlzLCBjaHVuaylcblxuICBpZiAodGhpcy5fY2FsbGJhY2spIHtcbiAgICB0aGlzLl9jYWxsYmFjayhudWxsLCB0aGlzLnNsaWNlKCkpXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsXG4gIH1cbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4KSB7XG4gIHJldHVybiB0aGlzLnNsaWNlKGluZGV4LCBpbmRleCArIDEpWzBdXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ID09ICdudW1iZXInICYmIHN0YXJ0IDwgMClcbiAgICBzdGFydCArPSB0aGlzLmxlbmd0aFxuICBpZiAodHlwZW9mIGVuZCA9PSAnbnVtYmVyJyAmJiBlbmQgPCAwKVxuICAgIGVuZCArPSB0aGlzLmxlbmd0aFxuICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIDAsIHN0YXJ0LCBlbmQpXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRzdCwgZHN0U3RhcnQsIHNyY1N0YXJ0LCBzcmNFbmQpIHtcbiAgaWYgKHR5cGVvZiBzcmNTdGFydCAhPSAnbnVtYmVyJyB8fCBzcmNTdGFydCA8IDApXG4gICAgc3JjU3RhcnQgPSAwXG4gIGlmICh0eXBlb2Ygc3JjRW5kICE9ICdudW1iZXInIHx8IHNyY0VuZCA+IHRoaXMubGVuZ3RoKVxuICAgIHNyY0VuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChzcmNTdGFydCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm4gZHN0IHx8IEJ1ZmZlci5hbGxvYygwKVxuICBpZiAoc3JjRW5kIDw9IDApXG4gICAgcmV0dXJuIGRzdCB8fCBCdWZmZXIuYWxsb2MoMClcblxuICB2YXIgY29weSAgID0gISFkc3RcbiAgICAsIG9mZiAgICA9IHRoaXMuX29mZnNldChzcmNTdGFydClcbiAgICAsIGxlbiAgICA9IHNyY0VuZCAtIHNyY1N0YXJ0XG4gICAgLCBieXRlcyAgPSBsZW5cbiAgICAsIGJ1Zm9mZiA9IChjb3B5ICYmIGRzdFN0YXJ0KSB8fCAwXG4gICAgLCBzdGFydCAgPSBvZmZbMV1cbiAgICAsIGxcbiAgICAsIGlcblxuICAvLyBjb3B5L3NsaWNlIGV2ZXJ5dGhpbmdcbiAgaWYgKHNyY1N0YXJ0ID09PSAwICYmIHNyY0VuZCA9PSB0aGlzLmxlbmd0aCkge1xuICAgIGlmICghY29weSkgeyAvLyBzbGljZSwgYnV0IGZ1bGwgY29uY2F0IGlmIG11bHRpcGxlIGJ1ZmZlcnNcbiAgICAgIHJldHVybiB0aGlzLl9idWZzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IHRoaXMuX2J1ZnNbMF1cbiAgICAgICAgOiBCdWZmZXIuY29uY2F0KHRoaXMuX2J1ZnMsIHRoaXMubGVuZ3RoKVxuICAgIH1cblxuICAgIC8vIGNvcHksIG5lZWQgdG8gY29weSBpbmRpdmlkdWFsIGJ1ZmZlcnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmKVxuICAgICAgYnVmb2ZmICs9IHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIGRzdFxuICB9XG5cbiAgLy8gZWFzeSwgY2hlYXAgY2FzZSB3aGVyZSBpdCdzIGEgc3Vic2V0IG9mIG9uZSBvZiB0aGUgYnVmZmVyc1xuICBpZiAoYnl0ZXMgPD0gdGhpcy5fYnVmc1tvZmZbMF1dLmxlbmd0aCAtIHN0YXJ0KSB7XG4gICAgcmV0dXJuIGNvcHlcbiAgICAgID8gdGhpcy5fYnVmc1tvZmZbMF1dLmNvcHkoZHN0LCBkc3RTdGFydCwgc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gICAgICA6IHRoaXMuX2J1ZnNbb2ZmWzBdXS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgfVxuXG4gIGlmICghY29weSkgLy8gYSBzbGljZSwgd2UgbmVlZCBzb21ldGhpbmcgdG8gY29weSBpbiB0b1xuICAgIGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pXG5cbiAgZm9yIChpID0gb2ZmWzBdOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGwgPSB0aGlzLl9idWZzW2ldLmxlbmd0aCAtIHN0YXJ0XG5cbiAgICBpZiAoYnl0ZXMgPiBsKSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYsIHN0YXJ0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYsIHN0YXJ0LCBzdGFydCArIGJ5dGVzKVxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBidWZvZmYgKz0gbFxuICAgIGJ5dGVzIC09IGxcblxuICAgIGlmIChzdGFydClcbiAgICAgIHN0YXJ0ID0gMFxuICB9XG5cbiAgcmV0dXJuIGRzdFxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zaGFsbG93U2xpY2UgPSBmdW5jdGlvbiBzaGFsbG93U2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwXG4gIGVuZCA9IGVuZCB8fCB0aGlzLmxlbmd0aFxuXG4gIGlmIChzdGFydCA8IDApXG4gICAgc3RhcnQgKz0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8IDApXG4gICAgZW5kICs9IHRoaXMubGVuZ3RoXG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KHN0YXJ0KVxuICAgICwgZW5kT2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KGVuZClcbiAgICAsIGJ1ZmZlcnMgPSB0aGlzLl9idWZzLnNsaWNlKHN0YXJ0T2Zmc2V0WzBdLCBlbmRPZmZzZXRbMF0gKyAxKVxuXG4gIGlmIChlbmRPZmZzZXRbMV0gPT0gMClcbiAgICBidWZmZXJzLnBvcCgpXG4gIGVsc2VcbiAgICBidWZmZXJzW2J1ZmZlcnMubGVuZ3RoLTFdID0gYnVmZmVyc1tidWZmZXJzLmxlbmd0aC0xXS5zbGljZSgwLCBlbmRPZmZzZXRbMV0pXG5cbiAgaWYgKHN0YXJ0T2Zmc2V0WzFdICE9IDApXG4gICAgYnVmZmVyc1swXSA9IGJ1ZmZlcnNbMF0uc2xpY2Uoc3RhcnRPZmZzZXRbMV0pXG5cbiAgcmV0dXJuIG5ldyBCdWZmZXJMaXN0KGJ1ZmZlcnMpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpLnRvU3RyaW5nKGVuY29kaW5nKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gY29uc3VtZSAoYnl0ZXMpIHtcbiAgd2hpbGUgKHRoaXMuX2J1ZnMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzID49IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoKSB7XG4gICAgICBieXRlcyAtPSB0aGlzLl9idWZzWzBdLmxlbmd0aFxuICAgICAgdGhpcy5sZW5ndGggLT0gdGhpcy5fYnVmc1swXS5sZW5ndGhcbiAgICAgIHRoaXMuX2J1ZnMuc2hpZnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idWZzWzBdID0gdGhpcy5fYnVmc1swXS5zbGljZShieXRlcylcbiAgICAgIHRoaXMubGVuZ3RoIC09IGJ5dGVzXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmR1cGxpY2F0ZSA9IGZ1bmN0aW9uIGR1cGxpY2F0ZSAoKSB7XG4gIHZhciBpID0gMFxuICAgICwgY29weSA9IG5ldyBCdWZmZXJMaXN0KClcblxuICBmb3IgKDsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspXG4gICAgY29weS5hcHBlbmQodGhpcy5fYnVmc1tpXSlcblxuICByZXR1cm4gY29weVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdGhpcy5fYnVmcy5sZW5ndGggPSAwXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLnB1c2gobnVsbClcbn1cblxuXG47KGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICAncmVhZERvdWJsZUJFJyA6IDhcbiAgICAsICdyZWFkRG91YmxlTEUnIDogOFxuICAgICwgJ3JlYWRGbG9hdEJFJyAgOiA0XG4gICAgLCAncmVhZEZsb2F0TEUnICA6IDRcbiAgICAsICdyZWFkSW50MzJCRScgIDogNFxuICAgICwgJ3JlYWRJbnQzMkxFJyAgOiA0XG4gICAgLCAncmVhZFVJbnQzMkJFJyA6IDRcbiAgICAsICdyZWFkVUludDMyTEUnIDogNFxuICAgICwgJ3JlYWRJbnQxNkJFJyAgOiAyXG4gICAgLCAncmVhZEludDE2TEUnICA6IDJcbiAgICAsICdyZWFkVUludDE2QkUnIDogMlxuICAgICwgJ3JlYWRVSW50MTZMRScgOiAyXG4gICAgLCAncmVhZEludDgnICAgICA6IDFcbiAgICAsICdyZWFkVUludDgnICAgIDogMVxuICB9XG5cbiAgZm9yICh2YXIgbSBpbiBtZXRob2RzKSB7XG4gICAgKGZ1bmN0aW9uIChtKSB7XG4gICAgICBCdWZmZXJMaXN0LnByb3RvdHlwZVttXSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBtZXRob2RzW21dKVttXSgwKVxuICAgICAgfVxuICAgIH0obSkpXG4gIH1cbn0oKSlcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3RcblxufSx7XCJyZWFkYWJsZS1zdHJlYW0vZHVwbGV4XCI6OTcsXCJzYWZlLWJ1ZmZlclwiOjExMCxcInV0aWxcIjoxMTd9XSw4NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgbWF4ID0gNjU1MzZcbnZhciBjYWNoZSA9IHt9XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQnVmZmVyIChpKSB7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMilcbiAgYnVmZmVyLndyaXRlVUludDgoaSA+PiA4LCAwKVxuICBidWZmZXIud3JpdGVVSW50OChpICYgMHgwMEZGLCAwICsgMSlcblxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ2FjaGUgKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgY2FjaGVbaV0gPSBnZW5lcmF0ZUJ1ZmZlcihpKVxuICB9XG59XG5cbi8qKlxuICogY2FsY1ZhcmlhYmxlQnl0ZUludExlbmd0aCAtIGNhbGN1bGF0ZSB0aGUgdmFyaWFibGUgYnl0ZSBpbnRlZ2VyXG4gKiBsZW5ndGggZmllbGRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsY1ZhcmlhYmxlQnl0ZUludExlbmd0aCAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPj0gMCAmJiBsZW5ndGggPCAxMjgpIHJldHVybiAxXG4gIGVsc2UgaWYgKGxlbmd0aCA+PSAxMjggJiYgbGVuZ3RoIDwgMTYzODQpIHJldHVybiAyXG4gIGVsc2UgaWYgKGxlbmd0aCA+PSAxNjM4NCAmJiBsZW5ndGggPCAyMDk3MTUyKSByZXR1cm4gM1xuICBlbHNlIGlmIChsZW5ndGggPj0gMjA5NzE1MiAmJiBsZW5ndGggPCAyNjg0MzU0NTYpIHJldHVybiA0XG4gIGVsc2UgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gZ2VuQnVmVmFyaWFibGVCeXRlSW50IChudW0pIHtcbiAgdmFyIGRpZ2l0ID0gMFxuICB2YXIgcG9zID0gMFxuICB2YXIgbGVuZ3RoID0gY2FsY1ZhcmlhYmxlQnl0ZUludExlbmd0aChudW0pXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuXG4gIGRvIHtcbiAgICBkaWdpdCA9IG51bSAlIDEyOCB8IDBcbiAgICBudW0gPSBudW0gLyAxMjggfCAwXG4gICAgaWYgKG51bSA+IDApIGRpZ2l0ID0gZGlnaXQgfCAweDgwXG5cbiAgICBidWZmZXIud3JpdGVVSW50OChkaWdpdCwgcG9zKyspXG4gIH0gd2hpbGUgKG51bSA+IDApXG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBidWZmZXIsXG4gICAgbGVuZ3RoOiBsZW5ndGhcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZTRCeXRlQnVmZmVyIChudW0pIHtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KVxuICBidWZmZXIud3JpdGVVSW50MzJCRShudW0sIDApXG4gIHJldHVybiBidWZmZXJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNhY2hlOiBjYWNoZSxcbiAgZ2VuZXJhdGVDYWNoZTogZ2VuZXJhdGVDYWNoZSxcbiAgZ2VuZXJhdGVOdW1iZXI6IGdlbmVyYXRlQnVmZmVyLFxuICBnZW5CdWZWYXJpYWJsZUJ5dGVJbnQ6IGdlbkJ1ZlZhcmlhYmxlQnl0ZUludCxcbiAgZ2VuZXJhdGU0Qnl0ZUJ1ZmZlcjogZ2VuZXJhdGU0Qnl0ZUJ1ZmZlclxufVxuXG59LHtcInNhZmUtYnVmZmVyXCI6MTEwfV0sODc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG5mdW5jdGlvbiBQYWNrZXQgKCkge1xuICB0aGlzLmNtZCA9IG51bGxcbiAgdGhpcy5yZXRhaW4gPSBmYWxzZVxuICB0aGlzLnFvcyA9IDBcbiAgdGhpcy5kdXAgPSBmYWxzZVxuICB0aGlzLmxlbmd0aCA9IC0xXG4gIHRoaXMudG9waWMgPSBudWxsXG4gIHRoaXMucGF5bG9hZCA9IG51bGxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYWNrZXRcblxufSx7fV0sODg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciBibCA9IHJlcXVpcmUoJ2JsJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIFBhY2tldCA9IHJlcXVpcmUoJy4vcGFja2V0JylcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmZ1bmN0aW9uIFBhcnNlciAob3B0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXJzZXIpKSByZXR1cm4gbmV3IFBhcnNlcihvcHQpXG5cbiAgdGhpcy5zZXR0aW5ncyA9IG9wdCB8fCB7fVxuXG4gIHRoaXMuX3N0YXRlcyA9IFtcbiAgICAnX3BhcnNlSGVhZGVyJyxcbiAgICAnX3BhcnNlTGVuZ3RoJyxcbiAgICAnX3BhcnNlUGF5bG9hZCcsXG4gICAgJ19uZXdQYWNrZXQnXG4gIF1cblxuICB0aGlzLl9yZXNldFN0YXRlKClcbn1cblxuaW5oZXJpdHMoUGFyc2VyLCBFRSlcblxuUGFyc2VyLnByb3RvdHlwZS5fcmVzZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wYWNrZXQgPSBuZXcgUGFja2V0KClcbiAgdGhpcy5lcnJvciA9IG51bGxcbiAgdGhpcy5fbGlzdCA9IGJsKClcbiAgdGhpcy5fc3RhdGVDb3VudGVyID0gMFxufVxuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5lcnJvcikgdGhpcy5fcmVzZXRTdGF0ZSgpXG5cbiAgdGhpcy5fbGlzdC5hcHBlbmQoYnVmKVxuXG4gIHdoaWxlICgodGhpcy5wYWNrZXQubGVuZ3RoICE9PSAtMSB8fCB0aGlzLl9saXN0Lmxlbmd0aCA+IDApICYmXG4gIHRoaXNbdGhpcy5fc3RhdGVzW3RoaXMuX3N0YXRlQ291bnRlcl1dKCkgJiZcbiAgIXRoaXMuZXJyb3IpIHtcbiAgICB0aGlzLl9zdGF0ZUNvdW50ZXIrK1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlQ291bnRlciA+PSB0aGlzLl9zdGF0ZXMubGVuZ3RoKSB0aGlzLl9zdGF0ZUNvdW50ZXIgPSAwXG4gIH1cblxuICByZXR1cm4gdGhpcy5fbGlzdC5sZW5ndGhcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBieXRlIGluIHRoZSBidWZmZXJcbiAgdmFyIHplcm8gPSB0aGlzLl9saXN0LnJlYWRVSW50OCgwKVxuICB0aGlzLnBhY2tldC5jbWQgPSBjb25zdGFudHMudHlwZXNbemVybyA+PiBjb25zdGFudHMuQ01EX1NISUZUXVxuICB0aGlzLnBhY2tldC5yZXRhaW4gPSAoemVybyAmIGNvbnN0YW50cy5SRVRBSU5fTUFTSykgIT09IDBcbiAgdGhpcy5wYWNrZXQucW9zID0gKHplcm8gPj4gY29uc3RhbnRzLlFPU19TSElGVCkgJiBjb25zdGFudHMuUU9TX01BU0tcbiAgdGhpcy5wYWNrZXQuZHVwID0gKHplcm8gJiBjb25zdGFudHMuRFVQX01BU0spICE9PSAwXG5cbiAgdGhpcy5fbGlzdC5jb25zdW1lKDEpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBieXRlIGluIHRoZSBsaXN0XG4gIHZhciByZXN1bHQgPSB0aGlzLl9wYXJzZVZhckJ5dGVOdW0odHJ1ZSlcblxuICBpZiAocmVzdWx0KSB7XG4gICAgdGhpcy5wYWNrZXQubGVuZ3RoID0gcmVzdWx0LnZhbHVlXG4gICAgdGhpcy5fbGlzdC5jb25zdW1lKHJlc3VsdC5ieXRlcylcbiAgfVxuXG4gIHJldHVybiAhIXJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVBheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZXN1bHQgPSBmYWxzZVxuXG4gIC8vIERvIHdlIGhhdmUgYSBwYXlsb2FkPyBEbyB3ZSBoYXZlIGVub3VnaCBkYXRhIHRvIGNvbXBsZXRlIHRoZSBwYXlsb2FkP1xuICAvLyBQSU5HcyBoYXZlIG5vIHBheWxvYWRcbiAgaWYgKHRoaXMucGFja2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9saXN0Lmxlbmd0aCA+PSB0aGlzLnBhY2tldC5sZW5ndGgpIHtcbiAgICB0aGlzLl9wb3MgPSAwXG5cbiAgICBzd2l0Y2ggKHRoaXMucGFja2V0LmNtZCkge1xuICAgICAgY2FzZSAnY29ubmVjdCc6XG4gICAgICAgIHRoaXMuX3BhcnNlQ29ubmVjdCgpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdjb25uYWNrJzpcbiAgICAgICAgdGhpcy5fcGFyc2VDb25uYWNrKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3B1Ymxpc2gnOlxuICAgICAgICB0aGlzLl9wYXJzZVB1Ymxpc2goKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHViYWNrJzpcbiAgICAgIGNhc2UgJ3B1YnJlYyc6XG4gICAgICBjYXNlICdwdWJyZWwnOlxuICAgICAgY2FzZSAncHViY29tcCc6XG4gICAgICAgIHRoaXMuX3BhcnNlQ29uZmlybWF0aW9uKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3N1YnNjcmliZSc6XG4gICAgICAgIHRoaXMuX3BhcnNlU3Vic2NyaWJlKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3N1YmFjayc6XG4gICAgICAgIHRoaXMuX3BhcnNlU3ViYWNrKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJlJzpcbiAgICAgICAgdGhpcy5fcGFyc2VVbnN1YnNjcmliZSgpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd1bnN1YmFjayc6XG4gICAgICAgIHRoaXMuX3BhcnNlVW5zdWJhY2soKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncGluZ3JlcSc6XG4gICAgICBjYXNlICdwaW5ncmVzcCc6XG4gICAgICAgIC8vIFRoZXNlIGFyZSBlbXB0eSwgbm90aGluZyB0byBkb1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnZGlzY29ubmVjdCc6XG4gICAgICAgIHRoaXMuX3BhcnNlRGlzY29ubmVjdCgpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdhdXRoJzpcbiAgICAgICAgdGhpcy5fcGFyc2VBdXRoKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQnKSlcbiAgICB9XG5cbiAgICByZXN1bHQgPSB0cnVlXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlQ29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb3RvY29sSWQgLy8gUHJvdG9jb2wgSURcbiAgdmFyIGNsaWVudElkIC8vIENsaWVudCBJRFxuICB2YXIgdG9waWMgLy8gV2lsbCB0b3BpY1xuICB2YXIgcGF5bG9hZCAvLyBXaWxsIHBheWxvYWRcbiAgdmFyIHBhc3N3b3JkIC8vIFBhc3N3b3JkXG4gIHZhciB1c2VybmFtZSAvLyBVc2VybmFtZVxuICB2YXIgZmxhZ3MgPSB7fVxuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcblxuICAvLyBQYXJzZSBwcm90b2NvbElkXG4gIHByb3RvY29sSWQgPSB0aGlzLl9wYXJzZVN0cmluZygpXG5cbiAgaWYgKHByb3RvY29sSWQgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgcHJvdG9jb2xJZCcpKVxuICBpZiAocHJvdG9jb2xJZCAhPT0gJ01RVFQnICYmIHByb3RvY29sSWQgIT09ICdNUUlzZHAnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2xJZCcpKVxuICB9XG5cbiAgcGFja2V0LnByb3RvY29sSWQgPSBwcm90b2NvbElkXG5cbiAgLy8gUGFyc2UgY29uc3RhbnRzIHZlcnNpb24gbnVtYmVyXG4gIGlmICh0aGlzLl9wb3MgPj0gdGhpcy5fbGlzdC5sZW5ndGgpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdQYWNrZXQgdG9vIHNob3J0JykpXG5cbiAgcGFja2V0LnByb3RvY29sVmVyc2lvbiA9IHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcylcblxuICBpZiAocGFja2V0LnByb3RvY29sVmVyc2lvbiAhPT0gMyAmJiBwYWNrZXQucHJvdG9jb2xWZXJzaW9uICE9PSA0ICYmIHBhY2tldC5wcm90b2NvbFZlcnNpb24gIT09IDUpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignSW52YWxpZCBwcm90b2NvbCB2ZXJzaW9uJykpXG4gIH1cblxuICB0aGlzLl9wb3MrK1xuXG4gIGlmICh0aGlzLl9wb3MgPj0gdGhpcy5fbGlzdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignUGFja2V0IHRvbyBzaG9ydCcpKVxuICB9XG5cbiAgLy8gUGFyc2UgY29ubmVjdCBmbGFnc1xuICBmbGFncy51c2VybmFtZSA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICYgY29uc3RhbnRzLlVTRVJOQU1FX01BU0spXG4gIGZsYWdzLnBhc3N3b3JkID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJiBjb25zdGFudHMuUEFTU1dPUkRfTUFTSylcbiAgZmxhZ3Mud2lsbCA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICYgY29uc3RhbnRzLldJTExfRkxBR19NQVNLKVxuXG4gIGlmIChmbGFncy53aWxsKSB7XG4gICAgcGFja2V0LndpbGwgPSB7fVxuICAgIHBhY2tldC53aWxsLnJldGFpbiA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICYgY29uc3RhbnRzLldJTExfUkVUQUlOX01BU0spICE9PSAwXG4gICAgcGFja2V0LndpbGwucW9zID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMuV0lMTF9RT1NfTUFTSykgPj4gY29uc3RhbnRzLldJTExfUU9TX1NISUZUXG4gIH1cblxuICBwYWNrZXQuY2xlYW4gPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5DTEVBTl9TRVNTSU9OX01BU0spICE9PSAwXG4gIHRoaXMuX3BvcysrXG5cbiAgLy8gUGFyc2Uga2VlcGFsaXZlXG4gIHBhY2tldC5rZWVwYWxpdmUgPSB0aGlzLl9wYXJzZU51bSgpXG4gIGlmIChwYWNrZXQua2VlcGFsaXZlID09PSAtMSkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcblxuICAvLyBwYXJzZSBwcm9wZXJ0aWVzXG4gIGlmIChwYWNrZXQucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wYXJzZVByb3BlcnRpZXMoKVxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKS5sZW5ndGgpIHtcbiAgICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1xuICAgIH1cbiAgfVxuICAvLyBQYXJzZSBjbGllbnRJZFxuICBjbGllbnRJZCA9IHRoaXMuX3BhcnNlU3RyaW5nKClcbiAgaWYgKGNsaWVudElkID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignUGFja2V0IHRvbyBzaG9ydCcpKVxuICBwYWNrZXQuY2xpZW50SWQgPSBjbGllbnRJZFxuXG4gIGlmIChmbGFncy53aWxsKSB7XG4gICAgaWYgKHBhY2tldC5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICAgIHZhciB3aWxsUHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2lsbFByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgICBwYWNrZXQud2lsbC5wcm9wZXJ0aWVzID0gd2lsbFByb3BlcnRpZXNcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUGFyc2Ugd2lsbCB0b3BpY1xuICAgIHRvcGljID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuICAgIGlmICh0b3BpYyA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB3aWxsIHRvcGljJykpXG4gICAgcGFja2V0LndpbGwudG9waWMgPSB0b3BpY1xuXG4gICAgLy8gUGFyc2Ugd2lsbCBwYXlsb2FkXG4gICAgcGF5bG9hZCA9IHRoaXMuX3BhcnNlQnVmZmVyKClcbiAgICBpZiAocGF5bG9hZCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB3aWxsIHBheWxvYWQnKSlcbiAgICBwYWNrZXQud2lsbC5wYXlsb2FkID0gcGF5bG9hZFxuICB9XG5cbiAgLy8gUGFyc2UgdXNlcm5hbWVcbiAgaWYgKGZsYWdzLnVzZXJuYW1lKSB7XG4gICAgdXNlcm5hbWUgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgaWYgKHVzZXJuYW1lID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHVzZXJuYW1lJykpXG4gICAgcGFja2V0LnVzZXJuYW1lID0gdXNlcm5hbWVcbiAgfVxuXG4gIC8vIFBhcnNlIHBhc3N3b3JkXG4gIGlmIChmbGFncy5wYXNzd29yZCkge1xuICAgIHBhc3N3b3JkID0gdGhpcy5fcGFyc2VCdWZmZXIoKVxuICAgIGlmIChwYXNzd29yZCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBwYXNzd29yZCcpKVxuICAgIHBhY2tldC5wYXNzd29yZCA9IHBhc3N3b3JkXG4gIH1cbiAgLy8gbmVlZCBmb3IgcmlnaHQgcGFyc2UgYXV0aCBwYWNrZXQgYW5kIHNlbGYgc2V0IHVwXG4gIHRoaXMuc2V0dGluZ3MgPSBwYWNrZXRcblxuICByZXR1cm4gcGFja2V0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlQ29ubmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG5cbiAgaWYgKHRoaXMuX2xpc3QubGVuZ3RoIDwgMikgcmV0dXJuIG51bGxcblxuICBwYWNrZXQuc2Vzc2lvblByZXNlbnQgPSAhISh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MrKykgJiBjb25zdGFudHMuU0VTU0lPTlBSRVNFTlRfTUFTSylcbiAgaWYgKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgcGFja2V0LnJlYXNvbkNvZGUgPSB0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MrKylcbiAgfSBlbHNlIHtcbiAgICBwYWNrZXQucmV0dXJuQ29kZSA9IHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcysrKVxuICB9XG5cbiAgaWYgKHBhY2tldC5yZXR1cm5Db2RlID09PSAtMSB8fCBwYWNrZXQucmVhc29uQ29kZSA9PT0gLTEpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgcmV0dXJuIGNvZGUnKSlcbiAgLy8gbXF0dCA1IHByb3BlcnRpZXNcbiAgaWYgKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wYXJzZVByb3BlcnRpZXMoKVxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKS5sZW5ndGgpIHtcbiAgICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1xuICAgIH1cbiAgfVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVB1Ymxpc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuICBwYWNrZXQudG9waWMgPSB0aGlzLl9wYXJzZVN0cmluZygpXG5cbiAgaWYgKHBhY2tldC50b3BpYyA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB0b3BpYycpKVxuXG4gIC8vIFBhcnNlIG1lc3NhZ2VJZFxuICBpZiAocGFja2V0LnFvcyA+IDApIGlmICghdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSkgeyByZXR1cm4gfVxuXG4gIC8vIFByb3BlcnRpZXMgbXF0dCA1XG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB9XG4gIH1cblxuICBwYWNrZXQucGF5bG9hZCA9IHRoaXMuX2xpc3Quc2xpY2UodGhpcy5fcG9zLCBwYWNrZXQubGVuZ3RoKVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG4gIHZhciB0b3BpY1xuICB2YXIgb3B0aW9uc1xuICB2YXIgcW9zXG4gIHZhciByaFxuICB2YXIgcmFwXG4gIHZhciBubFxuICB2YXIgc3Vic2NyaXB0aW9uXG5cbiAgaWYgKHBhY2tldC5xb3MgIT09IDEpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignV3Jvbmcgc3Vic2NyaWJlIGhlYWRlcicpKVxuICB9XG5cbiAgcGFja2V0LnN1YnNjcmlwdGlvbnMgPSBbXVxuXG4gIGlmICghdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSkgeyByZXR1cm4gfVxuXG4gIC8vIFByb3BlcnRpZXMgbXF0dCA1XG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB9XG4gIH1cblxuICB3aGlsZSAodGhpcy5fcG9zIDwgcGFja2V0Lmxlbmd0aCkge1xuICAgIC8vIFBhcnNlIHRvcGljXG4gICAgdG9waWMgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgaWYgKHRvcGljID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHRvcGljJykpXG5cbiAgICBvcHRpb25zID0gdGhpcy5fcGFyc2VCeXRlKClcbiAgICBxb3MgPSBvcHRpb25zICYgY29uc3RhbnRzLlNVQlNDUklCRV9PUFRJT05TX1FPU19NQVNLXG4gICAgbmwgPSAoKG9wdGlvbnMgPj4gY29uc3RhbnRzLlNVQlNDUklCRV9PUFRJT05TX05MX1NISUZUKSAmIGNvbnN0YW50cy5TVUJTQ1JJQkVfT1BUSU9OU19OTF9NQVNLKSAhPT0gMFxuICAgIHJhcCA9ICgob3B0aW9ucyA+PiBjb25zdGFudHMuU1VCU0NSSUJFX09QVElPTlNfUkFQX1NISUZUKSAmIGNvbnN0YW50cy5TVUJTQ1JJQkVfT1BUSU9OU19SQVBfTUFTSykgIT09IDBcbiAgICByaCA9IChvcHRpb25zID4+IGNvbnN0YW50cy5TVUJTQ1JJQkVfT1BUSU9OU19SSF9TSElGVCkgJiBjb25zdGFudHMuU1VCU0NSSUJFX09QVElPTlNfUkhfTUFTS1xuXG4gICAgc3Vic2NyaXB0aW9uID0geyB0b3BpYzogdG9waWMsIHFvczogcW9zIH1cblxuICAgIC8vIG1xdHQgNSBvcHRpb25zXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgICBzdWJzY3JpcHRpb24ubmwgPSBubFxuICAgICAgc3Vic2NyaXB0aW9uLnJhcCA9IHJhcFxuICAgICAgc3Vic2NyaXB0aW9uLnJoID0gcmhcbiAgICB9XG5cbiAgICAvLyBQdXNoIHBhaXIgdG8gc3Vic2NyaXB0aW9uc1xuICAgIHBhY2tldC5zdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKVxuICB9XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlU3ViYWNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcbiAgdGhpcy5wYWNrZXQuZ3JhbnRlZCA9IFtdXG5cbiAgaWYgKCF0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpKSB7IHJldHVybiB9XG5cbiAgLy8gUHJvcGVydGllcyBtcXR0IDVcbiAgaWYgKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wYXJzZVByb3BlcnRpZXMoKVxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKS5sZW5ndGgpIHtcbiAgICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1xuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIGdyYW50ZWQgUW9TZXNcbiAgd2hpbGUgKHRoaXMuX3BvcyA8IHRoaXMucGFja2V0Lmxlbmd0aCkge1xuICAgIHRoaXMucGFja2V0LmdyYW50ZWQucHVzaCh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MrKykpXG4gIH1cbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VVbnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG5cbiAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucyA9IFtdXG5cbiAgLy8gUGFyc2UgbWVzc2FnZUlkXG4gIGlmICghdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSkgeyByZXR1cm4gfVxuXG4gIC8vIFByb3BlcnRpZXMgbXF0dCA1XG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB9XG4gIH1cblxuICB3aGlsZSAodGhpcy5fcG9zIDwgcGFja2V0Lmxlbmd0aCkge1xuICAgIHZhciB0b3BpY1xuXG4gICAgLy8gUGFyc2UgdG9waWNcbiAgICB0b3BpYyA9IHRoaXMuX3BhcnNlU3RyaW5nKClcbiAgICBpZiAodG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgdG9waWMnKSlcblxuICAgIC8vIFB1c2ggdG9waWMgdG8gdW5zdWJzY3JpcHRpb25zXG4gICAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucy5wdXNoKHRvcGljKVxuICB9XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlVW5zdWJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuICBpZiAoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgbWVzc2FnZUlkJykpXG4gIC8vIFByb3BlcnRpZXMgbXF0dCA1XG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB9XG4gICAgLy8gUGFyc2UgZ3JhbnRlZCBRb1Nlc1xuICAgIHBhY2tldC5ncmFudGVkID0gW11cbiAgICB3aGlsZSAodGhpcy5fcG9zIDwgdGhpcy5wYWNrZXQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnBhY2tldC5ncmFudGVkLnB1c2godGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspKVxuICAgIH1cbiAgfVxufVxuXG4vLyBwYXJzZSBwYWNrZXRzIGxpa2UgcHViYWNrLCBwdWJyZWMsIHB1YnJlbCwgcHViY29tcFxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VDb25maXJtYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIHRoaXMuX3BhcnNlTWVzc2FnZUlkKClcblxuICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICBpZiAocGFja2V0Lmxlbmd0aCA+IDIpIHtcbiAgICAgIC8vIHJlc3BvbnNlIGNvZGVcbiAgICAgIHBhY2tldC5yZWFzb25Db2RlID0gdGhpcy5fcGFyc2VCeXRlKClcbiAgICAgIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKS5sZW5ndGgpIHtcbiAgICAgICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gcGFyc2UgZGlzY29ubmVjdCBwYWNrZXRcblBhcnNlci5wcm90b3R5cGUuX3BhcnNlRGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG5cbiAgaWYgKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgLy8gcmVzcG9uc2UgY29kZVxuICAgIHBhY2tldC5yZWFzb25Db2RlID0gdGhpcy5fcGFyc2VCeXRlKClcbiAgICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wYXJzZVByb3BlcnRpZXMoKVxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKS5sZW5ndGgpIHtcbiAgICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vIHBhcnNlIGF1dGggcGFja2V0XG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUF1dGggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiAhPT0gNSkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIGF1dGggcGFja2V0IGZvciB0aGlzIHZlcnNpb24gTVFUVCcpKVxuICB9XG5cbiAgLy8gcmVzcG9uc2UgY29kZVxuICBwYWNrZXQucmVhc29uQ29kZSA9IHRoaXMuX3BhcnNlQnl0ZSgpXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wYXJzZVByb3BlcnRpZXMoKVxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZU1lc3NhZ2VJZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG5cbiAgcGFja2V0Lm1lc3NhZ2VJZCA9IHRoaXMuX3BhcnNlTnVtKClcblxuICBpZiAocGFja2V0Lm1lc3NhZ2VJZCA9PT0gbnVsbCkge1xuICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlU3RyaW5nID0gZnVuY3Rpb24gKG1heWJlQnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLl9wYXJzZU51bSgpXG4gIHZhciByZXN1bHRcbiAgdmFyIGVuZCA9IGxlbmd0aCArIHRoaXMuX3Bvc1xuXG4gIGlmIChsZW5ndGggPT09IC0xIHx8IGVuZCA+IHRoaXMuX2xpc3QubGVuZ3RoIHx8IGVuZCA+IHRoaXMucGFja2V0Lmxlbmd0aCkgcmV0dXJuIG51bGxcblxuICByZXN1bHQgPSB0aGlzLl9saXN0LnRvU3RyaW5nKCd1dGY4JywgdGhpcy5fcG9zLCBlbmQpXG4gIHRoaXMuX3BvcyArPSBsZW5ndGhcblxuICByZXR1cm4gcmVzdWx0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlU3RyaW5nUGFpciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiB0aGlzLl9wYXJzZVN0cmluZygpLFxuICAgIHZhbHVlOiB0aGlzLl9wYXJzZVN0cmluZygpXG4gIH1cbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLl9wYXJzZU51bSgpXG4gIHZhciByZXN1bHRcbiAgdmFyIGVuZCA9IGxlbmd0aCArIHRoaXMuX3Bvc1xuXG4gIGlmIChsZW5ndGggPT09IC0xIHx8IGVuZCA+IHRoaXMuX2xpc3QubGVuZ3RoIHx8IGVuZCA+IHRoaXMucGFja2V0Lmxlbmd0aCkgcmV0dXJuIG51bGxcblxuICByZXN1bHQgPSB0aGlzLl9saXN0LnNsaWNlKHRoaXMuX3BvcywgZW5kKVxuXG4gIHRoaXMuX3BvcyArPSBsZW5ndGhcblxuICByZXR1cm4gcmVzdWx0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlTnVtID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fbGlzdC5sZW5ndGggLSB0aGlzLl9wb3MgPCAyKSByZXR1cm4gLTFcblxuICB2YXIgcmVzdWx0ID0gdGhpcy5fbGlzdC5yZWFkVUludDE2QkUodGhpcy5fcG9zKVxuICB0aGlzLl9wb3MgKz0gMlxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2U0Qnl0ZU51bSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2xpc3QubGVuZ3RoIC0gdGhpcy5fcG9zIDwgNCkgcmV0dXJuIC0xXG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2xpc3QucmVhZFVJbnQzMkJFKHRoaXMuX3BvcylcbiAgdGhpcy5fcG9zICs9IDRcblxuICByZXR1cm4gcmVzdWx0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlVmFyQnl0ZU51bSA9IGZ1bmN0aW9uIChmdWxsSW5mb0ZsYWcpIHtcbiAgdmFyIGJ5dGVzID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgbGVuZ3RoID0gMFxuICB2YXIgcmVzdWx0ID0gdHJ1ZVxuICB2YXIgY3VycmVudFxuICB2YXIgcGFkZGluZyA9IHRoaXMuX3BvcyA/IHRoaXMuX3BvcyA6IDBcblxuICB3aGlsZSAoYnl0ZXMgPCA1KSB7XG4gICAgY3VycmVudCA9IHRoaXMuX2xpc3QucmVhZFVJbnQ4KHBhZGRpbmcgKyBieXRlcysrKVxuICAgIGxlbmd0aCArPSBtdWwgKiAoY3VycmVudCAmIGNvbnN0YW50cy5MRU5HVEhfTUFTSylcbiAgICBtdWwgKj0gMHg4MFxuXG4gICAgaWYgKChjdXJyZW50ICYgY29uc3RhbnRzLkxFTkdUSF9GSU5fTUFTSykgPT09IDApIGJyZWFrXG4gICAgaWYgKHRoaXMuX2xpc3QubGVuZ3RoIDw9IGJ5dGVzKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAocGFkZGluZykge1xuICAgIHRoaXMuX3BvcyArPSBieXRlc1xuICB9XG5cbiAgcmVzdWx0ID0gcmVzdWx0XG4gICAgPyBmdWxsSW5mb0ZsYWcgPyB7XG4gICAgICBieXRlczogYnl0ZXMsXG4gICAgICB2YWx1ZTogbGVuZ3RoXG4gICAgfSA6IGxlbmd0aFxuICAgIDogZmFsc2VcblxuICByZXR1cm4gcmVzdWx0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlQnl0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcylcbiAgdGhpcy5fcG9zKytcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUJ5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2J5dGUnOiB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VCeXRlKCkgIT09IDBcbiAgICB9XG4gICAgY2FzZSAnaW50OCc6IHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZUJ5dGUoKVxuICAgIH1cbiAgICBjYXNlICdpbnQxNic6IHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZU51bSgpXG4gICAgfVxuICAgIGNhc2UgJ2ludDMyJzoge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlNEJ5dGVOdW0oKVxuICAgIH1cbiAgICBjYXNlICd2YXInOiB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VWYXJCeXRlTnVtKClcbiAgICB9XG4gICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlU3RyaW5nKClcbiAgICB9XG4gICAgY2FzZSAncGFpcic6IHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZVN0cmluZ1BhaXIoKVxuICAgIH1cbiAgICBjYXNlICdiaW5hcnknOiB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VCdWZmZXIoKVxuICAgIH1cbiAgfVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLl9wYXJzZVZhckJ5dGVOdW0oKVxuICB2YXIgc3RhcnQgPSB0aGlzLl9wb3NcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgbGVuZ3RoXG4gIHZhciByZXN1bHQgPSB7fVxuICB3aGlsZSAodGhpcy5fcG9zIDwgZW5kKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl9wYXJzZUJ5dGUoKVxuICAgIHZhciBuYW1lID0gY29uc3RhbnRzLnByb3BlcnRpZXNDb2Rlc1t0eXBlXVxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignVW5rbm93biBwcm9wZXJ0eScpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8vIHVzZXIgcHJvcGVydGllcyBwcm9jZXNzXG4gICAgaWYgKG5hbWUgPT09ICd1c2VyUHJvcGVydGllcycpIHtcbiAgICAgIGlmICghcmVzdWx0W25hbWVdKSB7XG4gICAgICAgIHJlc3VsdFtuYW1lXSA9IHt9XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudFVzZXJQcm9wZXJ0eSA9IHRoaXMuX3BhcnNlQnlUeXBlKGNvbnN0YW50cy5wcm9wZXJ0aWVzVHlwZXNbbmFtZV0pXG4gICAgICByZXN1bHRbbmFtZV1bY3VycmVudFVzZXJQcm9wZXJ0eS5uYW1lXSA9IGN1cnJlbnRVc2VyUHJvcGVydHkudmFsdWVcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHJlc3VsdFtuYW1lXSA9IHRoaXMuX3BhcnNlQnlUeXBlKGNvbnN0YW50cy5wcm9wZXJ0aWVzVHlwZXNbbmFtZV0pXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9uZXdQYWNrZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhY2tldCkge1xuICAgIHRoaXMuX2xpc3QuY29uc3VtZSh0aGlzLnBhY2tldC5sZW5ndGgpXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCB0aGlzLnBhY2tldClcbiAgfVxuXG4gIHRoaXMucGFja2V0ID0gbmV3IFBhY2tldCgpXG5cbiAgdGhpcy5fcG9zID0gMFxuXG4gIHJldHVybiB0cnVlXG59XG5cblBhcnNlci5wcm90b3R5cGUuX2VtaXRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdGhpcy5lcnJvciA9IGVyclxuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlclxuXG59LHtcIi4vY29uc3RhbnRzXCI6ODIsXCIuL3BhY2tldFwiOjg3LFwiYmxcIjo4NSxcImV2ZW50c1wiOjEzLFwiaW5oZXJpdHNcIjo4MH1dLDg5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgcHJvdG9jb2wgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBlbXB0eSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxudmFyIHplcm9CdWYgPSBCdWZmZXIuZnJvbShbMF0pXG52YXIgbnVtYmVycyA9IHJlcXVpcmUoJy4vbnVtYmVycycpXG52YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpLm5leHRUaWNrXG5cbnZhciBudW1DYWNoZSA9IG51bWJlcnMuY2FjaGVcbnZhciBnZW5lcmF0ZU51bWJlciA9IG51bWJlcnMuZ2VuZXJhdGVOdW1iZXJcbnZhciBnZW5lcmF0ZUNhY2hlID0gbnVtYmVycy5nZW5lcmF0ZUNhY2hlXG52YXIgZ2VuQnVmVmFyaWFibGVCeXRlSW50ID0gbnVtYmVycy5nZW5CdWZWYXJpYWJsZUJ5dGVJbnRcbnZhciBnZW5lcmF0ZTRCeXRlQnVmZmVyID0gbnVtYmVycy5nZW5lcmF0ZTRCeXRlQnVmZmVyXG52YXIgd3JpdGVOdW1iZXIgPSB3cml0ZU51bWJlckNhY2hlZFxudmFyIHRvR2VuZXJhdGUgPSB0cnVlXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICBpZiAoc3RyZWFtLmNvcmspIHtcbiAgICBzdHJlYW0uY29yaygpXG4gICAgbmV4dFRpY2sodW5jb3JrLCBzdHJlYW0pXG4gIH1cblxuICBpZiAodG9HZW5lcmF0ZSkge1xuICAgIHRvR2VuZXJhdGUgPSBmYWxzZVxuICAgIGdlbmVyYXRlQ2FjaGUoKVxuICB9XG5cbiAgc3dpdGNoIChwYWNrZXQuY21kKSB7XG4gICAgY2FzZSAnY29ubmVjdCc6XG4gICAgICByZXR1cm4gY29ubmVjdChwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdjb25uYWNrJzpcbiAgICAgIHJldHVybiBjb25uYWNrKHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ3B1Ymxpc2gnOlxuICAgICAgcmV0dXJuIHB1Ymxpc2gocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gICAgY2FzZSAncHViYWNrJzpcbiAgICBjYXNlICdwdWJyZWMnOlxuICAgIGNhc2UgJ3B1YnJlbCc6XG4gICAgY2FzZSAncHViY29tcCc6XG4gICAgICByZXR1cm4gY29uZmlybWF0aW9uKHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ3N1YnNjcmliZSc6XG4gICAgICByZXR1cm4gc3Vic2NyaWJlKHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ3N1YmFjayc6XG4gICAgICByZXR1cm4gc3ViYWNrKHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ3Vuc3Vic2NyaWJlJzpcbiAgICAgIHJldHVybiB1bnN1YnNjcmliZShwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICd1bnN1YmFjayc6XG4gICAgICByZXR1cm4gdW5zdWJhY2socGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gICAgY2FzZSAncGluZ3JlcSc6XG4gICAgY2FzZSAncGluZ3Jlc3AnOlxuICAgICAgcmV0dXJuIGVtcHR5UGFja2V0KHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgcmV0dXJuIGRpc2Nvbm5lY3QocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gICAgY2FzZSAnYXV0aCc6XG4gICAgICByZXR1cm4gYXV0aChwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBkZWZhdWx0OlxuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdVbmtub3duIGNvbW1hbmQnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4vKipcbiAqIENvbnRyb2xzIG51bWJlcnMgY2FjaGUuXG4gKiBTZXQgdG8gXCJmYWxzZVwiIHRvIGFsbG9jYXRlIGJ1ZmZlcnMgb24tdGhlLWZsaWdodCBpbnN0ZWFkIG9mIHByZS1nZW5lcmF0ZWQgY2FjaGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGdlbmVyYXRlLCAnY2FjaGVOdW1iZXJzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd3JpdGVOdW1iZXIgPT09IHdyaXRlTnVtYmVyQ2FjaGVkXG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIW51bUNhY2hlIHx8IE9iamVjdC5rZXlzKG51bUNhY2hlKS5sZW5ndGggPT09IDApIHRvR2VuZXJhdGUgPSB0cnVlXG4gICAgICB3cml0ZU51bWJlciA9IHdyaXRlTnVtYmVyQ2FjaGVkXG4gICAgfSBlbHNlIHtcbiAgICAgIHRvR2VuZXJhdGUgPSBmYWxzZVxuICAgICAgd3JpdGVOdW1iZXIgPSB3cml0ZU51bWJlckdlbmVyYXRlZFxuICAgIH1cbiAgfVxufSlcblxuZnVuY3Rpb24gdW5jb3JrIChzdHJlYW0pIHtcbiAgc3RyZWFtLnVuY29yaygpXG59XG5cbmZ1bmN0aW9uIGNvbm5lY3QgKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIHZhciBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICB2YXIgcHJvdG9jb2xJZCA9IHNldHRpbmdzLnByb3RvY29sSWQgfHwgJ01RVFQnXG4gIHZhciBwcm90b2NvbFZlcnNpb24gPSBzZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gfHwgNFxuICB2YXIgd2lsbCA9IHNldHRpbmdzLndpbGxcbiAgdmFyIGNsZWFuID0gc2V0dGluZ3MuY2xlYW5cbiAgdmFyIGtlZXBhbGl2ZSA9IHNldHRpbmdzLmtlZXBhbGl2ZSB8fCAwXG4gIHZhciBjbGllbnRJZCA9IHNldHRpbmdzLmNsaWVudElkIHx8ICcnXG4gIHZhciB1c2VybmFtZSA9IHNldHRpbmdzLnVzZXJuYW1lXG4gIHZhciBwYXNzd29yZCA9IHNldHRpbmdzLnBhc3N3b3JkXG4gIC8qIG1xdHQ1IG5ldyBvcHJpb25zICovXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuXG4gIGlmIChjbGVhbiA9PT0gdW5kZWZpbmVkKSBjbGVhbiA9IHRydWVcblxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIC8vIE11c3QgYmUgYSBzdHJpbmcgYW5kIG5vbi1mYWxzeVxuICBpZiAoIXByb3RvY29sSWQgfHxcbiAgICAgKHR5cGVvZiBwcm90b2NvbElkICE9PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzQnVmZmVyKHByb3RvY29sSWQpKSkge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBwcm90b2NvbElkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBsZW5ndGggKz0gcHJvdG9jb2xJZC5sZW5ndGggKyAyXG5cbiAgLy8gTXVzdCBiZSAzIG9yIDQgb3IgNVxuICBpZiAocHJvdG9jb2xWZXJzaW9uICE9PSAzICYmIHByb3RvY29sVmVyc2lvbiAhPT0gNCAmJiBwcm90b2NvbFZlcnNpb24gIT09IDUpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2wgdmVyc2lvbicpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IDFcblxuICAvLyBDbGllbnRJZCBtaWdodCBiZSBvbWl0dGVkIGluIDMuMS4xLCBidXQgb25seSBpZiBjbGVhblNlc3Npb24gaXMgc2V0IHRvIDFcbiAgaWYgKCh0eXBlb2YgY2xpZW50SWQgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihjbGllbnRJZCkpICYmXG4gICAgIChjbGllbnRJZCB8fCBwcm90b2NvbFZlcnNpb24gPT09IDQpICYmIChjbGllbnRJZCB8fCBjbGVhbikpIHtcbiAgICBsZW5ndGggKz0gY2xpZW50SWQubGVuZ3RoICsgMlxuICB9IGVsc2Uge1xuICAgIGlmIChwcm90b2NvbFZlcnNpb24gPCA0KSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2NsaWVudElkIG11c3QgYmUgc3VwcGxpZWQgYmVmb3JlIDMuMS4xJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKChjbGVhbiAqIDEpID09PSAwKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2NsaWVudElkIG11c3QgYmUgZ2l2ZW4gaWYgY2xlYW5TZXNzaW9uIHNldCB0byAwJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBNdXN0IGJlIGEgdHdvIGJ5dGUgbnVtYmVyXG4gIGlmICh0eXBlb2Yga2VlcGFsaXZlICE9PSAnbnVtYmVyJyB8fFxuICAgICAga2VlcGFsaXZlIDwgMCB8fFxuICAgICAga2VlcGFsaXZlID4gNjU1MzUgfHxcbiAgICAgIGtlZXBhbGl2ZSAlIDEgIT09IDApIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQga2VlcGFsaXZlJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBsZW5ndGggKz0gMlxuXG4gIC8vIENvbm5lY3QgZmxhZ3NcbiAgbGVuZ3RoICs9IDFcblxuICAvLyBQcm9wZXJ0aWVzXG4gIGlmIChwcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICB2YXIgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcylcbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBJZiB3aWxsIGV4aXN0cy4uLlxuICBpZiAod2lsbCkge1xuICAgIC8vIEl0IG11c3QgYmUgYW4gb2JqZWN0XG4gICAgaWYgKHR5cGVvZiB3aWxsICE9PSAnb2JqZWN0Jykge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHdpbGwnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvLyBJdCBtdXN0IGhhdmUgdG9waWMgdHlwZW9mIHN0cmluZ1xuICAgIGlmICghd2lsbC50b3BpYyB8fCB0eXBlb2Ygd2lsbC50b3BpYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCB3aWxsIHRvcGljJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHdpbGwudG9waWMpICsgMlxuICAgIH1cblxuICAgIC8vIFBheWxvYWRcbiAgICBpZiAod2lsbC5wYXlsb2FkKSB7XG4gICAgICBpZiAod2lsbC5wYXlsb2FkLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2lsbC5wYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh3aWxsLnBheWxvYWQpICsgMlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbmd0aCArPSB3aWxsLnBheWxvYWQubGVuZ3RoICsgMlxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgd2lsbCBwYXlsb2FkJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyB3aWxsIHByb3BlcnRpZXNcbiAgICAgIHZhciB3aWxsUHJvcGVydGllcyA9IHt9XG4gICAgICBpZiAocHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgICAgIHdpbGxQcm9wZXJ0aWVzID0gZ2V0UHJvcGVydGllcyhzdHJlYW0sIHdpbGwucHJvcGVydGllcylcbiAgICAgICAgbGVuZ3RoICs9IHdpbGxQcm9wZXJ0aWVzLmxlbmd0aFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXJuYW1lXG4gIHZhciBwcm92aWRlZFVzZXJuYW1lID0gZmFsc2VcbiAgaWYgKHVzZXJuYW1lICE9IG51bGwpIHtcbiAgICBpZiAoaXNTdHJpbmdPckJ1ZmZlcih1c2VybmFtZSkpIHtcbiAgICAgIHByb3ZpZGVkVXNlcm5hbWUgPSB0cnVlXG4gICAgICBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgodXNlcm5hbWUpICsgMlxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlcm5hbWUnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhc3N3b3JkXG4gIGlmIChwYXNzd29yZCAhPSBudWxsKSB7XG4gICAgaWYgKCFwcm92aWRlZFVzZXJuYW1lKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1VzZXJuYW1lIGlzIHJlcXVpcmVkIHRvIHVzZSBwYXNzd29yZCcpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nT3JCdWZmZXIocGFzc3dvcmQpKSB7XG4gICAgICBsZW5ndGggKz0gYnl0ZUxlbmd0aChwYXNzd29yZCkgKyAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBwYXNzd29yZCcpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgaGVhZGVyXG4gIHN0cmVhbS53cml0ZShwcm90b2NvbC5DT05ORUNUX0hFQURFUilcblxuICAvLyBHZW5lcmF0ZSBsZW5ndGhcbiAgd3JpdGVWYXJCeXRlSW50KHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIEdlbmVyYXRlIHByb3RvY29sIElEXG4gIHdyaXRlU3RyaW5nT3JCdWZmZXIoc3RyZWFtLCBwcm90b2NvbElkKVxuICBzdHJlYW0ud3JpdGUoXG4gICAgcHJvdG9jb2xWZXJzaW9uID09PSA0XG4gICAgICA/IHByb3RvY29sLlZFUlNJT040XG4gICAgICA6IHByb3RvY29sVmVyc2lvbiA9PT0gNVxuICAgICAgICA/IHByb3RvY29sLlZFUlNJT041XG4gICAgICAgIDogcHJvdG9jb2wuVkVSU0lPTjNcbiAgKVxuXG4gIC8vIENvbm5lY3QgZmxhZ3NcbiAgdmFyIGZsYWdzID0gMFxuICBmbGFncyB8PSAodXNlcm5hbWUgIT0gbnVsbCkgPyBwcm90b2NvbC5VU0VSTkFNRV9NQVNLIDogMFxuICBmbGFncyB8PSAocGFzc3dvcmQgIT0gbnVsbCkgPyBwcm90b2NvbC5QQVNTV09SRF9NQVNLIDogMFxuICBmbGFncyB8PSAod2lsbCAmJiB3aWxsLnJldGFpbikgPyBwcm90b2NvbC5XSUxMX1JFVEFJTl9NQVNLIDogMFxuICBmbGFncyB8PSAod2lsbCAmJiB3aWxsLnFvcykgPyB3aWxsLnFvcyA8PCBwcm90b2NvbC5XSUxMX1FPU19TSElGVCA6IDBcbiAgZmxhZ3MgfD0gd2lsbCA/IHByb3RvY29sLldJTExfRkxBR19NQVNLIDogMFxuICBmbGFncyB8PSBjbGVhbiA/IHByb3RvY29sLkNMRUFOX1NFU1NJT05fTUFTSyA6IDBcblxuICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW2ZsYWdzXSkpXG5cbiAgLy8gS2VlcGFsaXZlXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwga2VlcGFsaXZlKVxuXG4gIC8vIFByb3BlcnRpZXNcbiAgaWYgKHByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhLndyaXRlKClcbiAgfVxuXG4gIC8vIENsaWVudCBJRFxuICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgY2xpZW50SWQpXG5cbiAgLy8gV2lsbFxuICBpZiAod2lsbCkge1xuICAgIGlmIChwcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICAgIHdpbGxQcm9wZXJ0aWVzLndyaXRlKClcbiAgICB9XG4gICAgd3JpdGVTdHJpbmcoc3RyZWFtLCB3aWxsLnRvcGljKVxuICAgIHdyaXRlU3RyaW5nT3JCdWZmZXIoc3RyZWFtLCB3aWxsLnBheWxvYWQpXG4gIH1cblxuICAvLyBVc2VybmFtZSBhbmQgcGFzc3dvcmRcbiAgaWYgKHVzZXJuYW1lICE9IG51bGwpIHtcbiAgICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgdXNlcm5hbWUpXG4gIH1cbiAgaWYgKHBhc3N3b3JkICE9IG51bGwpIHtcbiAgICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgcGFzc3dvcmQpXG4gIH1cbiAgLy8gVGhpcyBpcyBhIHNtYWxsIHBhY2tldCB0aGF0IGhhcHBlbnMgb25seSBvbmNlIG9uIGEgc3RyZWFtXG4gIC8vIFdlIGFzc3VtZSB0aGUgc3RyZWFtIGlzIGFsd2F5cyBmcmVlIHRvIHJlY2VpdmUgbW9yZSBkYXRhIGFmdGVyIHRoaXNcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gY29ubmFjayAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgdmFyIHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIHZhciBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICB2YXIgcmMgPSB2ZXJzaW9uID09PSA1ID8gc2V0dGluZ3MucmVhc29uQ29kZSA6IHNldHRpbmdzLnJldHVybkNvZGVcbiAgdmFyIHByb3BlcnRpZXMgPSBzZXR0aW5ncy5wcm9wZXJ0aWVzXG4gIHZhciBsZW5ndGggPSAyIC8vIGxlbmd0aCBvZiByYyBhbmQgc2Vzc2lvbkhlYWRlclxuXG4gIC8vIENoZWNrIHJldHVybiBjb2RlXG4gIGlmICh0eXBlb2YgcmMgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHJldHVybiBjb2RlJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgLy8gbXF0dDUgcHJvcGVydGllc1xuICB2YXIgcHJvcGVydGllc0RhdGEgPSBudWxsXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcylcbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuQ09OTkFDS19IRUFERVIpXG4gIC8vIGxlbmd0aFxuICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCBsZW5ndGgpXG4gIHN0cmVhbS53cml0ZShzZXR0aW5ncy5zZXNzaW9uUHJlc2VudCA/IHByb3RvY29sLlNFU1NJT05QUkVTRU5UX0hFQURFUiA6IHplcm9CdWYpXG5cbiAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtyY10pKVxuICBpZiAocHJvcGVydGllc0RhdGEgIT0gbnVsbCkge1xuICAgIHByb3BlcnRpZXNEYXRhLndyaXRlKClcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoIChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICB2YXIgdmVyc2lvbiA9IG9wdHMgPyBvcHRzLnByb3RvY29sVmVyc2lvbiA6IDRcbiAgdmFyIHNldHRpbmdzID0gcGFja2V0IHx8IHt9XG4gIHZhciBxb3MgPSBzZXR0aW5ncy5xb3MgfHwgMFxuICB2YXIgcmV0YWluID0gc2V0dGluZ3MucmV0YWluID8gcHJvdG9jb2wuUkVUQUlOX01BU0sgOiAwXG4gIHZhciB0b3BpYyA9IHNldHRpbmdzLnRvcGljXG4gIHZhciBwYXlsb2FkID0gc2V0dGluZ3MucGF5bG9hZCB8fCBlbXB0eVxuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcbiAgdmFyIHByb3BlcnRpZXMgPSBzZXR0aW5ncy5wcm9wZXJ0aWVzXG5cbiAgdmFyIGxlbmd0aCA9IDBcblxuICAvLyBUb3BpYyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBCdWZmZXJcbiAgaWYgKHR5cGVvZiB0b3BpYyA9PT0gJ3N0cmluZycpIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh0b3BpYykgKyAyXG4gIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0b3BpYykpIGxlbmd0aCArPSB0b3BpYy5sZW5ndGggKyAyXG4gIGVsc2Uge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCB0b3BpYycpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gR2V0IHRoZSBwYXlsb2FkIGxlbmd0aFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXlsb2FkKSkgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHBheWxvYWQpXG4gIGVsc2UgbGVuZ3RoICs9IHBheWxvYWQubGVuZ3RoXG5cbiAgLy8gTWVzc2FnZSBJRCBtdXN0IGEgbnVtYmVyIGlmIHFvcyA+IDBcbiAgaWYgKHFvcyAmJiB0eXBlb2YgaWQgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHFvcykgbGVuZ3RoICs9IDJcblxuICAvLyBtcXR0NSBwcm9wZXJ0aWVzXG4gIHZhciBwcm9wZXJ0aWVzRGF0YSA9IG51bGxcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXMoc3RyZWFtLCBwcm9wZXJ0aWVzKVxuICAgIGxlbmd0aCArPSBwcm9wZXJ0aWVzRGF0YS5sZW5ndGhcbiAgfVxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuUFVCTElTSF9IRUFERVJbcW9zXVtzZXR0aW5ncy5kdXAgPyAxIDogMF1bcmV0YWluID8gMSA6IDBdKVxuXG4gIC8vIFJlbWFpbmluZyBsZW5ndGhcbiAgd3JpdGVWYXJCeXRlSW50KHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIFRvcGljXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgYnl0ZUxlbmd0aCh0b3BpYykpXG4gIHN0cmVhbS53cml0ZSh0b3BpYylcblxuICAvLyBNZXNzYWdlIElEXG4gIGlmIChxb3MgPiAwKSB3cml0ZU51bWJlcihzdHJlYW0sIGlkKVxuXG4gIC8vIFByb3BlcnRpZXNcbiAgaWYgKHByb3BlcnRpZXNEYXRhICE9IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICAvLyBQYXlsb2FkXG4gIHJldHVybiBzdHJlYW0ud3JpdGUocGF5bG9hZClcbn1cblxuLyogUHViYWNrLCBwdWJyZWMsIHB1YnJlbCBhbmQgcHViY29tcCAqL1xuZnVuY3Rpb24gY29uZmlybWF0aW9uIChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICB2YXIgdmVyc2lvbiA9IG9wdHMgPyBvcHRzLnByb3RvY29sVmVyc2lvbiA6IDRcbiAgdmFyIHNldHRpbmdzID0gcGFja2V0IHx8IHt9XG4gIHZhciB0eXBlID0gc2V0dGluZ3MuY21kIHx8ICdwdWJhY2snXG4gIHZhciBpZCA9IHNldHRpbmdzLm1lc3NhZ2VJZFxuICB2YXIgZHVwID0gKHNldHRpbmdzLmR1cCAmJiB0eXBlID09PSAncHVicmVsJykgPyBwcm90b2NvbC5EVVBfTUFTSyA6IDBcbiAgdmFyIHFvcyA9IDBcbiAgdmFyIHJlYXNvbkNvZGUgPSBzZXR0aW5ncy5yZWFzb25Db2RlXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuICB2YXIgbGVuZ3RoID0gdmVyc2lvbiA9PT0gNSA/IDMgOiAyXG5cbiAgaWYgKHR5cGUgPT09ICdwdWJyZWwnKSBxb3MgPSAxXG5cbiAgLy8gQ2hlY2sgbWVzc2FnZSBJRFxuICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgdmFyIHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllc0J5TWF4aW11bVBhY2tldFNpemUoc3RyZWFtLCBwcm9wZXJ0aWVzLCBvcHRzLCBsZW5ndGgpXG4gICAgaWYgKCFwcm9wZXJ0aWVzRGF0YSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGxlbmd0aCArPSBwcm9wZXJ0aWVzRGF0YS5sZW5ndGhcbiAgfVxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuQUNLU1t0eXBlXVtxb3NdW2R1cF1bMF0pXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBNZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gcmVhc29uIGNvZGUgaW4gaGVhZGVyXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtyZWFzb25Db2RlXSkpXG4gIH1cblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPT0gbnVsbCkge1xuICAgIHByb3BlcnRpZXNEYXRhLndyaXRlKClcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUgKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIHZhciB2ZXJzaW9uID0gb3B0cyA/IG9wdHMucHJvdG9jb2xWZXJzaW9uIDogNFxuICB2YXIgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgdmFyIGR1cCA9IHNldHRpbmdzLmR1cCA/IHByb3RvY29sLkRVUF9NQVNLIDogMFxuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcbiAgdmFyIHN1YnMgPSBzZXR0aW5ncy5zdWJzY3JpcHRpb25zXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuXG4gIHZhciBsZW5ndGggPSAwXG5cbiAgLy8gQ2hlY2sgbWVzc2FnZSBJRFxuICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGxlbmd0aCArPSAyXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICB2YXIgcHJvcGVydGllc0RhdGEgPSBudWxsXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcylcbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBDaGVjayBzdWJzY3JpcHRpb25zXG4gIGlmICh0eXBlb2Ygc3VicyA9PT0gJ29iamVjdCcgJiYgc3Vicy5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBpdG9waWMgPSBzdWJzW2ldLnRvcGljXG4gICAgICB2YXIgaXFvcyA9IHN1YnNbaV0ucW9zXG5cbiAgICAgIGlmICh0eXBlb2YgaXRvcGljICE9PSAnc3RyaW5nJykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2NyaXB0aW9ucyAtIGludmFsaWQgdG9waWMnKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGlxb3MgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBzdWJzY3JpcHRpb25zIC0gaW52YWxpZCBxb3MnKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgICAgIHZhciBubCA9IHN1YnNbaV0ubmwgfHwgZmFsc2VcbiAgICAgICAgaWYgKHR5cGVvZiBubCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMgLSBpbnZhbGlkIE5vIExvY2FsJykpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhcCA9IHN1YnNbaV0ucmFwIHx8IGZhbHNlXG4gICAgICAgIGlmICh0eXBlb2YgcmFwICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2NyaXB0aW9ucyAtIGludmFsaWQgUmV0YWluIGFzIFB1Ymxpc2hlZCcpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHZhciByaCA9IHN1YnNbaV0ucmggfHwgMFxuICAgICAgICBpZiAodHlwZW9mIHJoICE9PSAnbnVtYmVyJyB8fCByaCA+IDIpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2NyaXB0aW9ucyAtIGludmFsaWQgUmV0YWluIEhhbmRsaW5nJykpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKGl0b3BpYykgKyAyICsgMVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2NyaXB0aW9ucycpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgaGVhZGVyXG4gIHN0cmVhbS53cml0ZShwcm90b2NvbC5TVUJTQ1JJQkVfSEVBREVSWzFdW2R1cCA/IDEgOiAwXVswXSlcblxuICAvLyBHZW5lcmF0ZSBsZW5ndGhcbiAgd3JpdGVWYXJCeXRlSW50KHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIEdlbmVyYXRlIG1lc3NhZ2UgSURcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPT0gbnVsbCkge1xuICAgIHByb3BlcnRpZXNEYXRhLndyaXRlKClcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnVlXG5cbiAgLy8gR2VuZXJhdGUgc3Vic1xuICBmb3IgKHZhciBqID0gMDsgaiA8IHN1YnMubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgc3ViID0gc3Vic1tqXVxuICAgIHZhciBqdG9waWMgPSBzdWIudG9waWNcbiAgICB2YXIganFvcyA9IHN1Yi5xb3NcbiAgICB2YXIgam5sID0gK3N1Yi5ubFxuICAgIHZhciBqcmFwID0gK3N1Yi5yYXBcbiAgICB2YXIganJoID0gc3ViLnJoXG4gICAgdmFyIGpvcHRpb25zXG5cbiAgICAvLyBXcml0ZSB0b3BpYyBzdHJpbmdcbiAgICB3cml0ZVN0cmluZyhzdHJlYW0sIGp0b3BpYylcblxuICAgIC8vIG9wdGlvbnMgcHJvY2Vzc1xuICAgIGpvcHRpb25zID0gcHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUU9TW2pxb3NdXG4gICAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICAgIGpvcHRpb25zIHw9IGpubCA/IHByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX05MIDogMFxuICAgICAgam9wdGlvbnMgfD0ganJhcCA/IHByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1JBUCA6IDBcbiAgICAgIGpvcHRpb25zIHw9IGpyaCA/IHByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1JIW2pyaF0gOiAwXG4gICAgfVxuICAgIC8vIFdyaXRlIG9wdGlvbnNcbiAgICByZXN1bHQgPSBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW2pvcHRpb25zXSkpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHN1YmFjayAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgdmFyIHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIHZhciBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcbiAgdmFyIGdyYW50ZWQgPSBzZXR0aW5ncy5ncmFudGVkXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuICB2YXIgbGVuZ3RoID0gMFxuXG4gIC8vIENoZWNrIG1lc3NhZ2UgSURcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBsZW5ndGggKz0gMlxuXG4gIC8vIENoZWNrIGdyYW50ZWQgcW9zIHZlY3RvclxuICBpZiAodHlwZW9mIGdyYW50ZWQgPT09ICdvYmplY3QnICYmIGdyYW50ZWQubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFudGVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGdyYW50ZWRbaV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBxb3MgdmVjdG9yJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgbGVuZ3RoICs9IDFcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHFvcyB2ZWN0b3InKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgdmFyIHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllc0J5TWF4aW11bVBhY2tldFNpemUoc3RyZWFtLCBwcm9wZXJ0aWVzLCBvcHRzLCBsZW5ndGgpXG4gICAgaWYgKCFwcm9wZXJ0aWVzRGF0YSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGxlbmd0aCArPSBwcm9wZXJ0aWVzRGF0YS5sZW5ndGhcbiAgfVxuXG4gIC8vIGhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuU1VCQUNLX0hFQURFUilcblxuICAvLyBMZW5ndGhcbiAgd3JpdGVWYXJCeXRlSW50KHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIE1lc3NhZ2UgSURcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPT0gbnVsbCkge1xuICAgIHByb3BlcnRpZXNEYXRhLndyaXRlKClcbiAgfVxuXG4gIHJldHVybiBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oZ3JhbnRlZCkpXG59XG5cbmZ1bmN0aW9uIHVuc3Vic2NyaWJlIChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICB2YXIgdmVyc2lvbiA9IG9wdHMgPyBvcHRzLnByb3RvY29sVmVyc2lvbiA6IDRcbiAgdmFyIHNldHRpbmdzID0gcGFja2V0IHx8IHt9XG4gIHZhciBpZCA9IHNldHRpbmdzLm1lc3NhZ2VJZFxuICB2YXIgZHVwID0gc2V0dGluZ3MuZHVwID8gcHJvdG9jb2wuRFVQX01BU0sgOiAwXG4gIHZhciB1bnN1YnMgPSBzZXR0aW5ncy51bnN1YnNjcmlwdGlvbnNcbiAgdmFyIHByb3BlcnRpZXMgPSBzZXR0aW5ncy5wcm9wZXJ0aWVzXG5cbiAgdmFyIGxlbmd0aCA9IDBcblxuICAvLyBDaGVjayBtZXNzYWdlIElEXG4gIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIGxlbmd0aCArPSAyXG4gIH1cbiAgLy8gQ2hlY2sgdW5zdWJzXG4gIGlmICh0eXBlb2YgdW5zdWJzID09PSAnb2JqZWN0JyAmJiB1bnN1YnMubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bnN1YnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgdW5zdWJzW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgdW5zdWJzY3JpcHRpb25zJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHVuc3Vic1tpXSkgKyAyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCB1bnN1YnNjcmlwdGlvbnMnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIHZhciBwcm9wZXJ0aWVzRGF0YSA9IG51bGxcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXMoc3RyZWFtLCBwcm9wZXJ0aWVzKVxuICAgIGxlbmd0aCArPSBwcm9wZXJ0aWVzRGF0YS5sZW5ndGhcbiAgfVxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuVU5TVUJTQ1JJQkVfSEVBREVSWzFdW2R1cCA/IDEgOiAwXVswXSlcblxuICAvLyBMZW5ndGhcbiAgd3JpdGVWYXJCeXRlSW50KHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIE1lc3NhZ2UgSURcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPT0gbnVsbCkge1xuICAgIHByb3BlcnRpZXNEYXRhLndyaXRlKClcbiAgfVxuXG4gIC8vIFVuc3Vic1xuICB2YXIgcmVzdWx0ID0gdHJ1ZVxuICBmb3IgKHZhciBqID0gMDsgaiA8IHVuc3Vicy5sZW5ndGg7IGorKykge1xuICAgIHJlc3VsdCA9IHdyaXRlU3RyaW5nKHN0cmVhbSwgdW5zdWJzW2pdKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiB1bnN1YmFjayAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgdmFyIHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIHZhciBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcbiAgdmFyIGR1cCA9IHNldHRpbmdzLmR1cCA/IHByb3RvY29sLkRVUF9NQVNLIDogMFxuICB2YXIgZ3JhbnRlZCA9IHNldHRpbmdzLmdyYW50ZWRcbiAgdmFyIHByb3BlcnRpZXMgPSBzZXR0aW5ncy5wcm9wZXJ0aWVzXG4gIHZhciB0eXBlID0gc2V0dGluZ3MuY21kXG4gIHZhciBxb3MgPSAwXG5cbiAgdmFyIGxlbmd0aCA9IDJcblxuICAvLyBDaGVjayBtZXNzYWdlIElEXG4gIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gQ2hlY2sgZ3JhbnRlZFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIGlmICh0eXBlb2YgZ3JhbnRlZCA9PT0gJ29iamVjdCcgJiYgZ3JhbnRlZC5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhbnRlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIGdyYW50ZWRbaV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHFvcyB2ZWN0b3InKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gMVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcW9zIHZlY3RvcicpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICB2YXIgcHJvcGVydGllc0RhdGEgPSBudWxsXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzQnlNYXhpbXVtUGFja2V0U2l6ZShzdHJlYW0sIHByb3BlcnRpZXMsIG9wdHMsIGxlbmd0aClcbiAgICBpZiAoIXByb3BlcnRpZXNEYXRhKSB7IHJldHVybiBmYWxzZSB9XG4gICAgbGVuZ3RoICs9IHByb3BlcnRpZXNEYXRhLmxlbmd0aFxuICB9XG5cbiAgLy8gSGVhZGVyXG4gIHN0cmVhbS53cml0ZShwcm90b2NvbC5BQ0tTW3R5cGVdW3Fvc11bZHVwXVswXSlcblxuICAvLyBMZW5ndGhcbiAgd3JpdGVWYXJCeXRlSW50KHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIE1lc3NhZ2UgSURcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPT0gbnVsbCkge1xuICAgIHByb3BlcnRpZXNEYXRhLndyaXRlKClcbiAgfVxuXG4gIC8vIHBheWxvYWRcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oZ3JhbnRlZCkpXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZW1wdHlQYWNrZXQgKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIHJldHVybiBzdHJlYW0ud3JpdGUocHJvdG9jb2wuRU1QVFlbcGFja2V0LmNtZF0pXG59XG5cbmZ1bmN0aW9uIGRpc2Nvbm5lY3QgKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIHZhciB2ZXJzaW9uID0gb3B0cyA/IG9wdHMucHJvdG9jb2xWZXJzaW9uIDogNFxuICB2YXIgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgdmFyIHJlYXNvbkNvZGUgPSBzZXR0aW5ncy5yZWFzb25Db2RlXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuICB2YXIgbGVuZ3RoID0gdmVyc2lvbiA9PT0gNSA/IDEgOiAwXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICB2YXIgcHJvcGVydGllc0RhdGEgPSBudWxsXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzQnlNYXhpbXVtUGFja2V0U2l6ZShzdHJlYW0sIHByb3BlcnRpZXMsIG9wdHMsIGxlbmd0aClcbiAgICBpZiAoIXByb3BlcnRpZXNEYXRhKSB7IHJldHVybiBmYWxzZSB9XG4gICAgbGVuZ3RoICs9IHByb3BlcnRpZXNEYXRhLmxlbmd0aFxuICB9XG5cbiAgLy8gSGVhZGVyXG4gIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ2Rpc2Nvbm5lY3QnXSA8PCA0XSkpXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyByZWFzb24gY29kZSBpbiBoZWFkZXJcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3JlYXNvbkNvZGVdKSlcbiAgfVxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgaWYgKHByb3BlcnRpZXNEYXRhICE9PSBudWxsKSB7XG4gICAgcHJvcGVydGllc0RhdGEud3JpdGUoKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gYXV0aCAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgdmFyIHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIHZhciBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICB2YXIgcmVhc29uQ29kZSA9IHNldHRpbmdzLnJlYXNvbkNvZGVcbiAgdmFyIHByb3BlcnRpZXMgPSBzZXR0aW5ncy5wcm9wZXJ0aWVzXG4gIHZhciBsZW5ndGggPSB2ZXJzaW9uID09PSA1ID8gMSA6IDBcblxuICBpZiAodmVyc2lvbiAhPT0gNSkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIG1xdHQgdmVyc2lvbiBmb3IgYXV0aCBwYWNrZXQnKSlcblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIHZhciBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXNCeU1heGltdW1QYWNrZXRTaXplKHN0cmVhbSwgcHJvcGVydGllcywgb3B0cywgbGVuZ3RoKVxuICBpZiAoIXByb3BlcnRpZXNEYXRhKSB7IHJldHVybiBmYWxzZSB9XG4gIGxlbmd0aCArPSBwcm9wZXJ0aWVzRGF0YS5sZW5ndGhcblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1snYXV0aCddIDw8IDRdKSlcblxuICAvLyBMZW5ndGhcbiAgd3JpdGVWYXJCeXRlSW50KHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIHJlYXNvbiBjb2RlIGluIGhlYWRlclxuICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3JlYXNvbkNvZGVdKSlcblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPT0gbnVsbCkge1xuICAgIHByb3BlcnRpZXNEYXRhLndyaXRlKClcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIHdyaXRlVmFyQnl0ZUludCAtIHdyaXRlIGFuIE1RVFQgc3R5bGUgdmFyaWFibGUgYnl0ZSBpbnRlZ2VyIHRvIHRoZSBidWZmZXJcbiAqXG4gKiBAcGFyYW0gPEJ1ZmZlcj4gYnVmZmVyIC0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSA8TnVtYmVyPiBwb3MgLSBvZmZzZXRcbiAqIEBwYXJhbSA8TnVtYmVyPiBsZW5ndGggLSBsZW5ndGggKD4wKVxuICogQHJldHVybnMgPE51bWJlcj4gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgdmFyQnl0ZUludENhY2hlID0ge31cbmZ1bmN0aW9uIHdyaXRlVmFyQnl0ZUludCAoc3RyZWFtLCBudW0pIHtcbiAgdmFyIGJ1ZmZlciA9IHZhckJ5dGVJbnRDYWNoZVtudW1dXG5cbiAgaWYgKCFidWZmZXIpIHtcbiAgICBidWZmZXIgPSBnZW5CdWZWYXJpYWJsZUJ5dGVJbnQobnVtKS5kYXRhXG4gICAgaWYgKG51bSA8IDE2Mzg0KSB2YXJCeXRlSW50Q2FjaGVbbnVtXSA9IGJ1ZmZlclxuICB9XG5cbiAgc3RyZWFtLndyaXRlKGJ1ZmZlcilcbn1cblxuLyoqXG4gKiB3cml0ZVN0cmluZyAtIHdyaXRlIGEgdXRmOCBzdHJpbmcgdG8gdGhlIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSA8QnVmZmVyPiBidWZmZXIgLSBkZXN0aW5hdGlvblxuICogQHBhcmFtIDxOdW1iZXI+IHBvcyAtIG9mZnNldFxuICogQHBhcmFtIDxTdHJpbmc+IHN0cmluZyAtIHN0cmluZyB0byB3cml0ZVxuICogQHJldHVybiA8TnVtYmVyPiBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nIChzdHJlYW0sIHN0cmluZykge1xuICB2YXIgc3RybGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyaW5nKVxuICB3cml0ZU51bWJlcihzdHJlYW0sIHN0cmxlbilcblxuICBzdHJlYW0ud3JpdGUoc3RyaW5nLCAndXRmOCcpXG59XG5cbi8qKlxuICogd3JpdGVTdHJpbmdQYWlyIC0gd3JpdGUgYSB1dGY4IHN0cmluZyBwYWlycyB0byB0aGUgYnVmZmVyXG4gKlxuICogQHBhcmFtIDxCdWZmZXI+IGJ1ZmZlciAtIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gPFN0cmluZz4gbmFtZSAtIHN0cmluZyBuYW1lIHRvIHdyaXRlXG4gKiBAcGFyYW0gPFN0cmluZz4gdmFsdWUgLSBzdHJpbmcgdmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm4gPE51bWJlcj4gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gd3JpdGVTdHJpbmdQYWlyIChzdHJlYW0sIG5hbWUsIHZhbHVlKSB7XG4gIHdyaXRlU3RyaW5nKHN0cmVhbSwgbmFtZSlcbiAgd3JpdGVTdHJpbmcoc3RyZWFtLCB2YWx1ZSlcbn1cblxuLyoqXG4gKiB3cml0ZU51bWJlciAtIHdyaXRlIGEgdHdvIGJ5dGUgbnVtYmVyIHRvIHRoZSBidWZmZXJcbiAqXG4gKiBAcGFyYW0gPEJ1ZmZlcj4gYnVmZmVyIC0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSA8TnVtYmVyPiBwb3MgLSBvZmZzZXRcbiAqIEBwYXJhbSA8U3RyaW5nPiBudW1iZXIgLSBudW1iZXIgdG8gd3JpdGVcbiAqIEByZXR1cm4gPE51bWJlcj4gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gd3JpdGVOdW1iZXJDYWNoZWQgKHN0cmVhbSwgbnVtYmVyKSB7XG4gIHJldHVybiBzdHJlYW0ud3JpdGUobnVtQ2FjaGVbbnVtYmVyXSlcbn1cbmZ1bmN0aW9uIHdyaXRlTnVtYmVyR2VuZXJhdGVkIChzdHJlYW0sIG51bWJlcikge1xuICByZXR1cm4gc3RyZWFtLndyaXRlKGdlbmVyYXRlTnVtYmVyKG51bWJlcikpXG59XG5mdW5jdGlvbiB3cml0ZTRCeXRlTnVtYmVyIChzdHJlYW0sIG51bWJlcikge1xuICByZXR1cm4gc3RyZWFtLndyaXRlKGdlbmVyYXRlNEJ5dGVCdWZmZXIobnVtYmVyKSlcbn1cbi8qKlxuICogd3JpdGVTdHJpbmdPckJ1ZmZlciAtIHdyaXRlIGEgU3RyaW5nIG9yIEJ1ZmZlciB3aXRoIHRoZSBpdHMgbGVuZ3RoIHByZWZpeFxuICpcbiAqIEBwYXJhbSA8QnVmZmVyPiBidWZmZXIgLSBkZXN0aW5hdGlvblxuICogQHBhcmFtIDxOdW1iZXI+IHBvcyAtIG9mZnNldFxuICogQHBhcmFtIDxTdHJpbmc+IHRvV3JpdGUgLSBTdHJpbmcgb3IgQnVmZmVyXG4gKiBAcmV0dXJuIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nT3JCdWZmZXIgKHN0cmVhbSwgdG9Xcml0ZSkge1xuICBpZiAodHlwZW9mIHRvV3JpdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgd3JpdGVTdHJpbmcoc3RyZWFtLCB0b1dyaXRlKVxuICB9IGVsc2UgaWYgKHRvV3JpdGUpIHtcbiAgICB3cml0ZU51bWJlcihzdHJlYW0sIHRvV3JpdGUubGVuZ3RoKVxuICAgIHN0cmVhbS53cml0ZSh0b1dyaXRlKVxuICB9IGVsc2Ugd3JpdGVOdW1iZXIoc3RyZWFtLCAwKVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzIChzdHJlYW0sIHByb3BlcnRpZXMpIHtcbiAgLyogY29ubmVjdCBwcm9wZXJ0aWVzICovXG4gIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gJ29iamVjdCcgfHwgcHJvcGVydGllcy5sZW5ndGggIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZW5ndGg6IDEsXG4gICAgICB3cml0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB3cml0ZVByb3BlcnRpZXMoc3RyZWFtLCB7fSwgMClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHByb3BlcnRpZXNMZW5ndGggPSAwXG4gIGZ1bmN0aW9uIGdldExlbmd0aFByb3BlcnR5IChuYW1lKSB7XG4gICAgdmFyIHR5cGUgPSBwcm90b2NvbC5wcm9wZXJ0aWVzVHlwZXNbbmFtZV1cbiAgICB2YXIgdmFsdWUgPSBwcm9wZXJ0aWVzW25hbWVdXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2J5dGUnOiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCAnICsgbmFtZSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoICs9IDEgKyAxXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdpbnQ4Jzoge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCAnICsgbmFtZSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoICs9IDEgKyAxXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdiaW5hcnknOiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCAnICsgbmFtZSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoICs9IDEgKyBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSkgKyAyXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdpbnQxNic6IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIG5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSAxICsgMlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnaW50MzInOiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkICcgKyBuYW1lKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gMSArIDRcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3Zhcic6IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIG5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSAxICsgZ2VuQnVmVmFyaWFibGVCeXRlSW50KHZhbHVlKS5sZW5ndGhcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIG5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSAxICsgMiArIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdwYWlyJzoge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCAnICsgbmFtZSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoICs9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgbmFtZSkge1xuICAgICAgICAgIHJlc3VsdCArPSAxICsgMiArIEJ1ZmZlci5ieXRlTGVuZ3RoKG5hbWUudG9TdHJpbmcoKSkgKyAyICsgQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWVbbmFtZV0udG9TdHJpbmcoKSlcbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH0sIDApXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBwcm9wZXJ0eSAnICsgbmFtZSkpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cbiAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcHJvcExlbmd0aCA9IGdldExlbmd0aFByb3BlcnR5KHByb3BOYW1lKVxuICAgICAgaWYgKCFwcm9wTGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgICAgIHByb3BlcnRpZXNMZW5ndGggKz0gcHJvcExlbmd0aFxuICAgIH1cbiAgfVxuICB2YXIgcHJvcGVydGllc0xlbmd0aExlbmd0aCA9IGdlbkJ1ZlZhcmlhYmxlQnl0ZUludChwcm9wZXJ0aWVzTGVuZ3RoKS5sZW5ndGhcblxuICByZXR1cm4ge1xuICAgIGxlbmd0aDogcHJvcGVydGllc0xlbmd0aExlbmd0aCArIHByb3BlcnRpZXNMZW5ndGgsXG4gICAgd3JpdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdyaXRlUHJvcGVydGllcyhzdHJlYW0sIHByb3BlcnRpZXMsIHByb3BlcnRpZXNMZW5ndGgpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnRpZXNCeU1heGltdW1QYWNrZXRTaXplIChzdHJlYW0sIHByb3BlcnRpZXMsIG9wdHMsIGxlbmd0aCkge1xuICB2YXIgbWF5RW1wdHlQcm9wcyA9IFsncmVhc29uU3RyaW5nJywgJ3VzZXJQcm9wZXJ0aWVzJ11cbiAgdmFyIG1heGltdW1QYWNrZXRTaXplID0gb3B0cyAmJiBvcHRzLnByb3BlcnRpZXMgJiYgb3B0cy5wcm9wZXJ0aWVzLm1heGltdW1QYWNrZXRTaXplID8gb3B0cy5wcm9wZXJ0aWVzLm1heGltdW1QYWNrZXRTaXplIDogMFxuXG4gIHZhciBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXMoc3RyZWFtLCBwcm9wZXJ0aWVzKVxuICBpZiAobWF4aW11bVBhY2tldFNpemUpIHtcbiAgICB3aGlsZSAobGVuZ3RoICsgcHJvcGVydGllc0RhdGEubGVuZ3RoID4gbWF4aW11bVBhY2tldFNpemUpIHtcbiAgICAgIHZhciBjdXJyZW50TWF5RW1wdHlQcm9wID0gbWF5RW1wdHlQcm9wcy5zaGlmdCgpXG4gICAgICBpZiAoY3VycmVudE1heUVtcHR5UHJvcCAmJiBwcm9wZXJ0aWVzW2N1cnJlbnRNYXlFbXB0eVByb3BdKSB7XG4gICAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzW2N1cnJlbnRNYXlFbXB0eVByb3BdXG4gICAgICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllcyhzdHJlYW0sIHByb3BlcnRpZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BlcnRpZXNEYXRhXG59XG5cbmZ1bmN0aW9uIHdyaXRlUHJvcGVydGllcyAoc3RyZWFtLCBwcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzTGVuZ3RoKSB7XG4gIC8qIHdyaXRlIHByb3BlcnRpZXMgdG8gc3RyZWFtICovXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIHByb3BlcnRpZXNMZW5ndGgpXG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BlcnRpZXMpIHtcbiAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgcHJvcGVydGllc1twcm9wTmFtZV0gIT09IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BlcnRpZXNbcHJvcE5hbWVdXG4gICAgICB2YXIgdHlwZSA9IHByb3RvY29sLnByb3BlcnRpZXNUeXBlc1twcm9wTmFtZV1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdieXRlJzoge1xuICAgICAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wucHJvcGVydGllc1twcm9wTmFtZV1dKSlcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oWyt2YWx1ZV0pKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaW50OCc6IHtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICAgICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFt2YWx1ZV0pKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYmluYXJ5Jzoge1xuICAgICAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wucHJvcGVydGllc1twcm9wTmFtZV1dKSlcbiAgICAgICAgICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgdmFsdWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdpbnQxNic6IHtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICAgICAgd3JpdGVOdW1iZXIoc3RyZWFtLCB2YWx1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2ludDMyJzoge1xuICAgICAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wucHJvcGVydGllc1twcm9wTmFtZV1dKSlcbiAgICAgICAgICB3cml0ZTRCeXRlTnVtYmVyKHN0cmVhbSwgdmFsdWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd2YXInOiB7XG4gICAgICAgICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5wcm9wZXJ0aWVzW3Byb3BOYW1lXV0pKVxuICAgICAgICAgIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wucHJvcGVydGllc1twcm9wTmFtZV1dKSlcbiAgICAgICAgICB3cml0ZVN0cmluZyhzdHJlYW0sIHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncGFpcic6IHtcbiAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5wcm9wZXJ0aWVzW3Byb3BOYW1lXV0pKVxuICAgICAgICAgICAgd3JpdGVTdHJpbmdQYWlyKHN0cmVhbSwgbmFtZS50b1N0cmluZygpLCB2YWx1ZVtuYW1lXS50b1N0cmluZygpKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHByb3BlcnR5ICcgKyBwcm9wTmFtZSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYnVmT3JTdHJpbmcpIHtcbiAgaWYgKCFidWZPclN0cmluZykgcmV0dXJuIDBcbiAgZWxzZSBpZiAoYnVmT3JTdHJpbmcgaW5zdGFuY2VvZiBCdWZmZXIpIHJldHVybiBidWZPclN0cmluZy5sZW5ndGhcbiAgZWxzZSByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoYnVmT3JTdHJpbmcpXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT3JCdWZmZXIgKGZpZWxkKSB7XG4gIHJldHVybiB0eXBlb2YgZmllbGQgPT09ICdzdHJpbmcnIHx8IGZpZWxkIGluc3RhbmNlb2YgQnVmZmVyXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVcblxufSx7XCIuL2NvbnN0YW50c1wiOjgyLFwiLi9udW1iZXJzXCI6ODYsXCJwcm9jZXNzLW5leHRpY2stYXJnc1wiOjkxLFwic2FmZS1idWZmZXJcIjoxMTB9XSw5MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgd3JhcHB5ID0gcmVxdWlyZSgnd3JhcHB5Jylcbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5KG9uY2UpXG5tb2R1bGUuZXhwb3J0cy5zdHJpY3QgPSB3cmFwcHkob25jZVN0cmljdClcblxub25jZS5wcm90byA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2UodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlU3RyaWN0Jywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZVN0cmljdCh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZi5jYWxsZWQpIHJldHVybiBmLnZhbHVlXG4gICAgZi5jYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGYudmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgZi5jYWxsZWQgPSBmYWxzZVxuICByZXR1cm4gZlxufVxuXG5mdW5jdGlvbiBvbmNlU3RyaWN0IChmbikge1xuICB2YXIgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZi5jYWxsZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZi5vbmNlRXJyb3IpXG4gICAgZi5jYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGYudmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgdmFyIG5hbWUgPSBmbi5uYW1lIHx8ICdGdW5jdGlvbiB3cmFwcGVkIHdpdGggYG9uY2VgJ1xuICBmLm9uY2VFcnJvciA9IG5hbWUgKyBcIiBzaG91bGRuJ3QgYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlXCJcbiAgZi5jYWxsZWQgPSBmYWxzZVxuICByZXR1cm4gZlxufVxuXG59LHtcIndyYXBweVwiOjEyMH1dLDkxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG59LHtcIl9wcm9jZXNzXCI6OTJ9XSw5MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG59LHt9XSw5MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDk0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbn0se31dLDk1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG59LHt9XSw5NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcblxufSx7XCIuL2RlY29kZVwiOjk0LFwiLi9lbmNvZGVcIjo5NX1dLDk3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcblxufSx7XCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiOjk4fV0sOTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07XG59LHtcIi4vX3N0cmVhbV9yZWFkYWJsZVwiOjEwMCxcIi4vX3N0cmVhbV93cml0YWJsZVwiOjEwMixcImNvcmUtdXRpbC1pc1wiOjE0LFwiaW5oZXJpdHNcIjo4MCxcInByb2Nlc3MtbmV4dGljay1hcmdzXCI6OTF9XSw5OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcbn0se1wiLi9fc3RyZWFtX3RyYW5zZm9ybVwiOjEwMSxcImNvcmUtdXRpbC1pc1wiOjE0LFwiaW5oZXJpdHNcIjo4MH1dLDEwMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL19zdHJlYW1fZHVwbGV4XCI6OTgsXCIuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdFwiOjEwMyxcIi4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95XCI6MTA0LFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVwiOjEwNSxcIl9wcm9jZXNzXCI6OTIsXCJjb3JlLXV0aWwtaXNcIjoxNCxcImV2ZW50c1wiOjEzLFwiaW5oZXJpdHNcIjo4MCxcImlzYXJyYXlcIjoxMDYsXCJwcm9jZXNzLW5leHRpY2stYXJnc1wiOjkxLFwic2FmZS1idWZmZXJcIjoxMTAsXCJzdHJpbmdfZGVjb2Rlci9cIjoxMDcsXCJ1dGlsXCI6MTF9XSwxMDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbn0se1wiLi9fc3RyZWFtX2R1cGxleFwiOjk4LFwiY29yZS11dGlsLWlzXCI6MTQsXCJpbmhlcml0c1wiOjgwfV0sMTAyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsc2V0SW1tZWRpYXRlKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwidGltZXJzXCIpLnNldEltbWVkaWF0ZSlcbn0se1wiLi9fc3RyZWFtX2R1cGxleFwiOjk4LFwiLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3lcIjoxMDQsXCIuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtXCI6MTA1LFwiX3Byb2Nlc3NcIjo5MixcImNvcmUtdXRpbC1pc1wiOjE0LFwiaW5oZXJpdHNcIjo4MCxcInByb2Nlc3MtbmV4dGljay1hcmdzXCI6OTEsXCJzYWZlLWJ1ZmZlclwiOjExMCxcInRpbWVyc1wiOjExMixcInV0aWwtZGVwcmVjYXRlXCI6MTE1fV0sMTAzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufVxufSx7XCJzYWZlLWJ1ZmZlclwiOjExMCxcInV0aWxcIjoxMX1dLDEwNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59O1xufSx7XCJwcm9jZXNzLW5leHRpY2stYXJnc1wiOjkxfV0sMTA1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG59LHtcImV2ZW50c1wiOjEzfV0sMTA2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG59LHt9XSwxMDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59XG59LHtcInNhZmUtYnVmZmVyXCI6MTEwfV0sMTA4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5cbn0se1wiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIjo5OCxcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIjo5OSxcIi4vbGliL19zdHJlYW1fcmVhZGFibGUuanNcIjoxMDAsXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiOjEwMSxcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIjoxMDJ9XSwxMDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIFJlSW50ZXJ2YWwgKGNhbGxiYWNrLCBpbnRlcnZhbCwgYXJncykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgdGhpcy5fYXJncyA9IGFyZ3M7XG5cbiAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjYWxsYmFjaywgaW50ZXJ2YWwsIHRoaXMuX2FyZ3MpO1xuXG4gIHRoaXMucmVzY2hlZHVsZSA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgIC8vIGlmIG5vIGludGVydmFsIGVudGVyZWQsIHVzZSB0aGUgaW50ZXJ2YWwgcGFzc2VkIGluIG9uIGNyZWF0aW9uXG4gICAgaWYgKCFpbnRlcnZhbClcbiAgICAgIGludGVydmFsID0gc2VsZi5faW50ZXJ2YWw7XG5cbiAgICBpZiAoc2VsZi5faW50ZXJ2YWwpXG4gICAgICBjbGVhckludGVydmFsKHNlbGYuX2ludGVydmFsKTtcbiAgICBzZWxmLl9pbnRlcnZhbCA9IHNldEludGVydmFsKHNlbGYuX2NhbGxiYWNrLCBpbnRlcnZhbCwgc2VsZi5fYXJncyk7XG4gIH07XG5cbiAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5faW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoc2VsZi5faW50ZXJ2YWwpO1xuICAgICAgc2VsZi5faW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuICBcbiAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9pbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbCk7XG4gICAgfVxuICAgIHNlbGYuX2NhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgIHNlbGYuX2ludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIHNlbGYuX2FyZ3MgPSB1bmRlZmluZWQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlSW50ZXJ2YWwgKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIG5lZWRlZCcpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnRlcnZhbCBuZWVkZWQnKTtcblxuICB2YXIgYXJncztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZUludGVydmFsKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZUludGVydmFsO1xuXG59LHt9XSwxMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cblxufSx7XCJidWZmZXJcIjoxMn1dLDExMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IHNoaWZ0XG5cbmZ1bmN0aW9uIHNoaWZ0IChzdHJlYW0pIHtcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGlmICghcnMpIHJldHVybiBudWxsXG4gIHJldHVybiBycy5vYmplY3RNb2RlID8gc3RyZWFtLnJlYWQoKSA6IHN0cmVhbS5yZWFkKGdldFN0YXRlTGVuZ3RoKHJzKSlcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVMZW5ndGggKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoKSB7XG4gICAgLy8gU2luY2Ugbm9kZSA2LjMuMCBzdGF0ZS5idWZmZXIgaXMgYSBCdWZmZXJMaXN0IG5vdCBhbiBhcnJheVxuICAgIGlmIChzdGF0ZS5idWZmZXIuaGVhZCkge1xuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGhcbn1cblxufSx7fV0sMTEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoc2V0SW1tZWRpYXRlLGNsZWFySW1tZWRpYXRlKXtcbnZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJ0aW1lcnNcIikuc2V0SW1tZWRpYXRlLHJlcXVpcmUoXCJ0aW1lcnNcIikuY2xlYXJJbW1lZGlhdGUpXG59LHtcInByb2Nlc3MvYnJvd3Nlci5qc1wiOjkyLFwidGltZXJzXCI6MTEyfV0sMTEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG59LHtcIi4vdXRpbFwiOjExNCxcInB1bnljb2RlXCI6OTMsXCJxdWVyeXN0cmluZ1wiOjk2fV0sMTE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcblxufSx7fV0sMTE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwxMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxufSx7fV0sMTE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL3N1cHBvcnQvaXNCdWZmZXJcIjoxMTYsXCJfcHJvY2Vzc1wiOjkyLFwiaW5oZXJpdHNcIjo4MH1dLDExODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgZHVwbGV4aWZ5ID0gcmVxdWlyZSgnZHVwbGV4aWZ5JylcbnZhciBXUyA9IHJlcXVpcmUoJ3dzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFN0cmVhbVxuXG5mdW5jdGlvbiBidWlsZFByb3h5IChvcHRpb25zLCBzb2NrZXRXcml0ZSwgc29ja2V0RW5kKSB7XG4gIHZhciBwcm94eSA9IG5ldyBUcmFuc2Zvcm0oe1xuICAgIG9iamVjdE1vZGU6IG9wdGlvbnMub2JqZWN0TW9kZVxuICB9KVxuXG4gIHByb3h5Ll93cml0ZSA9IHNvY2tldFdyaXRlXG4gIHByb3h5Ll9mbHVzaCA9IHNvY2tldEVuZFxuXG4gIHJldHVybiBwcm94eVxufVxuXG5mdW5jdGlvbiBXZWJTb2NrZXRTdHJlYW0odGFyZ2V0LCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgdmFyIHN0cmVhbSwgc29ja2V0XG5cbiAgdmFyIGlzQnJvd3NlciA9IHByb2Nlc3MudGl0bGUgPT09ICdicm93c2VyJ1xuICB2YXIgaXNOYXRpdmUgPSAhIWdsb2JhbC5XZWJTb2NrZXRcbiAgdmFyIHNvY2tldFdyaXRlID0gaXNCcm93c2VyID8gc29ja2V0V3JpdGVCcm93c2VyIDogc29ja2V0V3JpdGVOb2RlXG5cbiAgaWYgKHByb3RvY29scyAmJiAhQXJyYXkuaXNBcnJheShwcm90b2NvbHMpICYmICdvYmplY3QnID09PSB0eXBlb2YgcHJvdG9jb2xzKSB7XG4gICAgLy8gYWNjZXB0IHRoZSBcIm9wdGlvbnNcIiBPYmplY3QgYXMgdGhlIDJuZCBhcmd1bWVudFxuICAgIG9wdGlvbnMgPSBwcm90b2NvbHNcbiAgICBwcm90b2NvbHMgPSBudWxsXG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJvdG9jb2wgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy5wcm90b2NvbCkpIHtcbiAgICAgIHByb3RvY29scyA9IG9wdGlvbnMucHJvdG9jb2w7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cblxuICBpZiAob3B0aW9ucy5vYmplY3RNb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLm9iamVjdE1vZGUgPSAhKG9wdGlvbnMuYmluYXJ5ID09PSB0cnVlIHx8IG9wdGlvbnMuYmluYXJ5ID09PSB1bmRlZmluZWQpXG4gIH1cblxuICB2YXIgcHJveHkgPSBidWlsZFByb3h5KG9wdGlvbnMsIHNvY2tldFdyaXRlLCBzb2NrZXRFbmQpXG5cbiAgaWYgKCFvcHRpb25zLm9iamVjdE1vZGUpIHtcbiAgICBwcm94eS5fd3JpdGV2ID0gd3JpdGV2XG4gIH1cblxuICAvLyBicm93c2VyIG9ubHk6IHNldHMgdGhlIG1heGltdW0gc29ja2V0IGJ1ZmZlciBzaXplIGJlZm9yZSB0aHJvdHRsaW5nXG4gIHZhciBidWZmZXJTaXplID0gb3B0aW9ucy5icm93c2VyQnVmZmVyU2l6ZSB8fCAxMDI0ICogNTEyXG5cbiAgLy8gYnJvd3NlciBvbmx5OiBob3cgbG9uZyB0byB3YWl0IHdoZW4gdGhyb3R0bGluZ1xuICB2YXIgYnVmZmVyVGltZW91dCA9IG9wdGlvbnMuYnJvd3NlckJ1ZmZlclRpbWVvdXQgfHwgMTAwMFxuXG4gIC8vIHVzZSBleGlzdGluZyBXZWJTb2NrZXQgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBpblxuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICBzb2NrZXQgPSB0YXJnZXRcbiAgLy8gb3RoZXJ3aXNlIG1ha2UgYSBuZXcgb25lXG4gIH0gZWxzZSB7XG4gICAgLy8gc3BlY2lhbCBjb25zdHJ1Y3RvciB0cmVhdG1lbnQgZm9yIG5hdGl2ZSB3ZWJzb2NrZXRzIGluIGJyb3dzZXJzLCBzZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vd2Vic29ja2V0LXN0cmVhbS9pc3N1ZXMvODJcbiAgICBpZiAoaXNOYXRpdmUgJiYgaXNCcm93c2VyKSB7XG4gICAgICBzb2NrZXQgPSBuZXcgV1ModGFyZ2V0LCBwcm90b2NvbHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNvY2tldCA9IG5ldyBXUyh0YXJnZXQsIHByb3RvY29scywgb3B0aW9ucylcbiAgICB9XG5cbiAgICBzb2NrZXQuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgfVxuXG4gIC8vIHdhcyBhbHJlYWR5IG9wZW4gd2hlbiBwYXNzZWQgaW5cbiAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBzb2NrZXQuT1BFTikge1xuICAgIHN0cmVhbSA9IHByb3h5XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gZHVwbGV4aWZ5Lm9iaigpXG4gICAgc29ja2V0Lm9ub3BlbiA9IG9ub3BlblxuICB9XG5cbiAgc3RyZWFtLnNvY2tldCA9IHNvY2tldFxuXG4gIHNvY2tldC5vbmNsb3NlID0gb25jbG9zZVxuICBzb2NrZXQub25lcnJvciA9IG9uZXJyb3JcbiAgc29ja2V0Lm9ubWVzc2FnZSA9IG9ubWVzc2FnZVxuXG4gIHByb3h5Lm9uKCdjbG9zZScsIGRlc3Ryb3kpXG5cbiAgdmFyIGNvZXJjZVRvQnVmZmVyID0gIW9wdGlvbnMub2JqZWN0TW9kZVxuXG4gIGZ1bmN0aW9uIHNvY2tldFdyaXRlTm9kZShjaHVuaywgZW5jLCBuZXh0KSB7XG4gICAgLy8gYXZvaWQgZXJyb3JzLCB0aGlzIG5ldmVyIGhhcHBlbnMgdW5sZXNzXG4gICAgLy8gZGVzdHJveSgpIGlzIGNhbGxlZFxuICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gc29ja2V0Lk9QRU4pIHtcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNvZXJjZVRvQnVmZmVyICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssICd1dGY4JylcbiAgICB9XG4gICAgc29ja2V0LnNlbmQoY2h1bmssIG5leHQpXG4gIH1cblxuICBmdW5jdGlvbiBzb2NrZXRXcml0ZUJyb3dzZXIoY2h1bmssIGVuYywgbmV4dCkge1xuICAgIGlmIChzb2NrZXQuYnVmZmVyZWRBbW91bnQgPiBidWZmZXJTaXplKSB7XG4gICAgICBzZXRUaW1lb3V0KHNvY2tldFdyaXRlQnJvd3NlciwgYnVmZmVyVGltZW91dCwgY2h1bmssIGVuYywgbmV4dClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjb2VyY2VUb0J1ZmZlciAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCAndXRmOCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNvY2tldC5zZW5kKGNodW5rKVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICByZXR1cm4gbmV4dChlcnIpXG4gICAgfVxuXG4gICAgbmV4dCgpXG4gIH1cblxuICBmdW5jdGlvbiBzb2NrZXRFbmQoZG9uZSkge1xuICAgIHNvY2tldC5jbG9zZSgpXG4gICAgZG9uZSgpXG4gIH1cblxuICBmdW5jdGlvbiBvbm9wZW4oKSB7XG4gICAgc3RyZWFtLnNldFJlYWRhYmxlKHByb3h5KVxuICAgIHN0cmVhbS5zZXRXcml0YWJsZShwcm94eSlcbiAgICBzdHJlYW0uZW1pdCgnY29ubmVjdCcpXG4gIH1cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIHN0cmVhbS5lbmQoKVxuICAgIHN0cmVhbS5kZXN0cm95KClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9XG5cbiAgZnVuY3Rpb24gb25tZXNzYWdlKGV2ZW50KSB7XG4gICAgdmFyIGRhdGEgPSBldmVudC5kYXRhXG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpXG4gICAgZWxzZSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKVxuICAgIHByb3h5LnB1c2goZGF0YSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgc29ja2V0LmNsb3NlKClcbiAgfVxuXG4gIC8vIHRoaXMgaXMgdG8gYmUgZW5hYmxlZCBvbmx5IGlmIG9iamVjdE1vZGUgaXMgZmFsc2VcbiAgZnVuY3Rpb24gd3JpdGV2IChjaHVua3MsIGNiKSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSBuZXcgQXJyYXkoY2h1bmtzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBjaHVua3NbaV0uY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1ZmZlcnNbaV0gPSBCdWZmZXIuZnJvbShjaHVua3NbaV0sICd1dGY4JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlcnNbaV0gPSBjaHVua3NbaV0uY2h1bmtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl93cml0ZShCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpLCAnYmluYXJ5JywgY2IpXG4gIH1cblxuICByZXR1cm4gc3RyZWFtXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIl9wcm9jZXNzXCI6OTIsXCJkdXBsZXhpZnlcIjoxNyxcInJlYWRhYmxlLXN0cmVhbVwiOjEwOCxcInNhZmUtYnVmZmVyXCI6MTEwLFwid3NcIjoxMTl9XSwxMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG52YXIgd3MgPSBudWxsXG5cbmlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IFdlYlNvY2tldFxufSBlbHNlIGlmICh0eXBlb2YgTW96V2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IE1veldlYlNvY2tldFxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IHdpbmRvdy5XZWJTb2NrZXQgfHwgd2luZG93Lk1veldlYlNvY2tldFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdzXG5cbn0se31dLDEyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBSZXR1cm5zIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB3cmFwcGVkIGNhbGxiYWNrXG4vLyBUaGUgd3JhcHBlciBmdW5jdGlvbiBzaG91bGQgZG8gc29tZSBzdHVmZiwgYW5kIHJldHVybiBhXG4vLyBwcmVzdW1hYmx5IGRpZmZlcmVudCBjYWxsYmFjayBmdW5jdGlvbi5cbi8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IG93biBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCwgc28gdGhhdFxuLy8gZGVjb3JhdGlvbnMgYW5kIHN1Y2ggYXJlIG5vdCBsb3N0IGFsb25nIHRoZSB3YXkuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweVxuZnVuY3Rpb24gd3JhcHB5IChmbiwgY2IpIHtcbiAgaWYgKGZuICYmIGNiKSByZXR1cm4gd3JhcHB5KGZuKShjYilcblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25lZWQgd3JhcHBlciBmdW5jdGlvbicpXG5cbiAgT2JqZWN0LmtleXMoZm4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB3cmFwcGVyW2tdID0gZm5ba11cbiAgfSlcblxuICByZXR1cm4gd3JhcHBlclxuXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgdmFyIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aC0xXVxuICAgIGlmICh0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nICYmIHJldCAhPT0gY2IpIHtcbiAgICAgIE9iamVjdC5rZXlzKGNiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldFtrXSA9IGNiW2tdXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxufSx7fV0sMTIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG5cbn0se31dfSx7fSxbOV0pKDkpXG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 20 */
/*!*********************************************************!*\
  !*** ./node_modules/@dcloudio/uni-mp-weixin/dist/mp.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });exports.Behavior = Behavior;exports.Component = Component;exports.Page = Page;exports.nextTick = exports.default = void 0;var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 8));var _PROP_DEFAULT_VALUES;function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _iterableToArrayLimit(arr, i) {if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}

function parseData(data, vueComponentOptions) {
  if (!data) {
    return;
  }
  vueComponentOptions.mpOptions.data = data;
}

function parseComponents(vueComponentOptions) {
  vueComponentOptions.components = global.__wxVueOptions.components;
}

var _toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function isFn(fn) {
  return typeof fn === 'function';
}

function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

function noop() {}

/**
                    * Create a cached version of a pure function.
                    */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
   * Camelize a hyphen-delimited string.
   */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {return c ? c.toUpperCase() : '';});
});

var SOURCE_KEY = '__data__';

var COMPONENT_LIFECYCLE = {
  created: 'onServiceCreated',
  attached: 'onServiceAttached',
  ready: 'mounted',
  moved: 'moved',
  detached: 'destroyed' };


var COMPONENT_LIFECYCLE_KEYS = Object.keys(COMPONENT_LIFECYCLE);

var PAGE_LIFETIMES = {
  show: 'onPageShow',
  hide: 'onPageHide',
  resize: 'onPageResize' };


var PAGE_LIFETIMES_KEYS = Object.keys(PAGE_LIFETIMES);

var PAGE_LIFECYCLE = [
'onLoad',
'onShow',
'onReady',
'onHide',
'onUnload',
'onPullDownRefresh',
'onReachBottom',
'onShareAppMessage',
'onPageScroll',
'onResize',
'onTabItemTap'];


function parsePageMethods(mpComponentOptions, vueComponentOptions) {
  var methods = Object.create(null);
  Object.keys(mpComponentOptions).forEach(function (key) {
    var value = mpComponentOptions[key];
    if (isFn(value) && PAGE_LIFECYCLE.indexOf(key) === -1) {
      methods[key] = value;
    }
  });
  vueComponentOptions.methods = methods;
}

function parsePageLifecycle(mpComponentOptions, vueComponentOptions) {
  Object.keys(mpComponentOptions).forEach(function (key) {
    if (PAGE_LIFECYCLE.indexOf(key) !== -1) {
      vueComponentOptions[key] = mpComponentOptions[key];
    }
  });
}

function parsePage(mpComponentOptions) {
  var vueComponentOptions = {
    mixins: [],
    mpOptions: {} };


  parseComponents(vueComponentOptions);

  parseData(mpComponentOptions.data, vueComponentOptions);

  parsePageMethods(mpComponentOptions, vueComponentOptions);
  parsePageLifecycle(mpComponentOptions, vueComponentOptions);

  return vueComponentOptions;
}

function parseProperties(properties, vueComponentOptions) {
  if (!properties) {
    return;
  }
  vueComponentOptions.mpOptions.properties = properties;
}

function parseOptions(options, vueComponentOptions) {
  if (!options) {
    return;
  }
  vueComponentOptions.mpOptions.options = options;
}

function parseMethods(methods, vueComponentOptions) {
  if (!methods) {
    return;
  }
  if (methods.$emit) {
    console.warn('Method "$emit" conflicts with an existing Vue instance method');
    delete methods.$emit;
  }
  vueComponentOptions.methods = methods;
}

function parseLifecycle(mpComponentOptions, vueComponentOptions) {
  COMPONENT_LIFECYCLE_KEYS.forEach(function (name) {
    if (hasOwn(mpComponentOptions, name)) {
      (vueComponentOptions[COMPONENT_LIFECYCLE[name]] || (vueComponentOptions[COMPONENT_LIFECYCLE[name]] = [])).
      push(mpComponentOptions[name]);
    }
  });
}

var mpBehaviors = {
  'wx://form-field': {},
  'wx://component-export': {} };


function callDefinitionFilter(mpComponentOptions) {var

  behaviors =

  mpComponentOptions.behaviors,definitionFilter = mpComponentOptions.definitionFilter;

  var behaviorDefinitionFilters = [];

  if (Array.isArray(behaviors)) {
    behaviors.forEach(function (behavior) {
      behavior = typeof behavior === 'string' ? mpBehaviors[behavior] : behavior;
      if (behavior.definitionFilter) {
        behaviorDefinitionFilters.push(behavior.definitionFilter);
        behavior.definitionFilter.call(null, mpComponentOptions, []);
      }
    });
  }

  if (isFn(definitionFilter)) {
    return function (defFields) {
      definitionFilter(defFields, behaviorDefinitionFilters);
    };
  }
}

function parseDefinitionFilter(mpComponentOptions, vueComponentOptions) {
  callDefinitionFilter(mpComponentOptions);
}

function parseBehavior(behavior) {var

  data =



  behavior.data,methods = behavior.methods,behaviors = behavior.behaviors,properties = behavior.properties;

  var vueComponentOptions = {
    watch: {},
    mpOptions: {
      mpObservers: [] } };



  parseData(data, vueComponentOptions);
  parseMethods(methods, vueComponentOptions);
  parseBehaviors(behaviors, vueComponentOptions);
  parseProperties(properties, vueComponentOptions);

  parseLifecycle(behavior, vueComponentOptions);
  parseDefinitionFilter(behavior);

  return vueComponentOptions;
}

var BEHAVIORS = {
  'wx://form-field': {
    beforeCreate: function beforeCreate() {
      var mpOptions = this.$options.mpOptions;
      if (!mpOptions.properties) {
        mpOptions.properties = Object.create(null);
      }

      var props = mpOptions.properties;
      // TODO form submit,reset
      if (!hasOwn(props, 'name')) {
        props.name = {
          type: String };

      }
      if (!hasOwn(props, 'value')) {
        props.value = {
          type: String // 默认类型调整为 String,否则默认值为 null,导致一些自定义 input 显示不正确
        };
      }
    } } };



function parseBehaviors(behaviors, vueComponentOptions) {
  if (!behaviors) {
    return;
  }
  behaviors.forEach(function (behavior) {
    if (typeof behavior === 'string') {
      BEHAVIORS[behavior] && vueComponentOptions.mixins.push(BEHAVIORS[behavior]);
    } else {
      vueComponentOptions.mixins.push(parseBehavior(behavior));
    }
  });
}

function parseSinglePath(path) {
  return path.split('.');
}

function parseMultiPaths(paths) {
  return paths.split(',').map(function (path) {return parseSinglePath(path);});
}

function parseObservers(observers, vueComponentOptions) {
  if (!observers) {
    return;
  }var


  mpObservers =
  vueComponentOptions.mpOptions.mpObservers;

  Object.keys(observers).forEach(function (path) {
    mpObservers.push({
      paths: parseMultiPaths(path),
      observer: observers[path] });

  });
}

function relative(from, to) {
  if (to.indexOf('/') === 0) {
    from = '';
  }
  var fromArr = from.split('/');
  var toArr = to.split('/');
  fromArr.pop();
  while (toArr.length) {
    var part = toArr.shift();
    if (part !== '' && part !== '.') {
      if (part !== '..') {
        fromArr.push(part);
      } else {
        fromArr.pop();
      }
    }
  }
  return fromArr.join('/');
}

function parseRelations(relations, vueComponentOptions) {
  if (!relations) {
    return;
  }
  Object.keys(relations).forEach(function (name) {
    var relation = relations[name];
    relation.name = name;
    relation.target = relation.target ? String(relation.target) : relative(global.__wxRoute, name);
  });
  vueComponentOptions.mpOptions.relations = relations;
}

function parseExternalClasses(externalClasses, vueComponentOptions) {
  if (!externalClasses) {
    return;
  }
  if (!Array.isArray(externalClasses)) {
    externalClasses = [externalClasses];
  }
  vueComponentOptions.mpOptions.externalClasses = externalClasses;
  if (!vueComponentOptions.mpOptions.properties) {
    vueComponentOptions.mpOptions.properties = Object.create(null);
  }
  externalClasses.forEach(function (externalClass) {
    vueComponentOptions.mpOptions.properties[camelize(externalClass)] = {
      type: String,
      value: '' };

  });
}

function parseLifetimes(lifetimes, vueComponentOptions) {
  if (!lifetimes) {
    return;
  }
  parseLifecycle(lifetimes, vueComponentOptions);
}

function parsePageLifetimes(pageLifetimes, vueComponentOptions) {
  if (!pageLifetimes) {
    return;
  }
  PAGE_LIFETIMES_KEYS.forEach(function (key) {
    var lifetimeFn = pageLifetimes[key];
    isFn(lifetimeFn) && (vueComponentOptions[PAGE_LIFETIMES[key]] = lifetimeFn);
  });
}

function parseComponent(mpComponentOptions) {var

  data =









  mpComponentOptions.data,options = mpComponentOptions.options,methods = mpComponentOptions.methods,behaviors = mpComponentOptions.behaviors,lifetimes = mpComponentOptions.lifetimes,observers = mpComponentOptions.observers,relations = mpComponentOptions.relations,properties = mpComponentOptions.properties,pageLifetimes = mpComponentOptions.pageLifetimes,externalClasses = mpComponentOptions.externalClasses;

  var vueComponentOptions = {
    mixins: [],
    props: {},
    watch: {},
    mpOptions: {
      mpObservers: [] } };



  parseComponents(vueComponentOptions);

  parseData(data, vueComponentOptions);
  parseOptions(options, vueComponentOptions);
  parseMethods(methods, vueComponentOptions);
  parseBehaviors(behaviors, vueComponentOptions);
  parseLifetimes(lifetimes, vueComponentOptions);
  parseObservers(observers, vueComponentOptions);
  parseRelations(relations, vueComponentOptions);
  parseProperties(properties, vueComponentOptions);
  parsePageLifetimes(pageLifetimes, vueComponentOptions);
  parseExternalClasses(externalClasses, vueComponentOptions);

  parseLifecycle(mpComponentOptions, vueComponentOptions);
  parseDefinitionFilter(mpComponentOptions);

  return vueComponentOptions;
}

function initRelationHandlers(type, handler, target, ctx) {
  if (!handler) {
    return;
  }
  var name = "_$".concat(type, "Handlers");
  (ctx[name] || (ctx[name] = [])).push(function () {
    handler.call(ctx, target);
  });
}

function initLinkedHandlers(relation, target, ctx) {
  var type = 'linked';
  var name = relation.name;
  var relationNodes = ctx._$relationNodes || (ctx._$relationNodes = Object.create(null));
  (relationNodes[name] || (relationNodes[name] = [])).push(target);
  initRelationHandlers(type, relation[type], target, ctx);
}

function initUnlinkedHandlers(relation, target, ctx) {
  var type = 'unlinked';
  initRelationHandlers(type, relation[type], target, ctx);
}

function findParentRelation(parentVm, target, type) {
  var relations = parentVm &&
  parentVm.$options.mpOptions &&
  parentVm.$options.mpOptions.relations;

  if (!relations) {
    return [];
  }
  var name = Object.keys(relations).find(function (name) {
    var relation = relations[name];
    return relation.target === target && relation.type === type;
  });
  if (!name) {
    return [];
  }
  return [relations[name], parentVm];
}

function initParentRelation(vm, childRelation, match) {var _match =
  match(vm, vm.$options.mpOptions.path),_match2 = _slicedToArray(_match, 2),parentRelation = _match2[0],parentVm = _match2[1];
  if (!parentRelation) {
    return;
  }

  initLinkedHandlers(parentRelation, vm, parentVm);
  initLinkedHandlers(childRelation, parentVm, vm);

  initUnlinkedHandlers(parentRelation, vm, parentVm);
  initUnlinkedHandlers(childRelation, parentVm, vm);
}

function initRelation(relation, vm) {
  var type = relation.type;
  if (type === 'parent') {
    initParentRelation(vm, relation, function matchParent(vm, target) {
      return findParentRelation(vm.$parent, target, 'child');
    });
  } else if (type === 'ancestor') {
    initParentRelation(vm, relation, function matchAncestor(vm, target) {
      var $parent = vm.$parent;
      while ($parent) {
        var ret = findParentRelation($parent, target, 'descendant');
        if (ret.length) {
          return ret;
        }
        $parent = $parent.$parent;
      }
      return [];
    });
  }
}

function initRelations(vm) {var _ref =


  vm.$options.mpOptions || {},relations = _ref.relations;
  if (!relations) {
    return;
  }
  Object.keys(relations).forEach(function (name) {
    initRelation(relations[name], vm);
  });
}

function handleRelations(vm, type) {
  // TODO 需要移除 relationNodes
  var handlers = vm["_$".concat(type, "Handlers")];
  if (!handlers) {
    return;
  }
  handlers.forEach(function (handler) {return handler();});
}

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop };


function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function setDataByExprPath(exprPath, value, data) {
  var keys = exprPath.replace(/\[(\d+?)\]/g, '.$1').split('.');
  keys.reduce(function (obj, key, idx) {
    if (idx === keys.length - 1) {
      obj[key] = value;
    } else {
      if (typeof obj[key] === 'undefined') {
        obj[key] = {};
      }
      return obj[key];
    }
  }, data);
  return keys.length === 1;
}

function setData(data, callback) {var _this = this;
  if (!isPlainObject(data)) {
    return;
  }
  Object.keys(data).forEach(function (key) {
    if (setDataByExprPath(key, data[key], _this.data)) {
      !hasOwn(_this, key) && proxy(_this, SOURCE_KEY, key);
    }
  });
  this.$forceUpdate();
  isFn(callback) && this.$nextTick(callback);
}

/**
   * https://github.com/swan-team/swan-js/blob/61e2a63f7aa576b5daafbe77fdfa7c65b977060c/src/utils/index.js
   */

var _toString$1 = Object.prototype.toString;
/**
                                              * 深度assign的函数
                                              * @param {Object} targetObject 要被拷贝的目标对象
                                              * @param {Object} originObject 拷贝的源对象
                                              * @return {Object} merge后的对象
                                              */
var deepAssign = function deepAssign() {var targetObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};var originObject = arguments.length > 1 ? arguments[1] : undefined;
  var originType = _toString$1.call(originObject);
  if (originType === '[object Array]') {
    targetObject = originObject.slice(0);
    return targetObject;
  } else if (originType === '[object Object]') {
    for (var key in originObject) {
      targetObject[key] = deepAssign(targetObject[key], originObject[key]);
    }
    return targetObject;
  } else if (originType === '[object Date]') {
    return new Date(originObject.getTime());
  } else if (originType === '[object RegExp]') {
    var target = String(originObject);
    var lastIndex = target.lastIndexOf('/');
    return new RegExp(target.slice(1, lastIndex), target.slice(lastIndex + 1));
  }
  return originObject;
};

/**
    * 深度拷贝逻辑，不同于lodash等库，但是与微信一致
    * @param {*} [originObj] 原对象
    * @return {Object|Array} 拷贝结果
    */
var deepClone = function deepClone(originObj) {
  return deepAssign(_toString$1.call(originObj) === '[object Array]' ? [] : {}, originObj);
};

var PROP_DEFAULT_VALUES = (_PROP_DEFAULT_VALUES = {}, _defineProperty(_PROP_DEFAULT_VALUES,
String, ''), _defineProperty(_PROP_DEFAULT_VALUES,
Number, 0), _defineProperty(_PROP_DEFAULT_VALUES,
Boolean, false), _defineProperty(_PROP_DEFAULT_VALUES,
Object, null), _defineProperty(_PROP_DEFAULT_VALUES,
Array, []), _defineProperty(_PROP_DEFAULT_VALUES,
null, null), _PROP_DEFAULT_VALUES);


function getDefaultVal(propType) {
  return PROP_DEFAULT_VALUES[propType];
}

function getPropertyVal(options) {
  if (isPlainObject(options)) {
    if (hasOwn(options, 'value')) {
      return options.value;
    }
    return getDefaultVal(options.type);
  }
  return getDefaultVal(options);
}

function getType(propOptions) {
  return isPlainObject(propOptions) ? propOptions.type : propOptions;
}

function validateProp(key, propsOptions, propsData, vm) {
  var value = propsData[key];
  if (value !== undefined) {
    var propOptions = propsOptions[key];
    var type = getType(propOptions);
    value = formatVal(value, type);
    var observer = propOptions && propOptions.observer;
    if (observer) {
      // 初始化时,异步触发 observer,否则 observer 中无法访问 methods 或其他
      setTimeout(function () {
        observe(observer, vm, value);
      }, 4);
    }
    return value;
  }
  return getPropertyVal(propsOptions[key]);
}

function formatVal(val, type) {
  if (type === Boolean) {
    return !!val;
  } else if (type === String) {
    return String(val);
  }
  return val;
}

function observe(observer, vm, newVal, oldVal) {
  try {
    if (typeof observer === 'function') {
      observer.call(vm, newVal, oldVal);
    } else if (typeof observer === 'string' &&
    typeof vm[observer] === 'function')
    {
      vm[observer](newVal, oldVal);
    }
  } catch (err) {
    console.error("execute observer ".concat(observer, " callback fail! err: ").concat(err));
  }
}

function initProperties(vm, instanceData) {
  var properties = vm.$options.mpOptions.properties;
  if (!properties) {
    return;
  }

  var propsData = deepClone(vm.$options.propsData) || {};var _loop = function _loop(

  key) {
    var observer = isPlainObject(properties[key]) ? properties[key].observer : false;
    var value = validateProp(key, properties, propsData, vm);
    Object.defineProperty(instanceData, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return value;
      },
      set: function set(newVal) {
        var oldVal = value;
        /* eslint-disable no-self-compare */
        if (newVal === value || newVal !== newVal && value !== value) {
          return;
        }
        // TODO 临时方案,clone array
        value = Array.isArray(newVal) ? newVal.slice(0) : newVal;
        if (observer) {
          observe(observer, vm, newVal, oldVal);
        }
        // 触发渲染
        vm.$forceUpdate();
      } });};for (var key in properties) {_loop(key);

  }
}

function updateProperties(vm) {
  var properties = vm.$options.mpOptions && vm.$options.mpOptions.properties;
  var propsData = vm.$options.propsData;
  if (propsData && properties) {
    Object.keys(properties).forEach(function (key) {
      if (hasOwn(propsData, key)) {
        vm[key] = formatVal(propsData[key], getType(properties[key]));
      }
    });
  }
}

function initState(vm) {
  var instanceData = JSON.parse(JSON.stringify(vm.$options.mpOptions.data || {}));

  vm[SOURCE_KEY] = instanceData;

  var propertyDefinition = {
    get: function get() {
      return vm[SOURCE_KEY];
    },
    set: function set(value) {
      vm[SOURCE_KEY] = value;
    } };


  Object.defineProperties(vm, {
    data: propertyDefinition,
    properties: propertyDefinition });


  vm.setData = setData;

  initProperties(vm, instanceData);

  Object.keys(instanceData).forEach(function (key) {
    proxy(vm, SOURCE_KEY, key);
  });
}

function initMethods(vm) {
  var oldEmit = vm.$emit;
  vm.triggerEvent = function (eventName, detail, options) {
    var target = {
      dataset: vm.$el.dataset };


    var event = {
      target: target,
      currentTarget: target,
      detail: detail,
      preventDefault: noop,
      stopPropagation: noop };


    oldEmit.call(vm, eventName, event);
  };
  // 主要是Vant 自己封装了 $emit,放到 methods 中会触发 Vue 的警告,索性,框架直接重写该方法
  vm.$emit = function () {
    vm.triggerEvent.apply(vm, arguments);
  };
  vm.getRelationNodes = function (relationKey) {
    // 需要过滤已被销毁的vm
    /* eslint-disable  no-mixed-operators */
    return (vm._$relationNodes && vm._$relationNodes[relationKey] || []).filter(function (vm) {return !vm._isDestroyed;});
  };

  vm._$updateProperties = updateProperties;
}

function handleObservers(vm) {
  var watch = vm.$options.watch;
  if (!watch) {
    return;
  }
  Object.keys(watch).forEach(function (name) {
    var observer = watch[name];
    if (observer.mounted) {
      var val = vm[name];
      var handler = observer.handler;
      if (typeof handler === 'string') {
        handler = vm[handler];
      }
      handler && handler.call(vm, val, val);
    }
  });
}

var polyfill = {
  beforeCreate: function beforeCreate() {
    // 取消 development 时的 Proxy,避免小程序组件模板中使用尚未定义的属性告警
    this._renderProxy = this;

    this._$self = this;
    this._$noop = noop;
  },
  created: function created() {// properties 中可能会访问 methods,故需要在 created 中初始化
    initState(this);
    initMethods(this);
    initRelations(this);
  },
  mounted: function mounted() {
    handleObservers(this);
  },
  destroyed: function destroyed() {
    handleRelations(this, 'unlinked');
  } };


global.__wxRoute = '';
global.__wxComponents = Object.create(null);
global.__wxVueOptions = Object.create(null);

function Page(options) {
  var pageOptions = parsePage(options);
  pageOptions.mixins.unshift(polyfill);
  pageOptions.mpOptions.path = global.__wxRoute;
  global.__wxComponents[global.__wxRoute] = pageOptions;
}

function initRelationsHandler(vueComponentOptions) {
  // linked 需要在当前组件 attached 之后再执行
  if (!vueComponentOptions.onServiceAttached) {
    vueComponentOptions.onServiceAttached = [];
  }
  vueComponentOptions.onServiceAttached.push(function onServiceAttached() {
    handleRelations(this, 'linked');
  });
}

function Component(options) {
  var componentOptions = parseComponent(options);
  componentOptions.mixins.unshift(polyfill);
  componentOptions.mpOptions.path = global.__wxRoute;
  initRelationsHandler(componentOptions);
  global.__wxComponents[global.__wxRoute] = componentOptions;
}

function Behavior(options) {
  return options;
}

var nextTick = _vue.default.nextTick;exports.nextTick = nextTick;

var index = uni.__$wx__;var _default =

index;exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ 19)))

/***/ })
],[[0,"app-config"]]]);